<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Каталог деталей и наборов LEGO</title>

  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="manifest" href="site.webmanifest">
  <link rel="shortcut icon" href="favicon.ico">
  <meta name="msapplication-TileColor" content="#1a202c">
  <meta name="theme-color" content="#1a202c">

  <meta property="og:title" content="Каталог деталей и наборов LEGO">
  <meta property="og:description" content="Современное веб-приложение для каталогизации вашей личной коллекции LEGO. Включает детали, наборы и минифигурки в едином удобном интерфейсе.">
  <meta property="og:image" content="ogimage.png">
  <meta property="og:type" content="website">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            'sans': ['Inter', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial', 'sans-serif'],
            'mono': ['JetBrains Mono', 'SF Mono', 'Monaco', 'Cascadia Code', 'Roboto Mono', 'Consolas', 'Courier New', 'monospace'],
          },
          letterSpacing: {
            'tighter': '-0.05em',
            'tight': '-0.025em',
            'normal': '0em',
            'wide': '0.025em',
            'wider': '0.05em',
            'widest': '0.1em',
          }
        }
      }
    }
  </script>

      <style>
    body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        /* Защита от случайного масштабирования */
        touch-action: manipulation;
        font-feature-settings: 'cv02', 'cv03', 'cv04', 'cv11';
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }
    
    /* Дополнительная защита от масштабирования на мобильных устройствах */
    @media (max-width: 768px) {
        body {
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
    }
    
    .no-scrollbar::-webkit-scrollbar {
        display: none;
    }
    
    .no-scrollbar {
        -ms-overflow-style: none;
        scrollbar-width: none;
    }
    
    #search-input::-webkit-search-cancel-button {
        -webkit-appearance: none;
        appearance: none;
        display: none;
    }
    
    /* Стили для выравнивания высоты кнопок в панели поиска */
    #search-button,
    #filter-button {
        height: 40px; /* Фиксированная высота кнопок */
        min-height: 40px;
        width: 40px; /* Делаем кнопки квадратными */
        min-width: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0; /* Предотвращаем сжатие */
    }
    
    #clear-search {
        height: 40px;
        min-height: 40px;
        width: 40px; /* Ширина кнопки очистки */
        min-width: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0; /* Предотвращаем сжатие */
        right: 0;
        top: 0;
        bottom: 0;
    }
    
    /* Выравниваем высоту поля поиска с кнопками */
    #search-input {
        height: 40px; /* Такая же высота как у кнопок */
        min-height: 40px;
        box-sizing: border-box;
        padding-top: 0.5rem; /* 8px */
        padding-bottom: 0.5rem; /* 8px */
    }
    
    /* Дополнительные стили для лучшего выравнивания панели поиска */
    .flex.items-center.space-x-2.w-full.max-w-sm {
        align-items: center; /* Возвращаем center вместо stretch */
    }
    
    /* Скругленные углы для разделительной линии в карточках */
    .card-image-container {
        border-bottom-left-radius: 0.5rem;
        border-bottom-right-radius: 0.5rem;
    }
    
    /* Скругленные углы для информационного блока в карточках */
    .card-info-container {
        border-top-left-radius: 0.5rem;
        border-top-right-radius: 0.5rem;
    }
    
    /* Адаптивная сетка для папок деталей */
    .folder-grid {
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    }
    
    /* На малых устройствах (до 640px) - минимум 2 карточки в ширину */
    @media (max-width: 640px) {
        .folder-grid {
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        }
    }
    
    /* Улучшенная типографика */
    h1, h2, h3, h4, h5, h6 {
        line-height: 1.2;
    }
    
    /* Улучшенный текст в карточках */
    .card-title {
        line-height: 1.3;
    }
    
    /* Улучшенная читаемость для длинного текста */
    p, span, div {
        line-height: 1.5;
        text-rendering: optimizeLegibility;
    }
    
    /* Специальные стили для заголовка */
    .main-title {
        line-height: 1.1;
    }
    
    /* Моноширинный шрифт для технических данных */
    .font-mono, code, pre {
        font-weight: 500;
        letter-spacing: 0.025em;
    }
    
    /* Улучшенная читаемость для длинного текста */
    p, span, div {
        line-height: 1.5;
        text-rendering: optimizeLegibility;
    }
    
    /* Специальные стили для заголовка */
    .main-title {
        font-weight: 800;
        letter-spacing: -0.05em;
        line-height: 1.1;
    }
    
    /* На очень малых устройствах (до 480px) - минимум 2 карточки в ширину */
    @media (max-width: 480px) {
        .folder-grid {
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
        }
    }
    

    
    /* Адаптивная сетка для основного контента деталей */
    .parts-grid {
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    }
    
    /* На малых устройствах (до 640px) - минимум 2 карточки в ширину */
    @media (max-width: 640px) {
        .parts-grid {
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        }
    }
    
    /* На очень малых устройствах (до 480px) - минимум 2 карточки в ширину */
    @media (max-width: 480px) {
        .parts-grid {
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
        }
    }
    
    /* Адаптивная сетка для наборов и минифигурок */
    .sets-minifigs-grid {
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    }
    
    /* На малых устройствах (до 640px) - минимум 2 карточки в ширину */
    @media (max-width: 640px) {
        .sets-minifigs-grid {
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        }
    }
    
    /* На очень малых устройствах (до 480px) - минимум 2 карточки в ширину */
    @media (max-width: 480px) {
        .sets-minifigs-grid {
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
        }
    }
    
    /* Адаптивные стили для информации о карточках */
    .card-info-text {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    /* На малых устройствах делаем текст еще более компактным */
    @media (max-width: 480px) {
        .card-info-text {
            font-size: 0.65rem;
        }
    }
    
    /* Адаптивные стили для заголовков карточек */
.card-title {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* На малых устройствах делаем заголовки более компактными */
@media (max-width: 480px) {
    .card-title {
        font-size: 0.75rem;
        line-height: 1.2;
    }
}

/* Палитра цветов в модальном окне детали */
.color-palette-container {
    max-height: 12rem; /* 48 * 0.25 = 12rem (192px) */
    overflow-y: auto;
    /* Добавляем отступ снизу для видимости скругленных углов */
    padding-bottom: 0.5rem;
    /* Обеспечиваем видимость скругленных углов */
    border-bottom-left-radius: 0.5rem;
    border-bottom-right-radius: 0.5rem;
}

/* Скругление нижних углов блока палитры */
.color-palette-wrapper {
    border-bottom-left-radius: 0.5rem;
    border-bottom-right-radius: 0.5rem;
}

/* Скругление нижних углов контейнера с прокруткой */
.color-palette-container {
    border-bottom-left-radius: 0.5rem;
    border-bottom-right-radius: 0.5rem;
}

/* Скругление нижних углов внутреннего контейнера с цветами */
.color-palette-inner {
    border-bottom-left-radius: 0.5rem;
    border-bottom-right-radius: 0.5rem;
}

/* Стили для градиента прокрутки */
.color-palette-gradient {
    border-bottom-left-radius: 0.5rem;
    border-bottom-right-radius: 0.5rem;
}

/* Стили для индикаторов в палитре цветов */
.indicator-white {
    width: 0.5rem;
    height: 0.5rem;
    background-color: white;
    border-radius: 9999px;
}

.indicator-white-with-border {
    width: 0.5rem;
    height: 0.5rem;
    background-color: white;
    border-radius: 9999px;
    border: 1px solid black;
    box-shadow: 0 0 0 1px black;
}

/* Стили для градиентного заголовка */
.bg-gradient-to-r {
    background: linear-gradient(to right, var(--tw-gradient-stops));
}

.from-blue-400 {
    --tw-gradient-from: #60a5fa;
    --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to, rgba(96, 165, 250, 0));
}

.via-blue-500 {
    --tw-gradient-stops: var(--tw-gradient-from), #3b82f6, var(--tw-gradient-to, rgba(59, 130, 246, 0));
}

.to-blue-600 {
    --tw-gradient-to: #2563eb;
}

.bg-clip-text {
    background-clip: text;
    -webkit-background-clip: text;
}

.text-transparent {
    color: transparent;
}







/* Отступы между блоками в модальном окне детали */
.modal-section-spacing {
    margin-bottom: 1.5rem; /* 24px */
}

/* Отступы в заголовках секций */
.modal-section-title {
    margin-bottom: 0.75rem; /* 12px */
}
    
    /* Исправляем layout на малых экранах */
    @media (max-width: 640px) {
        .flex.justify-between.items-center.gap-4 {
            gap: 1rem !important;
        }
    }
    
    /* Обеспечиваем одинаковую высоту для всех элементов в панели поиска */
    #search-input,
    #search-button,
    #filter-button {
        box-sizing: border-box;
    }
    
    /* Сохраняем стандартное расстояние между полем поиска и кнопками */
    .flex.items-center.space-x-2 > * + * {
        margin-left: 0.5rem !important; /* 8px - стандартное расстояние space-x-2 */
    }
    
    /* Увеличиваем ширину поля поиска на малых устройствах */
    @media (max-width: 640px) {
        /* Убираем ограничение max-w-sm на малых экранах */
        .flex.items-center.space-x-2.w-full.max-w-sm {
            max-width: none !important;
            width: 100% !important;
        }
        
        /* Увеличиваем поле поиска */
        .flex.items-center.space-x-2.w-full.max-w-sm .relative.flex-grow {
            flex-grow: 1 !important;
            min-width: 0 !important;
        }
        
        /* Сохраняем стандартное расстояние между элементами на малых экранах */
        .flex.items-center.space-x-2 > * + * {
            margin-left: 0.5rem !important;
        }
        
        /* Исправляем отступы кнопки sidebar-toggle на малых экранах */
        .sidebar-toggle-btn {
            margin-left: -0.5rem !important; /* Перемещаем ближе к левому краю */
            margin-right: 1rem !important;
        }
        
        /* Убираем лишние отступы у заголовка */
        .flex.items-center h1 {
            margin-left: 0 !important;
        }
    }
    
    /* Адаптивный размер текста для поля поиска на малых экранах */
    @media (max-width: 640px) {
        #search-input {
            font-size: 13px;
        }
    }
    
    @media (max-width: 480px) {
        #search-input {
            font-size: 12px;
        }
    }
    
    /* Медиа-запрос для мобильных устройств */
    @media (max-width: 640px) {
        #search-button,
        #filter-button {
            height: 40px;
            min-height: 40px;
            width: 40px;
            min-width: 40px;
        }
        
        #clear-search {
            height: 40px;
            min-height: 40px;
            width: 36px;
            min-width: 36px;
        }
        
        /* Увеличиваем правый отступ поля ввода для кнопки очистки */
        #search-input {
            padding-right: 2.5rem; /* 40px - достаточно места для кнопки очистки */
        }
    }
    
    .checkerboard {
        background-image: linear-gradient(45deg, #374151 25%, transparent 25%), 
                          linear-gradient(-45deg, #374151 25%, transparent 25%), 
                          linear-gradient(45deg, transparent 75%, #374151 75%), 
                          linear-gradient(-45deg, transparent 75%, #374151 75%);
        background-size: 8px 8px;
        background-position: 0 0, 0 4px, 4px -4px, -4px 0;
    }
    
    .modal-hidden {
        visibility: hidden !important;
        opacity: 0 !important;
        pointer-events: none !important;
    }
    
    .viewer-hidden {
        visibility: hidden !important;
        opacity: 0 !important;
        pointer-events: none !important;
    }
    
    /* Стили для кнопок закрытия модальных окон */
    .modal-close-btn {
        position: relative;
        width: 32px;
        height: 32px;
        background: #dc2626;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border: none;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .modal-close-btn:hover {
        background: #b91c1c;
        transform: scale(1.1) rotate(2deg);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
    }
    
    .modal-close-btn:active {
        transform: scale(0.95) rotate(0deg);
    }
    
    .modal-close-btn svg {
        width: 16px;
        height: 16px;
        stroke-width: 2.5;
        transition: transform 0.3s ease;
    }
    
    .modal-close-btn:hover svg {
        transform: scale(1.1);
    }
    
    /* Специальный стиль для кнопки закрытия боковой панели */
    .modal-close-btn.lg\:hidden {
        background: transparent;
        color: #6b7280;
        box-shadow: none;
        border: none;
    }
    
    .modal-close-btn.lg\:hidden:hover {
        background: transparent;
        color: #9ca3af;
        transform: none;
    }
    
    .modal-close-btn.lg\:hidden svg {
        width: 20px;
        height: 20px;
        stroke-width: 2;
        transition: color 0.2s ease;
    }
    
    .modal-close-btn.lg\:hidden:hover svg {
        transform: none;
    }
    
    /* Стили для кнопки открытия боковой панели */
    .sidebar-toggle-btn {
        position: relative;
        width: 48px;
        height: 48px;
        background: transparent;
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #6b7280;
        transition: color 0.2s ease;
        cursor: pointer;
        margin-right: 1rem;
        margin-left: -0.5rem; /* Перемещаем ближе к левому краю */
        border-radius: 8px;
        padding: 12px;
    }
    
    .sidebar-toggle-btn:hover {
        color: #9ca3af;
        background: rgba(107, 114, 128, 0.1);
        transform: none;
    }
    
    .sidebar-toggle-btn:active {
        transform: scale(0.95);
        background: rgba(107, 114, 128, 0.2);
    }
    
    .sidebar-toggle-btn svg {
        width: 24px;
        height: 24px;
        stroke-width: 2.5;
        transition: color 0.2s ease;
    }
    
    .sidebar-toggle-btn:hover svg {
        transform: none;
    }
    
    .sidebar-toggle-btn:focus-visible {
        outline: none;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        background: rgba(107, 114, 128, 0.1);
    }
    
    /* Анимации для кнопок закрытия */
    .modal-close-btn:not(.lg\:hidden) {
        animation: buttonAppear 0.4s ease-out;
    }
    
  
    .sidebar-hint-close {
        animation: buttonAppear 0.4s ease-out 0.2s both;
    }
    
    @keyframes buttonAppear {
        0% {
            opacity: 0;
            transform: scale(0.8) rotate(-10deg);
        }
        50% {
            transform: scale(1.05) rotate(2deg);
        }
        100% {
            opacity: 1;
            transform: scale(1) rotate(0deg);
        }
    }
    
    /* Пульсация для кнопки sidebar-toggle при первом показе */
    .sidebar-toggle-btn.pulse {
        animation: buttonPulse 2s ease-in-out infinite;
    }
    
    @keyframes buttonPulse {
        0%, 100% {
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), 0 0 0 0 rgba(107, 114, 128, 0.7);
        }
        50% {
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), 0 0 0 10px rgba(107, 114, 128, 0);
        }
    }
    
    .loader {
        border: 4px solid #4a5568;
        border-top: 4px solid #4299e1;
        border-radius: 50%;
        width: 48px;
        height: 48px;
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    
    @keyframes fadeOut {
        from { opacity: 1; }
        to { opacity: 0; }
    }
    
    @keyframes scaleIn {
        from { 
            opacity: 0; 
            transform: scale(0.9) translateY(10px); 
        }
        to { 
            opacity: 1; 
            transform: scale(1) translateY(0); 
        }
    }
    
    @keyframes scaleOut {
        from { 
            opacity: 1; 
            transform: scale(1) translateY(0); 
        }
        to { 
            opacity: 0; 
            transform: scale(0.9) translateY(-10px); 
        }
    }
    
    /* Убрали @keyframes для backdrop, теперь используем transition */
    
    /* Стили для указателя sidebar-toggle */
    .sidebar-hint {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
        color: white;
        padding: 20px 24px;
        border-radius: 16px;
        font-size: 14px;
        line-height: 1.5;
        text-align: center;
        z-index: 1000;
        max-width: 320px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(59, 130, 246, 0.1);
        animation: hintFadeIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        pointer-events: auto;
        border: 1px solid rgba(59, 130, 246, 0.2);
        backdrop-filter: blur(10px);
    }
    
    .sidebar-hint::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(147, 51, 234, 0.1) 100%);
        border-radius: 16px;
        z-index: -1;
    }
    
    .sidebar-hint::after {
        content: '';
        position: absolute;
        top: -10px;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 10px solid transparent;
        border-right: 10px solid transparent;
        border-bottom: 10px solid #1f2937;
        filter: drop-shadow(0 -2px 4px rgba(0, 0, 0, 0.3));
    }
    
    .sidebar-hint-icon {
        display: inline-block;
        width: 48px;
        height: 48px;
        background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
        border-radius: 12px;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        animation: iconPulse 2s ease-in-out infinite;
    }
    
    .sidebar-hint-title {
        font-size: 16px;
        font-weight: 600;
        color: #f3f4f6;
        margin-bottom: 8px;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }
    
    .sidebar-hint-text {
        color: #d1d5db;
        font-size: 13px;
        line-height: 1.4;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }
    
    .sidebar-hint-close {
        position: absolute;
        top: 8px;
        right: 8px;
        width: 24px;
        height: 24px;
        background: #6b7280;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border: none;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        font-size: 14px;
        font-weight: bold;
        line-height: 1;
    }
    
    .sidebar-hint-close:hover {
        background: #4b5563;
        transform: scale(1.1) rotate(2deg);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
    }
    
    .sidebar-hint-close:active {
        transform: scale(0.95) rotate(0deg);
    }
    
    @keyframes hintFadeIn {
        from { 
            opacity: 0; 
            transform: translate(-50%, -50%) scale(0.9) translateY(10px);
        }
        to { 
            opacity: 1; 
            transform: translate(-50%, -50%) scale(1) translateY(0);
        }
    }
    
    @keyframes iconPulse {
        0%, 100% { 
            transform: scale(1) rotate(0deg);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        50% { 
            transform: scale(1.05) rotate(2deg);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
        }
    }
    
    .sidebar-hint-close {
        position: absolute;
        top: -12px;
        right: -12px;
        width: 28px;
        height: 28px;
        background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        pointer-events: auto;
        font-size: 18px;
        font-weight: bold;
        color: white;
        box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4), 0 0 0 2px rgba(255, 255, 255, 0.1);
        transition: all 0.2s ease;
        border: 2px solid rgba(255, 255, 255, 0.2);
    }
    
    .sidebar-hint-close:hover {
        background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
        transform: scale(1.1);
        box-shadow: 0 6px 16px rgba(239, 68, 68, 0.5), 0 0 0 3px rgba(255, 255, 255, 0.2);
    }
    
    .sidebar-hint-close:active {
        transform: scale(0.95);
    }
    
    /* Скрываем указатель на больших экранах */
    @media (min-width: 1024px) {
        .sidebar-hint {
            display: none !important;
        }
    }
    /* Тумблеры (анимированный слайдер) */
    .toggle-switch {
        position: relative;
        width: 42px;
        height: 22px;
        border-radius: 9999px;
        background: #374151; /* gray-700 - более темный для лучшего контраста */
        box-shadow: inset 0 0 0 2px rgba(255,255,255,0.1);
        transition: background .2s ease, box-shadow .2s ease, transform .2s ease;
        outline: none;
    }
    .toggle-switch .knob {
        position: absolute;
        top: 2px; left: 2px;
        width: 18px; height: 18px;
        border-radius: 9999px;
        background: #f3f4f6; /* gray-100 - более мягкий белый */
        box-shadow: 0 2px 6px rgba(0,0,0,.4);
        transition: transform .2s ease;
    }
    .toggle-switch.on { background: #2563eb; /* blue-600 - основной цвет сайта */ }
    .toggle-switch.on .knob { transform: translateX(20px); }
    .toggle-switch:focus-visible { box-shadow: 0 0 0 3px rgba(59,130,246,.45); }
    /* Анимация панели мультивыбора */
    @keyframes msSlideFadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    @keyframes msSlideFadeOut {
        from { opacity: 1; transform: translateY(0); }
        to { opacity: 0; transform: translateY(-10px); }
    }
    
    @keyframes fadeInUp {
        from { opacity: 0; transform: translateY(0.1rem) scale(0.995); }
        to { opacity: 1; transform: translateY(0) scale(1); }
    }
    
    /* Модальные окна - ВАЖНО: не отключать! */
    #modal-container,
    #filter-modal-container,
    #set-modal-container,
    #settings-modal-container,
    #minifig-modal-container,
    #colors-modal-container,
    #related-sets-modal-container,
    #image-viewer-container {
        opacity: 0;
        transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1), backdrop-filter 0.25s cubic-bezier(0.4, 0, 0.2, 1), visibility 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        backdrop-filter: blur(0px);
        visibility: hidden;
        pointer-events: none;
    }
    
    #modal-container.visible,
    #filter-modal-container.visible,
    #set-modal-container.visible,
    #settings-modal-container.visible,
    #minifig-modal-container.visible,
    #colors-modal-container.visible,
    #related-sets-modal-container.visible,
    #image-viewer-container.visible {
        opacity: 1;
        backdrop-filter: blur(4px);
        visibility: visible;
        pointer-events: auto;
    }
    
    /* Анимация сворачивания/разворачивания панелей */
    .collapse-panel {
        overflow: hidden;
        max-height: 0;
        opacity: 0;
        padding: 0 !important; /* убираем паддинги, чтобы не было лишнего отступа в свернутом состоянии */
        transition: max-height 0.25s ease, opacity 0.2s ease, padding 0.2s ease;
    }
    .collapse-panel.open {
        max-height: 1000px; /* достаточная высота для контента */
        opacity: 1;
        padding: 0.75rem !important; /* соответствие классу p-3 */
    }
    .rotate {
        transition: transform 0.2s ease;
    }
    .rotate-180 {
        transform: rotate(180deg);
    }
    
    /* Анимации кнопок в боковом меню */
    #sidebar-container button {
        transition: transform 0.15s ease-out, background-color 0.15s ease, color 0.15s ease, box-shadow 0.15s ease;
        will-change: transform;
    }
    #sidebar-container button:hover {
        transform: translateY(-1px);
    }
    #sidebar-container button:active {
        transform: translateY(0) scale(0.98);
    }
    #sidebar-container button:focus-visible {
        outline: none;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
    }
    /* Легкая анимация для иконок избранного в боковом меню */
    #sidebar-container [data-action="toggle-favorite-theme"],
    #sidebar-container [data-action="toggle-favorite-category"] {
        transition: transform 0.15s ease;
    }
    #sidebar-container [data-action="toggle-favorite-theme"]:active,
    #sidebar-container [data-action="toggle-favorite-category"]:active {
        transform: scale(0.9);
    }

    /* Анимации боковой панели */
    #sidebar-container {
        transition: transform 0.25s ease-in-out;
        will-change: transform;
    }
    #sidebar-backdrop {
        transition: opacity 0.2s ease-in-out;
    }
    
    /* Полноэкранный просмотр изображений */
    #image-viewer-container {
        cursor: default;
    }
    
    #image-viewer-container.zoomed {
        cursor: default;
    }
    
    #fullscreen-image {
        transition: all 0.3s ease-out;
        cursor: default;
        max-width: 100%;
        max-height: 100%;
    }
    
    #fullscreen-image.zoomed {
        cursor: default;
        /* Убираем transform, так как он теперь на обертке */
        max-width: 90%;
        max-height: 90%;
        object-fit: contain;
    }
    
    /* Контейнер для изображения с отступами */
    #image-viewer-container > div {
        transition: padding 0.3s ease-out;
        /* Убираем лишние отступы */
        padding: 0;
    }
    
    #image-viewer-container.zoomed > div {
        padding: 5% !important;
    }
    
    /* Центрируем обертку в контейнере */
    #image-viewer-container {
        display: flex;
        align-items: center;
        justify-content: center;
        /* Убираем лишние отступы */
        padding: 0;
        /* Предотвращаем растягивание содержимого */
        align-content: center;
        /* Улучшенное центрирование */
        text-align: center;
        /* Предотвращаем горизонтальное скроллирование */
        overflow: hidden;
    }
    
    /* Дополнительные стили для скругленных краев */
    .image-wrapper {
        /* Обертка точно по размеру содержимого */
        display: inline-block;
        /* Предотвращаем растягивание */
        width: fit-content;
        height: fit-content;
        /* Скругленные края */
        border-radius: 1rem;
        /* Тень */
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        /* Переходы */
        transition: all 0.3s ease-out;
        /* Отступы для фона */
        padding: 8px;
        /* Простой белый фон без шахматки */
        background-color: white;
        /* Убираем лишние ограничения */
        max-width: none;
        max-height: none;
        /* Улучшенное позиционирование */
        position: relative;
        /* Центрируем содержимое */
        text-align: center;
        /* Обрезаем содержимое по внутренним закругленным углам */
        overflow: hidden;
    }

    /* Чуть более крупные скругления на десктопах */
    @media (min-width: 1024px) {
        .image-wrapper {
            border-radius: 1.25rem;
        }
    }
    
    /* При увеличении улучшаем тень и масштабируем обертку */
    .image-wrapper.zoomed {
        box-shadow: 0 35px 60px -15px rgba(0, 0, 0, 0.3);
        transform: scale(1.5);
        transition: transform 0.3s ease-out;
        /* Увеличиваем отступы при масштабировании */
        padding: 12px;
        /* Центрируем увеличение относительно центра обертки */
        transform-origin: center;
        /* Сохраняем точный размер */
        width: fit-content;
        height: fit-content;
        /* Предотвращаем смещение */
        position: relative;
    }
    
    #fullscreen-image {
        /* Изображение помещается в экран */
        max-width: 90vw;
        max-height: 90vh;
        width: auto;
        height: auto;
        /* Улучшенное качество рендеринга */
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
        /* Убираем border-radius с изображения, так как он теперь на обертке */
        border-radius: 0;
        /* Объект-фит для правильного масштабирования */
        object-fit: contain;
        /* Предотвращаем влияние на размер обертки */
        flex-shrink: 0;
        /* Центрируем изображение в обертке */
        display: block;
        margin: 0 auto;
    }
    
    /* Гарантируем, что модальные окна всегда поверх */
    #modal-container,
    #set-modal-container,
    #minifig-modal-container,
    #filter-modal-container,
    #settings-modal-container {
        z-index: 50 !important;
        pointer-events: auto !important;
        overflow: hidden; /* Клипуем содержимое при анимации скрытия */
    }
    /* Модалка деталей должна быть поверх инвентарей наборов/минифигурок */
    #modal-container { z-index: 60 !important; }
    /* Модалка набора должна быть поверх связанных наборов */
    /* z-index управляется ModalManager */
    
    /* Прогресс прокрутки (вертикальный индикатор) */
    #scroll-progress {
        position: fixed;
        right: 2px;
        top: 12px;
        bottom: 12px;
        width: 5px;
        background: rgba(255,255,255,0.08);
        border-radius: 9999px;
        overflow: hidden;
        opacity: 0;
        transform: translateX(8px);
        transition: opacity .2s ease, transform .2s ease;
        z-index: 45;
        pointer-events: none;
    }
    #scroll-progress.visible { opacity: .9; transform: translateX(0); }
    #scroll-progress .bar {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 48px; /* размер маркера */
        background: linear-gradient(180deg, #60a5fa, #3b82f6);
        box-shadow: 0 0 10px rgba(59,130,246,.35);
        border-radius: inherit;
        transform: translateY(0);
    }
    /* Индикатор в модальном окне набора */
    #set-scroll-progress {
        position: absolute;
        right: 2px;
        top: 12px; /* будет скорректирован скриптом под высоту шапки модалки */
        bottom: 12px;
        width: 5px;
        background: rgba(255,255,255,0.08);
        border-radius: 9999px;
        overflow: hidden;
        opacity: 0;
        transform: translateX(8px);
        transition: opacity .2s ease, transform .2s ease;
        z-index: 15;
        pointer-events: none;
    }
    #set-scroll-progress.visible { opacity: .9; transform: translateX(0); }
    #set-scroll-progress .bar {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 48px;
        background: linear-gradient(180deg, #60a5fa, #3b82f6);
        box-shadow: 0 0 10px rgba(59,130,246,.35);
        border-radius: inherit;
        transform: translateY(0);
    }

    /* Индикатор в модальном окне минифигурки */
    #minifig-scroll-progress {
        position: absolute;
        right: 2px;
        top: 12px; /* будет скорректирован скриптом под высоту шапки модалки */
        bottom: 12px;
        width: 5px;
        background: rgba(255,255,255,0.08);
        border-radius: 9999px;
        overflow: hidden;
        opacity: 0;
        transform: translateX(8px);
        transition: opacity .2s ease, transform .2s ease;
        z-index: 15;
        pointer-events: none;
    }
    #minifig-scroll-progress.visible { opacity: .9; transform: translateX(0); }
    #minifig-scroll-progress .bar {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 48px; /* размер маркера */
        background: linear-gradient(180deg, #60a5fa, #3b82f6);
        box-shadow: 0 0 10px rgba(59,130,246,.35);
        border-radius: inherit;
        transform: translateY(0);
    }

    /* Индикатор в модальном окне связанных наборов */
    #related-sets-scroll-progress {
        position: absolute;
        right: 2px;
        top: 12px; /* будет скорректирован скриптом под высоту шапки модалки */
        bottom: 12px;
        width: 5px;
        background: rgba(255,255,255,0.08);
        border-radius: 9999px;
        overflow: hidden;
        opacity: 0;
        transform: translateX(8px);
        transition: opacity .2s ease, transform .2s ease;
        z-index: 15;
        pointer-events: none;
    }
    #related-sets-scroll-progress.visible { opacity: .9; transform: translateX(0); }
    #related-sets-scroll-progress .bar {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 48px;
        background: linear-gradient(180deg, #60a5fa, #3b82f6);
        box-shadow: 0 0 10px rgba(59,130,246,.35);
        border-radius: inherit;
        transform: translateY(0);
    }
    /* Индикатор в модальном окне цветов детали */
    #colors-scroll-progress {
        position: absolute;
        right: 2px;
        top: 12px;
        bottom: 12px;
        width: 5px;
        background: rgba(255,255,255,0.08);
        border-radius: 9999px;
        overflow: hidden;
        opacity: 0;
        transform: translateX(8px);
        transition: opacity .2s ease, transform .2s ease;
        z-index: 15;
        pointer-events: none;
    }
    #colors-scroll-progress.visible { opacity: .9; transform: translateX(0); }
    #colors-scroll-progress .bar {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 48px;
        background: linear-gradient(180deg, #60a5fa, #3b82f6);
        box-shadow: 0 0 10px rgba(59,130,246,.35);
        border-radius: inherit;
        transform: translateY(0);
    }
    /* Image viewer должен быть поверх модальных окон */
    #image-viewer-container.visible {
        pointer-events: auto !important;
        opacity: 1 !important;
    }
    
    /* Скрытый image viewer не должен блокировать клики */
    #image-viewer-container.viewer-hidden {
        z-index: -1 !important;
        pointer-events: none !important;
        opacity: 0 !important;
    }
    
    /* Кнопка закрытия всегда поверх и кликабельна */
    #image-viewer-close {
        pointer-events: auto !important;
    }
    
    /* Принудительно восстанавливаем pointer-events для модальных окон */
    #modal-container:not(.modal-hidden),
    #set-modal-container:not(.modal-hidden),
    #minifig-modal-container:not(.modal-hidden),
    #filter-modal-container:not(.modal-hidden),
    #settings-modal-container:not(.modal-hidden) {
        pointer-events: auto !important;
    }
    

    
    .modal-content-enter {
        animation: scaleIn 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    
    .modal-content-leave {
        animation: scaleOut 0.25s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }

    /* Клип контента и корректное происхождение трансформации при анимациях модалок */
    #modal-content,
    #set-modal-content,
    #minifig-modal-content,
    #filter-modal-content,
    #settings-modal-content {
        overflow: hidden;            /* чтобы содержимое не выходило за скругления */
        will-change: transform, opacity;
        contain: paint;              /* изоляция слоя для предотвращения артефактов */
    }
    .modal-content-enter,
    .modal-content-leave {
        transform-origin: center;
    }
    .modal-content-leave {
        box-shadow: none !important; /* убираем тень при скрытии, чтобы не выпирала */
    }
    
    /* Плавный переход размытия фона теперь управляется через transition выше */
    
    /* Image viewer также использует плавный переход размытия через transition выше */
    
    /* Transition для backdrop-filter управляется выше, анимации для контента остаются */
    
    .part-card.animate-in,
    .set-card.animate-in,
    .minifig-card.animate-in {
        opacity: 0;
        animation: fadeInUp 0.1s ease-out forwards;
    }

/* Анимации для всех экранов - МИНИМАЛЬНЫЕ */
.part-card.animate-in,.set-card.animate-in,.minifig-card.animate-in {
    animation-duration: 0.1s;
    animation-timing-function: ease-out;
    opacity: 0;
    animation-fill-mode: forwards;
}

/* Анимация для первой загрузки страницы - МИНИМАЛЬНАЯ */
@keyframes pageLoad {
    from {
        opacity: 0;
        transform: translateY(0.1rem) scale(0.995);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

.page-loading .part-card.animate-in,
.page-loading .set-card.animate-in,
.page-loading .minifig-card.animate-in {
    animation: pageLoad 0.1s ease-out forwards;
}

/* ВРЕМЕННО ОТКЛЮЧЕНО: Анимации при открытой боковой панели */
.sidebar-open-large .part-card.animate-in,
.sidebar-open-large .set-card.animate-in,
.sidebar-open-large .minifig-card.animate-in {
    /* animation-duration: 0.2s; */
    opacity: 1 !important;
    transform: none !important;
}
/* Анимации при переключении вкладок */
body.tab-switching .part-card,
body.tab-switching .set-card,
body.tab-switching .minifig-card {
    animation: none !important;
    opacity: 1 !important;
    transform: none !important;
}

/* ВРЕМЕННО ОТКЛЮЧЕНО: Анимация для результатов поиска и фильтрации */
.search-results .part-card,
.search-results .set-card,
.search-results .minifig-card {
    /* animation-duration: 0.25s; */
    opacity: 1 !important;
    transform: none !important;
}

/* ВРЕМЕННО ОТКЛЮЧЕНО: Анимация для пустых результатов */
.empty-results {
    /* animation: fadeInUp 0.5s cubic-bezier(0.4, 0, 0.2, 1) forwards; */
    opacity: 1 !important;
    transform: none !important;
}

/* ВРЕМЕННО ОТКЛЮЧЕНО: Анимация при изменении размера экрана */
@media (max-width: 768px) {
    .part-card.animate-in,
    .set-card.animate-in,
    .minifig-card.animate-in {
        /* animation-duration: 0.3s; */
        opacity: 1 !important;
        transform: none !important;
    }
}

/* ВРЕМЕННО ОТКЛЮЧЕНО: Анимация для мобильных устройств */
@media (max-width: 480px) {
    .part-card.animate-in,
    .set-card.animate-in,
    .minifig-card.animate-in {
        /* animation-duration: 0.25s; */
        opacity: 1 !important;
        transform: none !important;
    }
    
    /* Отключаем hover эффекты только на мобильных устройствах */
    .part-card:hover,
    .set-card:hover,
    .minifig-card:hover {
        transform: none !important;
    }
}

/* ВРЕМЕННО ОТКЛЮЧЕНО: Производительность карточек */
.part-card img,
.set-card img,
.minifig-card img {
    /* will-change: transform; */
    /* backface-visibility: hidden; */
    /* transform: translateZ(0); */
    /* transition: opacity 0.3s ease-in-out; */
    opacity: 1 !important;
}

/* ВРЕМЕННО ОТКЛЮЧЕНО: Анимация загрузки изображений */
.part-card img[loading],
.set-card img[loading],
.minifig-card img[loading] {
    opacity: 1 !important;
}

.part-card img:not([loading]),
.set-card img:not([loading]),
.minifig-card img:not([loading]) {
    opacity: 1 !important;
}

/* Эффекты для карточек: базовые переходы для hover-анимации */
.part-card,
.set-card,
.minifig-card {
    transition: transform 0.2s ease-out, box-shadow 0.2s ease-out !important;
    will-change: transform;
}

/* Легкое поднятие карточки при наведении */
.part-card:hover,
.set-card:hover,
.minifig-card:hover {
    transform: translateY(-6px) scale(1.03) !important;
    box-shadow: 0 25px 30px -5px rgba(0, 0, 0, 0.15), 0 15px 15px -5px rgba(0, 0, 0, 0.08) !important;
}

/* Форсируем hover-поднятие на десктопах, если не идет активная навигация */
@media (pointer: fine) and (min-width: 769px) {
    body:not(.scrolling):not(.resizing):not(.tab-switching):not(.searching):not(.filtering):not(.sorting) .part-card:hover,
    body:not(.scrolling):not(.resizing):not(.tab-switching):not(.searching):not(.filtering):not(.sorting) .set-card:hover,
    body:not(.scrolling):not(.resizing):not(.tab-switching):not(.searching):not(.filtering):not(.sorting) .minifig-card:hover {
        transform: translateY(-6px) scale(1.03) !important;
        box-shadow: 0 25px 30px -5px rgba(0, 0, 0, 0.15), 0 15px 15px -5px rgba(0, 0, 0, 0.08) !important;
    }
}

/* Отключение анимаций при прокрутке для предотвращения моргания */
@media (prefers-reduced-motion: reduce), (max-height: 800px) {
    .part-card.animate-in,
    .set-card.animate-in,
    .minifig-card.animate-in {
        animation: none !important;
        opacity: 1 !important;
        /* Сохраняем hover эффекты даже при отключении анимаций */
    }
    
    .part-card:not(.animate-in),
    .set-card:not(.animate-in),
    .minifig-card:not(.animate-in) {
        animation: none !important;
        opacity: 1 !important;
        /* Сохраняем hover эффекты даже при отключении анимаций */
    }
}

/* Отключение анимаций при быстрой прокрутке */
.scrolling .part-card,
.scrolling .set-card,
.scrolling .minifig-card {
    animation: none !important;
    opacity: 1 !important;
    /* Сохраняем hover эффекты даже при прокрутке */
}

/* Анимация для новых карточек при загрузке - ОТКЛЮЧЕНА */
.part-card:not(.animate-in),
.set-card:not(.animate-in),
.minifig-card:not(.animate-in) {
    opacity: 1 !important;
    /* Сохраняем hover эффекты даже при отключении анимаций */
    animation: none !important;
}

/* Анимация для кнопки "Показать еще" - ОПТИМИЗИРОВАННАЯ */
#load-more-button-catalog,
#load-more-button-collection {
    transition: all 0.2s ease-out;
    transform: translateY(0);
}

/* Анимация для изменения состояния коллекции - МИНИМАЛЬНАЯ */
.part-card[data-collection-change="added"],
.set-card[data-collection-change="added"],
.minifig-card[data-collection-change="added"] {
    animation: collectionAdd 0.2s ease-out forwards !important;
    will-change: box-shadow, transform, opacity;
}

/* Мягкое появление при добавлении через класс */
.part-card.collection-added,
.set-card.collection-added,
.minifig-card.collection-added {
    animation: collectionAdd 0.25s ease-out forwards !important;
    will-change: box-shadow, transform, opacity;
}

.part-card[data-collection-change="removed"],
.set-card[data-collection-change="removed"],
.minifig-card[data-collection-change="removed"] {
    animation: collectionRemove 0.12s ease-in forwards;
}

@keyframes collectionAdd {
    from {
        opacity: 0;
        transform: scale(0.99);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}

@keyframes collectionRemove {
    from {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
    to {
        opacity: 0;
        transform: translateY(2px) scale(0.98);
    }
}

/* Анимация для состояний загрузки и ошибок - ОПТИМИЗИРОВАННАЯ */
.loading-state {
    animation: loadingPulse 1.5s ease-in-out infinite;
}
.error-state {
    animation: errorShake 0.5s ease-in-out;
}

/* Анимация для изменения фильтров - ОТКЛЮЧЕНА */
.filter-change .part-card,
.filter-change .set-card,
.filter-change .minifig-card {
    animation: none !important;
    opacity: 1 !important;
    transform: none !important;
}

@keyframes filterChange {
    from {
        opacity: 0;
        transform: translateY(0.05rem) scale(0.999);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

/* Анимация для изменения сортировки - МИНИМАЛЬНАЯ */
.sort-change .part-card,
.sort-change .set-card,
.sort-change .minifig-card {
    animation: sortChange 0.05s ease-out forwards;
}

/*
@keyframes sortChange {
    from {
        opacity: 0;
        transform: translateX(-0.05rem) scale(0.999);
    }
    to {
        opacity: 1;
        transform: translateX(0) scale(1);
    }
}
*/

/* Анимация для изменения представления - ОТКЛЮЧЕНА */
.view-change .part-card,
.view-change .set-card,
.view-change .minifig-card {
    animation: none !important;
    opacity: 1 !important;
    transform: none !important;
}

/*
@keyframes viewChange {
    from {
        opacity: 0;
        transform: translateY(0.05rem) scale(0.999);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}
*/

/* Анимация для изменения подпредставления - ОТКЛЮЧЕНА */
.subview-change .part-card,
.subview-change .set-card,
.subview-change .minifig-card {
    animation: none !important;
    opacity: 1 !important;
    transform: none !important;
}

/*
@keyframes subviewChange {
    from {
        opacity: 0;
        transform: translateY(0.4rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}
*/

/* Анимация для изменения категории или темы - МИНИМАЛЬНАЯ */
.category-change .part-card,
.theme-change .set-card {
    animation: categoryChange 0.05s ease-out forwards;
}

/*
@keyframes categoryChange {
    from {
        opacity: 0;
        transform: translateY(0.3rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}
*/

/* Анимация для изменения цвета - МИНИМАЛЬНАЯ */
.color-change .part-card {
    animation: colorChange 0.05s ease-out forwards;
}

/*
@keyframes colorChange {
    from {
        opacity: 0;
        transform: scale(0.98);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}
*/

/* Анимация для изменения года или количества деталей - МИНИМАЛЬНАЯ */
.year-change .set-card,
.parts-change .set-card {
    animation: yearPartsChange 0.05s ease-out forwards;
}

/*
@keyframes yearPartsChange {
    from {
        opacity: 0;
        transform: translateY(0.3rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}
*/

/* Анимация для изменения популярности - МИНИМАЛЬНАЯ */
.popularity-change .part-card,
.popularity-change .set-card {
    animation: popularityChange 0.05s ease-out forwards;
}

/*
@keyframes popularityChange {
    from {
        opacity: 0;
        transform: translateY(0.4rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}
*/

/* Анимация для изменения количества элементов - МИНИМАЛЬНАЯ */
.quantity-change .part-card,
.quantity-change .set-card,
.quantity-change .minifig-card {
    animation: quantityChange 0.05s ease-out forwards;
}

/*
@keyframes quantityChange {
    from {
        opacity: 0;
        transform: scale(0.97);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}
*/

/* Анимация для изменения поискового запроса - ОТКЛЮЧЕНА */
.search-change .part-card,
.search-change .set-card,
.search-change .minifig-card {
    animation: none !important;
    opacity: 1 !important;
    transform: none !important;
}

/*
@keyframes searchChange {
    from {
        opacity: 0;
        transform: translateY(0.4rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}
*/

/* Анимация для изменения избранного - МИНИМАЛЬНАЯ */
.favorite-change .part-card,
.favorite-change .set-card,
.favorite-change .minifig-card {
    animation: favoriteChange 0.05s ease-out forwards;
}

/*
@keyframes favoriteChange {
    from {
        opacity: 0;
        transform: scale(0.97);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}
*/

/* Анимация для изменения настроек - ОПТИМИЗИРОВАННАЯ */
.settings-change .part-card,
.settings-change .set-card,
.settings-change .minifig-card {
    animation: settingsChange 0.2s ease-out forwards;
}

@keyframes settingsChange {
    from {
        opacity: 0;
        transform: translateY(0.5rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

/* Анимация для изменения языка - ОПТИМИЗИРОВАННАЯ */
.language-change .part-card,
.language-change .set-card,
.language-change .minifig-card {
    animation: languageChange 0.2s ease-out forwards;
}

/*
@keyframes languageChange {
    from {
        opacity: 0;
        transform: translateY(0.4rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}
*/

/* Анимация для изменения темы (светлая/темная) - ОПТИМИЗИРОВАННАЯ */
.theme-switch .part-card,
.theme-switch .set-card,
.theme-switch .minifig-card {
    animation: themeSwitch 0.3s ease-out forwards;
}

/*
@keyframes themeSwitch {
    from {
        opacity: 0;
        transform: translateY(0.5rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}
*/

/* Анимация для изменения размера шрифта - ОПТИМИЗИРОВАННАЯ */
.font-size-change .part-card,
.font-size-change .set-card,
.font-size-change .minifig-card {
    animation: fontSizeChange 0.2s ease-out forwards;
}

/*
@keyframes fontSizeChange {
    from {
        opacity: 0;
        transform: scale(0.99);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}
*/
/* Анимация для изменения сетки - ОПТИМИЗИРОВАННАЯ */
.grid-change .part-card,
.grid-change .set-card,
.grid-change .minifig-card {
    animation: gridChange 0.2s ease-out forwards;
}

/*
@keyframes gridChange {
    from {
        opacity: 0;
        transform: translateY(0.4rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}
*/

/* Анимация для изменения порядка сортировки - ОПТИМИЗИРОВАННАЯ */
.order-change .part-card,
.order-change .set-card,
.order-change .minifig-card {
    animation: orderChange 0.2s ease-out forwards;
}

/*
@keyframes orderChange {
    from {
        opacity: 0;
        transform: translateX(0.5rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateX(0) scale(1);
    }
}
*/

/* Анимация для изменения пагинации - ОПТИМИЗИРОВАННАЯ */
.pagination-change .part-card,
.pagination-change .set-card,
.pagination-change .minifig-card {
    animation: paginationChange 0.2s ease-out forwards;
}
/*
@keyframes paginationChange {
    from {
        opacity: 0;
        transform: translateY(0.4rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}
*/

/* Анимация для изменения экспорта - ОПТИМИЗИРОВАННАЯ */
.export-change .part-card,
.export-change .set-card,
.export-change .minifig-card {
    animation: exportChange 0.2s ease-out forwards;
}

/*
@keyframes exportChange {
    from {
        opacity: 0;
        transform: scale(0.98);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}
*/

/* Анимация для изменения импорта - ОПТИМИЗИРОВАННАЯ */
.import-change .part-card,
.import-change .set-card,
.import-change .minifig-card {
    animation: importChange 0.2s ease-out forwards;
}

/*
@keyframes importChange {
    from {
        opacity: 0;
        transform: translateY(0.5rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}
*/

/* Анимация для изменения синхронизации - ОПТИМИЗИРОВАННАЯ */
.sync-change .part-card,
.sync-change .set-card,
.sync-change .minifig-card {
    animation: syncChange 0.2s ease-out forwards;
}

@keyframes syncChange {
    from {
        opacity: 0;
        transform: translateY(0.5rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

/* Анимация для изменения резервного копирования - ОПТИМИЗИРОВАННАЯ */
.backup-change .part-card,
.backup-change .set-card,
.backup-change .minifig-card {
    animation: backupChange 0.2s ease-out forwards;
}

@keyframes backupChange {
    from {
        opacity: 0;
        transform: translateY(0.4rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

/* Анимация для изменения восстановления - ОПТИМИЗИРОВАННАЯ */
.restore-change .part-card,
.restore-change .set-card,
.restore-change .minifig-card {
    animation: restoreChange 0.2s ease-out forwards;
}

@keyframes restoreChange {
    from {
        opacity: 0;
        transform: translateY(0.5rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

/* Анимация для изменения очистки - ОПТИМИЗИРОВАННАЯ */
.clear-change .part-card,
.clear-change .set-card,
.clear-change .minifig-card {
    animation: clearChange 0.2s ease-out forwards;
}

@keyframes clearChange {
    from {
        opacity: 0;
        transform: translateY(0.5rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

/* Анимация для изменения сброса - ОПТИМИЗИРОВАННАЯ */
.reset-change .part-card,
.reset-change .set-card,
.reset-change .minifig-card {
    animation: resetChange 0.2s ease-out forwards;
}

@keyframes resetChange {
    from {
        opacity: 0;
        transform: translateY(0.5rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

/* Анимация для изменения обновления - ОПТИМИЗИРОВАННАЯ */
.update-change .part-card,
.update-change .set-card,
.update-change .minifig-card {
    animation: updateChange 0.2s ease-out forwards;
}

@keyframes updateChange {
    from {
        opacity: 0;
        transform: translateY(0.5rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

/* Анимация для изменения перезагрузки - ОПТИМИЗИРОВАННАЯ */
.reload-change .part-card,
.reload-change .set-card,
.reload-change .minifig-card {
    animation: reloadChange 0.2s ease-out forwards;
}

@keyframes reloadChange {
    from {
        opacity: 0;
        transform: translateY(0.5rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

/* Анимация для изменения перезапуска - ОПТИМИЗИРОВАННАЯ */
.restart-change .part-card,
.restart-change .set-card,
.restart-change .minifig-card {
    animation: restartChange 0.2s ease-out forwards;
}

@keyframes restartChange {
    from {
        opacity: 0;
        transform: translateY(0.5rem) scale(0.99);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

/* Анимация для изменения завершения */
.finish-change .part-card,
.finish-change .set-card,
.finish-change .minifig-card {
    animation: finishChange 0.95s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

@keyframes finishChange {
    from {
        opacity: 0;
        transform: translateY(4.2rem) scale(0.68) rotate(-12deg);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1) rotate(0deg);
    }
}

@keyframes loadingPulse {
    0%, 100% {
        opacity: 0.6;
        transform: scale(1);
    }
    50% {
        opacity: 1;
        transform: scale(1.05);
    }
}

@keyframes errorShake {
    0%, 100% {
        transform: translateX(0);
    }
    25% {
        transform: translateX(-5px);
    }
    75% {
        transform: translateX(5px);
    }
}

#load-more-button-catalog:hover,
#load-more-button-collection:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 20px -5px rgba(0, 0, 0, 0.2);
}

/* Hover эффекты для карточек уже определены в базовых стилях выше */
  
    /* Стили для кастомного выпадающего списка вариаций */
    #variation-select-button {
        max-width: 100% !important;
        width: 100% !important;
        box-sizing: border-box;
        text-overflow: ellipsis;
        white-space: nowrap;
        background-color: #374151 !important;
        border: 1px solid #4B5563 !important;
        border-radius: 6px !important;
        color: white !important;
        font-size: 14px !important;
        line-height: 1.5 !important;
        transition: all 0.2s ease !important;
        min-width: 0 !important;
        flex-shrink: 1 !important;
        cursor: pointer !important;
        user-select: none !important;
    }
    
    #variation-select-button:hover {
        border-color: #6B7280 !important;
        background-color: #4B5563 !important;
    }
    
    #variation-select-button:focus {
        outline: none !important;
        border-color: #3B82F6 !important;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5) !important;
    }
    
    #variation-select-button.open {
        border-color: #3B82F6 !important;
        background-color: #4B5563 !important;
    }
    
    #variation-select-button.open svg {
        transform: rotate(180deg) !important;
    }
    
    #variation-dropdown {
        position: absolute !important;
        z-index: 99999 !important;
        background-color: #374151 !important;
        border: 1px solid #4B5563 !important;
        border-radius: 6px !important;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05) !important;
        max-height: 240px !important;
        overflow-y: auto !important;
        transition: all 0.2s ease !important;
        box-sizing: border-box !important;
        min-width: 100% !important;
        max-width: 100% !important;
        top: 100% !important;
        left: 0 !important;
        right: 0 !important;
        margin-top: 4px !important;
    }
    
    .variation-option {
        max-width: 100% !important;
        width: 100% !important;
        overflow: hidden !important;
        text-overflow: ellipsis !important;
        white-space: nowrap !important;
        box-sizing: border-box;
        padding: 8px 12px !important;
        background-color: #374151 !important;
        color: white !important;
        cursor: pointer !important;
        transition: background-color 0.15s ease !important;
        border-bottom: 1px solid #4B5563 !important;
    }
    
    .variation-option:last-child {
        border-bottom: none !important;
    }
    
    .variation-option:hover {
        background-color: #4B5563 !important;
    }
    
    .variation-option.selected {
        background-color: #3B82F6 !important;
    }
    
    .variation-option.selected:hover {
        background-color: #2563EB !important;
    }
    /* Стили для контейнера */
    .variation-select-container {
        position: relative !important;
        width: 100% !important;
        max-width: 100% !important;
        overflow: visible !important;
    }
    
    /* Стили для неактивных кнопок */
    button[disabled] {
        opacity: 0.5 !important;
        cursor: not-allowed !important;
        pointer-events: none !important;
    }
    
    button[disabled]:hover {
        background-color: inherit !important;
        transform: none !important;
    }
    
    /* Убираем стандартную стрелку браузера */
    .variation-select-container::after {
        display: none !important;
    }
    
    /* Для мобильных устройств */
    @media (max-width: 768px) {
        #variation-select-button {
            font-size: 16px; /* Предотвращает зум на iOS */
        }
    }
    
    /* Loading indicator styles */
    #loading-container {
        transition: opacity 0.5s ease-out;
    }
    
    #loading-container.hidden {
        opacity: 0;
        pointer-events: none;
    }
    
    .loading-step {
        opacity: 1;
        /* animation: fadeInUp 0.3s ease-out forwards; */
    }
    
    /* .loading-step:nth-child(1) { animation-delay: 0.1s; } */
    /* .loading-step:nth-child(2) { animation-delay: 0.2s; } */
    /* .loading-step:nth-child(3) { animation-delay: 0.3s; } */
    /* .loading-step:nth-child(4) { animation-delay: 0.4s; } */
    
    /* Анимации для подсказок */
    .tip-container {
        position: relative;
        overflow: hidden;
        min-height: 1.5rem;
    }
    
    .tip-text {
        transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        transform: translateY(0);
        opacity: 1;
    }
    
    .tip-text.fade-out {
        transform: translateY(-20px);
        opacity: 0;
    }
    
    .tip-text.fade-in {
        transform: translateY(20px);
        opacity: 0;
    }
    
    .tip-text.fade-in.show {
        transform: translateY(0);
        opacity: 1;
    }
    
    /* Анимация появления подсказки */
    @keyframes tipSlideIn {
        0% {
            transform: translateY(30px);
            opacity: 0;
        }
        100% {
            transform: translateY(0);
            opacity: 1;
        }
    }
    
    /* Анимация исчезновения подсказки */
    @keyframes tipSlideOut {
        0% {
            transform: translateY(0);
            opacity: 1;
        }
        100% {
            transform: translateY(-30px);
            opacity: 0;
        }
    }
    
    /* Анимация пульсации для привлечения внимания */
    @keyframes tipPulse {
        0%, 100% {
            transform: scale(1);
        }
        50% {
            transform: scale(1.02);
        }
    }
    
    .tip-text.pulse {
        animation: tipPulse 2s ease-in-out infinite;
    }

    /* Стили для системы неактивности */
    .inactivity-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
    }

    .inactivity-overlay.show {
        opacity: 1;
    }

    .inactivity-content {
        background: linear-gradient(135deg, rgba(31, 41, 55, 0.3) 0%, rgba(55, 65, 81, 0.3) 100%);
        border: 2px solid rgba(75, 85, 99, 0.8);
        border-radius: 20px;
        padding: 2rem;
        text-align: center;
        max-width: 500px;
        width: 90%;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        transform: scale(0.9);
        transition: transform 0.5s ease-in-out;
        backdrop-filter: blur(10px);
    }

    .inactivity-overlay.show .inactivity-content {
        transform: scale(1);
    }

    .inactivity-icon {
        font-size: 4rem;
        margin-bottom: 1rem;
        animation: bounce 2s ease-in-out infinite;
    }

    .inactivity-title {
        font-size: 1.5rem;
        font-weight: bold;
        color: #fbbf24;
        margin-bottom: 1rem;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .inactivity-text {
        font-size: 1.1rem;
        color: #e5e7eb;
        line-height: 1.6;
        margin-bottom: 1.5rem;
    }

    .inactivity-close {
        position: absolute;
        top: 1rem;
        right: 1rem;
        width: 32px;
        height: 32px;
        background: #dc2626;
        border-radius: 50%;
        color: white;
        border: none;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
        transition: all 0.2s ease;
    }

    .inactivity-close:hover {
        background: #b91c1c;
        transform: scale(1.1) rotate(2deg);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
    }

    .inactivity-close:active {
        transform: scale(0.95) rotate(0deg);
    }

    .inactivity-close svg {
        width: 16px;
        height: 16px;
        stroke-width: 2.5;
        transition: transform 0.3s ease;
    }

    .inactivity-close:hover svg {
        transform: scale(1.1);
    }

    @keyframes bounce {
        0%, 20%, 50%, 80%, 100% {
            transform: translateY(0);
        }
        40% {
            transform: translateY(-10px);
        }
        60% {
            transform: translateY(-5px);
        }
    }

    /* Размытие основного контента при неактивности */
    body.inactive #main-content,
    body.inactive #sidebar-container,
    body.inactive #header-container {
        filter: blur(3px);
        transition: filter 0.5s ease-in-out;
    }

    /* Оверлей неактивности всегда остается четким */
    .inactivity-overlay {
        filter: blur(0) !important;
    }
  </style>
</head>
<body class="bg-gray-900 text-gray-200">
  <div id="scroll-progress"><div class="bar"></div></div>
  <aside id="sidebar-container" class="w-80 bg-gray-800 p-4 flex flex-col h-full border-r border-gray-700 fixed inset-y-0 left-0 z-40 lg:translate-x-0 -translate-x-full"></aside>
  <div id="sidebar-backdrop" class="fixed inset-0 bg-black bg-opacity-60 z-30 hidden lg:hidden"></div>
  <div class="lg:ml-80 flex flex-col h-screen">
    <header id="header-container" class="bg-gray-800 sticky top-0 z-20 p-4 border-b border-gray-700"></header>
    <main id="main-content" class="flex-1 overflow-y-auto no-scrollbar">
      
      <div id="loading-container" class="flex flex-col items-center justify-center h-full p-8">
        <div class="text-center">
          <div class="loader mx-auto mb-4"></div>
          <h2 class="text-2xl font-bold text-gray-200 mb-2">Загрузка каталога LEGO</h2>
          <p id="loading-status" class="text-gray-400 mb-4">Подготовка к загрузке...</p>
          <div class="w-64 bg-gray-700 rounded-full h-2 mb-4 mx-auto">
            <div id="loading-progress" class="bg-blue-500 h-2 rounded-full" style="width: 0%"></div>
          </div>
          <div id="loading-details" class="text-sm text-gray-500"></div>
          <div class="tip-container max-w-md mx-auto mt-4">
            <div id="loading-tip" class="tip-text text-xs text-blue-400"></div>
          </div>
        </div>
      </div>
    </main>
  </div>
  <div id="modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center modal-hidden"></div>
          <div id="set-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center modal-hidden"></div>
  <div id="minifig-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center modal-hidden"></div>
  <div id="colors-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center modal-hidden"></div>
  <div id="filter-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center modal-hidden"></div>
  <div id="settings-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center modal-hidden"></div>
  <div id="related-sets-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center modal-hidden"></div>
  <input type="file" id="import-csv-input" class="hidden" accept=".csv">
  <div id="image-viewer-container" class="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center viewer-hidden">
    <div class="relative w-full h-full flex items-center justify-center p-[5%]">
      <div class="image-wrapper bg-white rounded-lg shadow-2xl overflow-hidden">
        <img id="fullscreen-image" src="" alt="Полноэкранный просмотр" class="w-full h-full object-contain transition-all duration-300 ease-out">
      </div>
    </div>
    <button id="image-viewer-close" class="modal-close-btn absolute top-4 right-4 z-[101]">
      ${I_X("w-4 h-4")}
    </button>
  </div>
  <button id="scroll-to-top-btn" class="fixed bottom-6 right-6 bg-blue-600 text-white p-3 rounded-full shadow-lg hover:bg-blue-700 opacity-0 pointer-events-none z-40 transform translate-y-4" aria-label="Вернуться наверх" title="Прокрутить страницу в начало">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7"></path></svg>
  </button>

  <!-- Система неактивности с подсказками -->
  <div id="inactivity-overlay" class="inactivity-overlay hidden">
      <div class="inactivity-content">
          <div class="inactivity-icon">💡</div>
          <div class="inactivity-title">Полезная подсказка</div>
          <div class="inactivity-text" id="inactivity-tip"></div>
          <button class="inactivity-close" id="inactivity-close" title="Закрыть подсказку"><svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button>
      </div>
  </div>
  <script type="module">
const DEBUG = false;
if (!DEBUG) {
    console.log = () => {};
    console.debug = () => {};
    console.warn = () => {};
}

// Проверяем, что скрипт выполняется
console.log('🚀 СКРИПТ ЗАГРУЖЕН! DEBUG =', DEBUG);

// Тестовая функция для проверки выполнения
function testFunction() {
    console.log('🧪 ТЕСТОВАЯ ФУНКЦИЯ ВЫЗВАНА!');
    return true;
}

// Вызываем тестовую функцию
testFunction();

// Простая инициализация системы неактивности
let inactivityTimer = null;
let tipRotationTimer = null;

const inactivityTips = [
    "🎲 Удерживайте кнопки 'Детали', 'Наборы' или 'Фигурки' 1 секунду для случайного элемента",
    "💡 После обновления сайта обязательно очистите кэш в настройках сайта для корректной работы",
    "🔍 Используйте поиск по названию для быстрого нахождения нужных деталей",
    "🎨 Фильтруйте детали по цвету для точного подбора к вашей коллекции",
    "📱 Сайт адаптирован для мобильных устройств - удобно использовать на телефоне",
    "❤️ Добавляйте часто используемые категории в избранное для быстрого доступа",
    "🔄 При проблемах с загрузкой попробуйте обновить страницу или очистить кэш",
    "📊 Статистика показывает общее количество элементов в каталоге",
    "💾 Данные сохраняются локально в браузере для быстрой работы",
    "🖼️ Изображения загружаются автоматически при просмотре деталей",
    "🔧 Используйте фильтры по темам для поиска наборов определенной серии",
    "📋 Переключайтесь между каталогом и коллекцией для разных задач",
    "⚡ Сайт работает офлайн после первой загрузки данных",
    "🔄 Регулярно обновляйте данные для получения актуальной информации",
    "🎯 Используйте комбинацию фильтров для точного поиска нужных элементов",
    "📱 На мобильных устройствах используйте свайпы для навигации",
    "🔍 Поиск работает по частичному совпадению - не нужно вводить полное название",
    "❤️ Добавляйте в избранное часто используемые темы для быстрого доступа",
    "📊 В коллекции можно группировать детали по названию для удобства",
    "🖼️ Нажмите на изображение детали для просмотра в полном размере",
    "📋 Экспортируйте свою коллекцию в формате CSV",
    "🎲 Статистика обновляется в реальном времени при изменении коллекции",
    "⚡ Быстрый поиск работает даже при медленном интернете",
    "🔄 Автосохранение состояния происходит после каждого действия",
    "🎯 Клик по карточке открывает детальную информацию",
    "🔍 Фильтры можно комбинировать для создания сложных запросов",
    "🎨 Используйте цветовые фильтры для подбора деталей к набору",
    "📊 Отслеживайте статистику использования различных элементов",
    "🖼️ Предзагрузка изображений ускоряет работу с каталогом",
    "🔧 Настройки интерфейса сохраняются между сессиями",
    "📋 Импортируйте коллекции из других источников",
    "🎲 Удерживайте кнопку Детали/Наборы/Фигурки 1 секунду для случайного элемента",
    "📱 Интерфейс оптимизирован для всех устройств"
];

function simpleInactivityInit() {
    console.log('🎯 ПРОСТАЯ ИНИЦИАЛИЗАЦИЯ СИСТЕМЫ НЕАКТИВНОСТИ');
    
    // Проверяем элементы
    const overlay = document.getElementById('inactivity-overlay');
    const tip = document.getElementById('inactivity-tip');
    const closeBtn = document.getElementById('inactivity-close');
    
    console.log('🎯 Элементы найдены:', {
        overlay: !!overlay,
        tip: !!tip,
        closeBtn: !!closeBtn
    });
    
    if (overlay && tip && closeBtn) {
        console.log('🎯 Все элементы найдены, запускаем простую систему');
        
        // Функция для сброса таймера
        function resetInactivityTimer() {
            console.log('🔄 Сбрасываем таймер неактивности');
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
            }
            
            // Останавливаем смену подсказок при активности
            stopTipRotation();
            
            // Запускаем новый таймер на 90 секунд
            inactivityTimer = setTimeout(() => {
                console.log('🎯 Показываем подсказку!');
                // Выбираем случайную подсказку
                const randomIndex = Math.floor(Math.random() * inactivityTips.length);
                tip.textContent = inactivityTips[randomIndex];
                overlay.classList.remove('hidden');
                overlay.classList.add('show');
                // Запускаем автоматическую смену подсказок
                startTipRotation();
            }, 90000);
            
            console.log('🔄 Таймер неактивности установлен на 90 секунд');
        }
        
        // Функция для автоматической смены подсказок
        function startTipRotation() {
            if (tipRotationTimer) {
                clearInterval(tipRotationTimer);
            }
            
            tipRotationTimer = setInterval(() => {
                if (overlay && overlay.classList.contains('show')) {
                    console.log('🔄 Меняем подсказку');
                    // Выбираем случайную подсказку
                    const randomIndex = Math.floor(Math.random() * inactivityTips.length);
                    tip.textContent = inactivityTips[randomIndex];
                }
            }, 5000);
        }
        
        // Функция для остановки смены подсказок
        function stopTipRotation() {
            if (tipRotationTimer) {
                clearInterval(tipRotationTimer);
                tipRotationTimer = null;
            }
        }
        
        // Обработчик закрытия
        closeBtn.addEventListener('click', () => {
            console.log('🎯 Закрываем подсказку');
            overlay.classList.remove('show');
            overlay.classList.add('hidden');
            stopTipRotation();
            // Перезапускаем таймер после закрытия
            resetInactivityTimer();
        });
        
        // Обработчики активности пользователя
        const activityEvents = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];
        
        activityEvents.forEach(event => {
            document.addEventListener(event, () => {
                console.log(`🎯 Активность пользователя: ${event}`);
                resetInactivityTimer();
            }, { passive: true });
        });
        
        // Запускаем первый таймер
        resetInactivityTimer();
    }
}

// Запускаем простую инициализацию
simpleInactivityInit();
const REBRICKABLE_API_URL = 'https://rebrickable.com/api/v3/lego';
const REBRICKABLE_API_KEYS = ['20c78cc607d6059c8d2a61338d851590', '04a7405ad41f1dd484a562f6e0c57312', 'd93f5c0989f63afa9b1c29ef8ad66002', 'b4179c1b8bd3c022ec9fc0e713e96b77', 'd32527bc33b575b8825a0ba04ba4add5'];
let currentApiKeyIndex = 0;

function getApiKey() {
    const key = REBRICKABLE_API_KEYS[currentApiKeyIndex];
    currentApiKeyIndex = (currentApiKeyIndex + 1) % REBRICKABLE_API_KEYS.length;
    return key;
}
const CACHE_NAME = 'lego-catalog-cache-v14';
const COLOR_COLLAPSE_THRESHOLD = 18;
let COLOR_MAP = {},
    PART_MAP = {},
    SET_MAP = {},
    MINIFIG_MAP = {},
    THEME_MAP = {},
    flatCategories = [];

// Кэш для URL изображений цветов, чтобы избежать повторных вызовов API
const COLOR_IMAGE_CACHE = new Map();
// Fetch de-duplication and waiters for set images
const SET_IMAGE_FETCHING = new Set();
const SET_IMAGE_PENDING = new Map(); // set_num -> Promise<string|undefined>
const SET_IMAGE_WAITERS = new Map(); // set_num -> HTMLElement[]
const SET_IMAGE_FAILED = new Set(); // set_num, где получение изображения по API уже провалилось
let API_IMAGE_FETCH_COUNT = 0;
const API_IMAGE_FETCH_LIMIT = 50; // предохранитель на сессию от избыточных запросов
// Ускоряем загрузку ~в 3 раза: 200мс -> ~66мс
const API_REQUEST_DELAY = 66;
// Ограничения для подгрузки изображений деталей по цветам
const PART_COLOR_FETCHING = new Set(); // key: `${partNum}:${colorId}`
const PART_COLOR_FAILED = new Set();   // key: `${partNum}:${colorId}`
let API_PART_COLOR_FETCH_COUNT = 0;
const API_PART_COLOR_FETCH_LIMIT = 100;
let lastApiRequestTime = 0;
const I_Cat = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>`;
const I_Coll = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polygon points="2 17 12 22 22 17"></polygon><polygon points="2 12 12 17 22 12"></polygon></svg>`;
const I_Set = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>`;
const I_Plus = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>`;
const I_Minus = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>`;
const I_X = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
const I_Menu = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>`;
const I_Up = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>`;
const I_Down = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>`;
const I_Img = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>`;
const I_Trash = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`;
const I_Search = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>`;
const I_Chev = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>`;
const I_Dice = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><path d="M16 8h.01"></path><path d="M12 12h.01"></path><path d="M8 16h.01"></path><path d="M8 8h.01"></path><path d="M16 16h.01"></path></svg>`;
const I_Brick = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="10" rx="2" ry="2"></rect><path d="M7 11V7a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v4"></path><path d="M12 11V7"></path></svg>`;
const I_Plate = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="15" width="18" height="6" rx="1"></rect><circle cx="8" cy="18" r="1"></circle><circle cx="16" cy="18" r="1"></circle></svg>`;
const I_Tech = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20.94c1.5 0 2.85-.93 3.53-2.28a3.99 3.99 0 0 0-7.06 0c.68 1.35 2.03 2.28 3.53 2.28z"></path><path d="M12 3.06c-1.5 0-2.85.93-3.53 2.28a3.99 3.99 0 0 0 7.06 0C14.85 3.99 13.5 3.06 12 3.06z"></path><path d="M3.06 12c0-1.5.93-2.85 2.28-3.53a3.99 3.99 0 0 0 0 7.06C3.99 14.85 3.06 13.5 3.06 12z"></path><path d="M20.94 12c0 1.5-.93 2.85-2.28 3.53a3.99 3.99 0 0 0 0-7.06c1.35.68 2.28 2.03 2.28 3.53z"></path><circle cx="12" cy="12" r="1"></circle></svg>`;
const I_Slope = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 20h18L3 4v16z"></path></svg>`;
const I_Tile = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>`;
const I_Win = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"></rect><path d="M3 12h18"></path><path d="M12 3v18"></path></svg>`;
const I_Wheel = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle></svg>`;
const I_Minifig = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="8" r="3"></circle><path d="M12 11v5"></path><path d="M9 22v-5h6v5"></path><path d="M9 11H5a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h4"></path><path d="M15 11h4a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-4"></path></svg>`;
const I_Bar = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12h16"></path><path d="M4 12a2 2 0 1 0-4 0 2 2 0 0 0 4 0z"></path><path d="M20 12a2 2 0 1 0 4 0 2 2 0 0 0-4 0z"></path></svg>`;
const I_Arch = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 21V11c0-3.87 3.13-7 7-7s7 3.13 7 7v10"></path><path d="M5 21h14"></path></svg>`;

// Функция для правильного склонения слова "цвет"
const getColorWord = (count) => {
    if (count === 1) return "Цвет";
    if (count >= 2 && count <= 4) return "Цвета";
    return "Цветов";
};

// Функция для создания иконки круглой детали LEGO 1x1
const I_Lego1x1 = (c, colorHex) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="10" fill="${colorHex}" stroke="currentColor"/>
    <circle cx="12" cy="12" r="3" fill="rgba(255,255,255,0.3)"/>
    <circle cx="12" cy="12" r="1.5" fill="rgba(255,255,255,0.6)"/>
</svg>`;
const I_Other = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>`;
const I_Filter = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>`;
const I_Theme = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"></path></svg>`;
const I_Folder = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>`;
// Иконки для мультивыбора
const I_Circle = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle></svg>`;
const I_CheckCircle = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M8 12l2.5 2.5L16 9"></path></svg>`;
const I_Share = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><path d="M8.59 13.51l6.83 3.98"></path><path d="M15.41 6.51L8.59 10.49"></path></svg>`;
const I_Settings = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>`;
const I_Heart = (c, f = !1) => f ? `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>` : `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>`;
const I_Refresh = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path></svg>`;

// Класс для управления модальными окнами
class ModalManager {
    constructor() {
        this.openModals = [];
        this.baseZIndex = 200; // Увеличиваем базовый z-index
    }
    
    openModal(modalId, modalElement) {
        console.log(`ModalManager.openModal: Opening ${modalId}`);
        // Убираем класс modal-hidden или viewer-hidden
        modalElement.classList.remove('modal-hidden', 'viewer-hidden');
        
        // Находим максимальный z-index среди всех открытых модальных окон
        let maxZIndex = this.baseZIndex;
        if (this.openModals.length > 0) {
            maxZIndex = Math.max(...this.openModals.map(modal => modal.zIndex));
        }
        
        // Для image viewer устанавливаем z-index еще выше
        let zIndex;
        if (modalId === 'image-viewer-container') {
            zIndex = maxZIndex + 50; // Image viewer всегда поверх всех
        } else {
            zIndex = maxZIndex + 10; // Обычные модальные окна
        }
        
        console.log(`ModalManager.openModal: Setting z-index ${zIndex} for ${modalId} (max was ${maxZIndex})`);
        modalElement.style.zIndex = zIndex.toString();
        
        // Добавляем в список открытых модальных окон
        this.openModals.push({ id: modalId, element: modalElement, zIndex });
        
        // Показываем модальное окно
        requestAnimationFrame(() => {
            modalElement.classList.add('visible');
            
            // Находим контент модального окна для анимации
            const modalContent = modalElement.querySelector('[id$="-content"]') || modalElement.querySelector('.modal-content');
            
            if (modalContent) {
                // Добавляем класс для анимации появления
                modalContent.classList.add('modal-content-enter');
                
                // Убираем класс анимации после завершения
                setTimeout(() => {
                    modalContent.classList.remove('modal-content-enter');
                }, 200);
            } else if (modalId === 'image-viewer-container') {
                // Для image viewer используем обычный CSS transition
                // Анимация контролируется классом .visible
            }
            
            // Анимация появления кнопки закрытия
            const closeBtn = modalElement.querySelector('.modal-close-btn');
            if (closeBtn) {
                closeBtn.style.opacity = '0';
                closeBtn.style.transform = 'scale(0.8) rotate(-10deg)';
                
                setTimeout(() => {
                    closeBtn.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                    closeBtn.style.opacity = '1';
                    closeBtn.style.transform = 'scale(1) rotate(0deg)';
                }, 200);
            }
        });
        
        // Блокируем прокрутку body
        document.body.classList.add('overflow-hidden');
        
        console.log(`ModalManager.openModal: After opening ${modalId}, current z-indexes:`);
        this.debugZIndexes();
    }
    
    closeModal(modalId) {
        const modalIndex = this.openModals.findIndex(modal => modal.id === modalId);
        if (modalIndex === -1) return;
        
        const modal = this.openModals[modalIndex];
        
        // Находим контент модального окна для анимации
        const modalContent = modal.element.querySelector('[id$="-content"]') || modal.element.querySelector('.modal-content');
        
        if (modalContent) {
            // Добавляем класс для анимации закрытия
            modalContent.classList.add('modal-content-leave');
            
            // Ждем завершения анимации закрытия
            setTimeout(() => {
                // Убираем класс анимации (visible убирается позже для плавности)
                
                // Убираем класс анимации
                modalContent.classList.remove('modal-content-leave');
                
                // Добавляем правильный класс скрытия в зависимости от типа модального окна
                if (modalId === 'image-viewer-container') {
                    // Для image viewer сразу скрываем, но backdrop-filter анимируется
                    modal.element.classList.remove('visible');
                    modal.element.style.transition = 'backdrop-filter 0.25s cubic-bezier(0.4, 0, 0.2, 1)';
                    modal.element.style.backdropFilter = 'blur(0px)';
                    
                    // Ждем завершения анимации backdrop-filter
                    setTimeout(() => {
                        modal.element.classList.add('viewer-hidden');
                        modal.element.style.transition = '';
                        modal.element.style.backdropFilter = '';
                    }, 250);
                } else {
                    // Для обычных модальных окон сразу скрываем, но backdrop-filter анимируется
                    modal.element.classList.remove('visible');
                    modal.element.style.transition = 'backdrop-filter 0.25s cubic-bezier(0.4, 0, 0.2, 1)';
                    modal.element.style.backdropFilter = 'blur(0px)';
                    
                    // Ждем завершения анимации backdrop-filter
                    setTimeout(() => {
                        modal.element.classList.add('modal-hidden');
                        modal.element.style.transition = '';
                        modal.element.style.backdropFilter = '';
                    }, 250);
                }
                
                // Убираем из списка открытых модальных окон
                this.openModals.splice(modalIndex, 1);
                
                // Убираем overflow-hidden только если нет других открытых модальных окон
                if (this.openModals.length === 0) {
                    document.body.classList.remove('overflow-hidden');
                }
            }, 200); // Время анимации закрытия
        } else {
            // Если контент не найден, закрываем с анимацией backdrop-filter
            modal.element.classList.remove('visible');
            
            if (modalId === 'image-viewer-container') {
                // Для image viewer сразу скрываем, но backdrop-filter анимируется
                modal.element.classList.remove('visible');
                modal.element.style.transition = 'backdrop-filter 0.25s cubic-bezier(0.4, 0, 0.2, 1)';
                modal.element.style.backdropFilter = 'blur(0px)';
                
                // Ждем завершения анимации backdrop-filter
                setTimeout(() => {
                    modal.element.classList.add('viewer-hidden');
                    modal.element.style.transition = '';
                    modal.element.style.backdropFilter = '';
                }, 250);
            } else {
                // Для обычных модальных окон сразу скрываем, но backdrop-filter анимируется
                modal.element.classList.remove('visible');
                modal.element.style.transition = 'backdrop-filter 0.25s cubic-bezier(0.4, 0, 0.2, 1)';
                modal.element.style.backdropFilter = 'blur(0px)';
                
                // Ждем завершения анимации backdrop-filter
                setTimeout(() => {
                    modal.element.classList.add('modal-hidden');
                    modal.element.style.transition = '';
                    modal.element.style.backdropFilter = '';
                }, 250);
            }
            
            this.openModals.splice(modalIndex, 1);
            
            if (this.openModals.length === 0) {
                document.body.classList.remove('overflow-hidden');
            }
        }
    }
    
    closeLastModal() {
        if (this.openModals.length === 0) return;
        
        const lastModal = this.openModals[this.openModals.length - 1];
        this.closeModal(lastModal.id);
    }
    
    getOpenModalsCount() {
        return this.openModals.length;
    }
    
    getTopModal() {
        if (this.openModals.length === 0) return null;
        return this.openModals[this.openModals.length - 1];
    }
    
    // Закрывает все открытые модальные окна
    closeAllModals() {
        console.log(`ModalManager.closeAllModals: Closing ${this.openModals.length} modals`);
        
        // Создаем копию массива, чтобы избежать проблем при итерации
        const modalsToClose = [...this.openModals];
        
        // Закрываем все модальные окна с небольшой задержкой для плавности
        modalsToClose.forEach((modal, index) => {
            setTimeout(() => {
                this.closeModal(modal.id);
            }, index * 50); // Небольшая задержка между закрытием каждого модального окна
        });
        
        // Убираем overflow-hidden после небольшой задержки
        setTimeout(() => {
            document.body.classList.remove('overflow-hidden');
        }, modalsToClose.length * 50 + 200);
        
        console.log('ModalManager.closeAllModals: All modals closing with animation');
    }
    
    getMaxZIndex() {
        if (this.openModals.length === 0) return this.baseZIndex;
        return Math.max(...this.openModals.map(modal => modal.zIndex));
    }
    
    debugZIndexes() {
        console.log('Current modal z-indexes:');
        this.openModals.forEach(modal => {
            console.log(`  ${modal.id}: ${modal.zIndex}`);
        });
        console.log(`Max z-index: ${this.getMaxZIndex()}`);
    }
    
    // Временно поднимает модальное окно на самый верх
    bringToFront(modalId) {
        console.log(`ModalManager.bringToFront: Bringing ${modalId} to front`);
        const modalIndex = this.openModals.findIndex(modal => modal.id === modalId);
        if (modalIndex === -1) {
            console.log(`ModalManager.bringToFront: Modal ${modalId} not found in openModals`);
            return;
        }
        
        const modal = this.openModals[modalIndex];
        
        // Находим текущий максимальный z-index
        const currentMaxZIndex = this.getMaxZIndex();
        
        // Устанавливаем z-index выше всех остальных
        const newZIndex = currentMaxZIndex + 20;
        modal.zIndex = newZIndex;
        console.log(`ModalManager.bringToFront: Setting z-index ${newZIndex} for ${modalId} (was ${modal.element.style.zIndex})`);
        modal.element.style.zIndex = newZIndex.toString();
        
        // Перемещаем модальное окно в конец массива (последним открытым)
        this.openModals.splice(modalIndex, 1);
        this.openModals.push(modal);
        
        console.log(`ModalManager.bringToFront: After bringing ${modalId} to front:`);
        this.debugZIndexes();
    }
}

// Создаем экземпляр ModalManager
const modalManager = new ModalManager();

let S = {
    view: 'collection',
    subView: 'parts',
    catTree: [],
    expCats: new Set,
    selCatId: null,
    selCollCatId: null,
    catGroups: null,
    favCatIds: new Set,
    themeTree: [],
    expThemes: new Set,
    selThemeId: null,
    selCollThemeId: null,
    setRes: null,
    favThemeIds: new Set,
    minifigRes: null,
    q: '',
    searchGroups: null,
    totalPartsInCatalog: 0, // Общее количество всех деталей в каталоге (не изменяется при смене категории/темы)
    totalSetsInCatalog: 0, // Общее количество всех наборов в каталоге (не изменяется при смене темы)
    collectionSummaryExpanded: false, // Сворачивание/разворачивание сводки коллекции
    searchSetRes: null,
    searchMinifigRes: null,
    loading: !1,
    sidebarLoading: !1,
    err: null,
    selPartId: null,
    selSetNum: null,
    selFigNum: null,
    showRelatedSets: false, // Флаг для показа связанных наборов (только при явном запросе)
    randomMinifigImage: null, // Сохраняем случайное изображение минифигурки
    lastMinifigNumber: null, // Сохраняем номер последней выбранной минифигурки
    longPressTriggered: false, // Флаг для блокировки обычного клика после долгого нажатия
    sidebarOpen: window.innerWidth >= 1024,
    gridStale: !0,
    hasMoreItems: false,
    partModal: {
        groupId: null,
        variants: [],
        selColorId: null,
        qty: 1,
        loadingColors: !1,
        loadingImg: !1,
        imgUrl: null
    },
    setModal: {
        loading: !1,
        inv: [],
        invPage: 1,
        hasNextInv: !1,
        qty: 1,
        bulkUpdate: !1,
        status: '',
        statusType: '',
        view: 'details',
        minifigs: [],
        loadingMinifigs: !1
    },
    minifigModal: {
        loading: !1,
        qty: 1,
        view: 'details',
        inv: null,
        loadingInv: !1,
        invError: !1,
        bulkUpdate: !1,
        status: '',
        statusType: ''
    },
    // Защита от случайной перезагрузки/закрытия вкладки (включена по умолчанию, читаем из кэша)
    preventAccidentalExit: (function(){
        try {
            const v = localStorage.getItem('preventAccidentalExit');
            return v === null ? true : v === 'true';
        } catch { return true; }
    })(),
    // Показывать ли указатель на кнопку sidebar-toggle для первой загрузки на малых устройствах
    showSidebarHint: (function(){
        try {
            const v = localStorage.getItem('showSidebarHint');
            return v === null ? true : v === 'true';
        } catch { return true; }
    })(),
    filterOpen: !1,
    settingsOpen: !1,
    settingsModal: {
        delConfirm: null,
        status: '',
        statusType: 'info'
    },
    toDisplay: 48,
    increment: 48,
    coll: {},
    setColl: {},
    minifigColl: {},
    filters: {
        colorIds: [],
        inCollectionOnly: !1
    },
    
    // ВРЕМЕННО ОТКЛЮЧЕНО: Функция для оптимизации задержек анимаций в зависимости от размера экрана
    getAnimationDelay: function(index) {
        // ВРЕМЕННО ОТКЛЮЧЕНО: Включаем анимации на всех экранах для лучшего пользовательского опыта
        // ВРЕМЕННО ОТКЛЮЧЕНО: Используем более плавные задержки для создания волнового эффекта
        // const delay = Math.min(15 * index, 600);
        // return delay > 0 ? `animation-delay: ${delay}ms;` : '';
        return ''; // Без задержки анимации
    },
    

    setFilters: {
        minYear: '',
        maxYear: '',
        minParts: '',
        maxParts: ''
    },
    sortBy: 'popularity',
    // Мультивыбор (смешанный)
    multiSelect: {
        active: !1,
        items: new Set, // ключи вида: 'sets:1234', 'minifigs:fig-01', 'parts:3001:15' (последнее число — colorId)
        justActivated: !1
    },
    catalogMultiSelectEnabled: (localStorage.getItem('catalogMultiSelectEnabled') === 'true'),
    collectionMultiSelectEnabled: (localStorage.getItem('collectionMultiSelectEnabled') !== 'false'),
    collectionSummaryExpanded: (localStorage.getItem('collectionSummaryExpanded') === 'true'), // По умолчанию скрыта
    foldersEnabled: (localStorage.getItem('foldersEnabled') !== 'false') // По умолчанию включено
};
let tempFilters = {
    filters: { colorIds: [], inCollectionOnly: false },
    setFilters: { minYear: "", maxYear: "", minParts: "", maxParts: "" },
    sortBy: 'popularity'
};

function loadState() {
    // Сбрасываем случайное изображение минифигурки при загрузке состояния
    resetRandomMinifigImage();
    
    const e = localStorage.getItem('legoCollection');
    if (e) try {
        const t = JSON.parse(e);
        "object" == typeof t && null !== t && (S.coll = t)
    } catch (t) {
        console.error("Failed to parse lego collection from localStorage", t), S.coll = {}
    }
    const t = localStorage.getItem('legoSetCollection');
    if (t) try {
        const e = JSON.parse(t);
        "object" == typeof e && null !== e && (S.setColl = e)
    } catch (e) {
        console.error("Failed to parse lego set collection from localStorage", e), S.setColl = {}
    }
    

    // Все данные будут загружены заново из CSV файлов
    console.log('User collections and favorites loaded from localStorage');
    
    const o = localStorage.getItem('legoMinifigCollection');
    if (o) try {
        const e = JSON.parse(o);
        "object" == typeof e && null !== e && (S.minifigColl = e)
    } catch (e) {
        console.error("Failed to parse lego minifig collection from localStorage", e), S.minifigColl = {}
    }
    const l = localStorage.getItem('favoriteCategoryIds');
    if (l) try {
        S.favCatIds = new Set(JSON.parse(l))
    } catch (e) {
        console.error("Failed to parse favorite categories from localStorage", e), S.favCatIds = new Set
    }
    const a = localStorage.getItem('favoriteThemeIds');
    if (a) try {
        S.favThemeIds = new Set(JSON.parse(a))
    } catch (e) {
        console.error("Failed to parse favorite themes from localStorage", e), S.favThemeIds = new Set
    }
    
    // Загружаем настройки
    const foldersEnabled = localStorage.getItem('foldersEnabled');
    if (foldersEnabled !== null) {
        S.foldersEnabled = foldersEnabled === 'true';
    }
}

function saveState() {
    localStorage.setItem('legoCollection', JSON.stringify(S.coll));
    localStorage.setItem('legoSetCollection', JSON.stringify(S.setColl));
    localStorage.setItem('legoMinifigCollection', JSON.stringify(S.minifigColl));
    localStorage.setItem('favoriteCategoryIds', JSON.stringify(Array.from(S.favCatIds)));
    localStorage.setItem('favoriteThemeIds', JSON.stringify(Array.from(S.favThemeIds)));
        
    // Все данные будут загружены заново из CSV файлов при каждом запуске
    console.log('User collections and favorites saved to localStorage');
}
const sidebarEl = document.getElementById('sidebar-container'),
    backdropEl = document.getElementById('sidebar-backdrop'),
    headerEl = document.getElementById('header-container'),
    mainEl = document.getElementById('main-content'),
    partModalEl = document.getElementById('modal-container'),
    setModalEl = document.getElementById('set-modal-container'),
    colorsModalEl = document.getElementById('colors-modal-container'),
    minifigModalEl = document.getElementById('minifig-modal-container'),
    filterModalEl = document.getElementById('filter-modal-container'),
    settingsModalEl = document.getElementById('settings-modal-container'),
    relatedSetsModalEl = document.getElementById('related-sets-modal-container'),
    toTopBtn = document.getElementById('scroll-to-top-btn'),
    viewerEl = document.getElementById('image-viewer-container'),
    viewerImg = document.getElementById('fullscreen-image'),
    viewerCloseBtn = document.getElementById('image-viewer-close');

async function apiFetchPaginated(e) {
    let t = [];
    let o = 1;
    for (;;) {
        const l = e.includes("?") ? "&" : "?",
            a = `${REBRICKABLE_API_URL}${e}${l}page=${o}&page_size=800`;
        
        console.log(`API call: ${a}`);
        
        const i = await fetch(a, {
            headers: {
                Authorization: `key ${getApiKey()}`
            }
        });
        if (!i.ok) {
            const e = await i.json().catch(() => ({
                detail: "Не удалось получить детали ошибки."
            }));
            throw new Error(`Ошибка API Rebrickable: ${i.status} - ${e.detail}`)
        }
        const n = await i.json();
        console.log(`API response page ${o}:`, {
            status: i.status,
            hasResults: !!n.results,
            resultsCount: n.results?.length || 0,
            hasNext: !!n.next,
            sampleResult: n.results?.[0] ? {
                part_num: n.results[0].part_num,
                name: n.results[0].name,
                has_part_img_url: !!n.results[0].part_img_url,
                part_img_url: n.results[0].part_img_url
            } : null
        });
        
        if (n.results?.length > 0) {
            t = t.concat(n.results)
        }
        if (!n.next) break;
        o++
    }
    return t
}

function procPart(e) {
    if (!e || !e.part_num) return console.warn("Пропуск некорректных данных о детали из API:", e), null;
    

    
    const t = {
        id: e.part_num,
        name: e.name,
        rebrickable_img_url: e.part_img_url,
        categoryId: e.part_cat_id,
        num_sets: e.num_sets,
        part_num: e.part_num,
        part_cat_id: e.part_cat_id,
        part_img_url: e.part_img_url
    };
    PART_MAP[t.id] = { ...PART_MAP[t.id],
        ...t
    };
            // Принудительно сохраняем состояние после обработки детали для немедленного сохранения данных детали
        saveState();
    return t
}

function getGroupId(e) {
    if (!e || "string" != typeof e) return e || "unknown_group";
    const t = e.match(/^([0-9]+)/);
    return t ? t[1] : e.split("p")[0]
}

function groupParts(e) {
    const t = {};
    return (e || []).forEach(e => {
        if (!e || (!e.part_num && !e.id)) return void console.warn("Пропуск детали без номера:", e);
        const partNum = e.part_num || e.id;
        const o = getGroupId(partNum);
        t[o] || (t[o] = []), t[o].push(e)
    }), Object.keys(t).forEach(e => {
        t[e].sort(partCmp)
    }), t
}

// Выбирает лучшую вариацию детали для отображения карточки каталога:
// 1) с валидным изображением (part_img_url или rebrickable_img_url)
// 2) если у нескольких есть изображения – оставляем порядок сортировки
// 3) иначе – первый элемент группы
function pickBestPartVariantForCard(variants) {
    try {
        if (!Array.isArray(variants) || variants.length === 0) return null;
        const hasImg = (v) => {
            const url = v?.part_img_url || v?.rebrickable_img_url;
            return typeof url === 'string' && url.startsWith('http');
        };
        const withImg = variants.find(hasImg);
        return withImg || variants[0];
    } catch {
        return Array.isArray(variants) && variants[0] ? variants[0] : null;
    }
}

function buildCategoryTree(e) {
    const t = {
            'Bricks': ["brick"],
            'Plates': ["plate"],
            'Technic': ["technic"],
            'Slopes & Wedges': ["slope", "wedge"],
            'Tiles': ["tile"],
            'Panels, Doors & Windows': ["panel", "door", "window"],
            'Wheels & Tyres': ["wheel", "tyre"],
            'Minifig': ["minifig", "minidoll", "headwear"],
            'Bars, Hinges & Connectors': ["bar", "hinge", "connector", "link", "axle", "pin"],
            'Arches & Curves': ["arch", "curved", "round", "cone", "cylinder"]
        },
        o = {},
        l = [];
    (e || []).forEach(e => {
        const a = e.name.toLowerCase();
        let i = !1;
        for (const n in t)
            if (t[n].some(e => a.includes(e))) {
                o[n] || (o[n] = {
                    name: n,
                    children: []
                }), o[n].children.push(e), i = !0;
                break
            }
        i || l.push(e)
    });
    const a = Object.values(o).sort((e, t) => e.name.localeCompare(t.name, 'en'));
    return l.length > 0 && a.push({
        name: "Other",
        children: l.sort((e, t) => e.name.localeCompare(t.name, 'en'))
    }), a
}
async function fetchCategories() {
    try {
        const e = await apiFetchPaginated("/part_categories/");
        flatCategories = e.sort((e, t) => e.name.localeCompare(t.name, 'en')), S.catTree = buildCategoryTree(flatCategories)
        // Принудительно сохраняем состояние после загрузки категорий для сохранения всех данных категорий
        forceSaveState();
    } catch (e) {
        console.error("Ошибка загрузки категорий:", e), S.err = `Не удалось загрузить категории: ${e.message}`, S.catTree = []
    }
}
async function fetchThemes() {
    try {
        const e = await apiFetchPaginated("/themes/"),
            t = [],
            o = {};
        (e || []).forEach(e => {
            if (e && e.id) {
                o[e.id] = { ...e,
                    children: []
                };
                THEME_MAP[e.id] = o[e.id]
            }
        });
        (e || []).forEach(e => {
            if (e && e.id && o[e.id]) {
                if (e.parent_id && o[e.parent_id]) {
                    (Array.isArray(o[e.parent_id].children) || (o[e.parent_id].children = []));
                    o[e.parent_id].children.push(o[e.id]);
                } else {
                    t.push(o[e.id]);
                }
            }
        });
        const l = (e) => {
            if (Array.isArray(e.children) && e.children.length > 0) {
                e.children.sort((e, t) => e.name.localeCompare(t.name, 'en'));
                e.children.forEach(l);
            }
        };
        t.sort((e, t) => e.name.localeCompare(t.name, 'en')), t.forEach(l), S.themeTree = t
        // Принудительно сохраняем состояние после загрузки тем для сохранения всех данных тем
        forceSaveState();
    } catch (e) {
        console.error("Ошибка загрузки тем:", e), S.err = (S.err ? S.err + "\n" : "") + `Не удалось загрузить темы: ${e.message}`, S.themeTree = []
    }
}
async function fetchAllColors() {
    try {
        const e = await apiFetchPaginated("/colors/");
        const colorsCount = (e || []).length;
        (e || []).forEach(e => {
            const t = String(e.id);
            COLOR_MAP[t] = {
                id: t,
                name: e.name,
                hex: `#${e.rgb}`,
                isTransparent: e.is_trans,
                rgb: e.rgb,
                is_trans: e.is_trans
            }
            // Учитываем цвет один раз на уникальный id
            try { markApiStatOnce('colors', t); } catch {}
        })
        
        // Принудительно сохраняем состояние после загрузки цветов для сохранения всех данных цветов
        forceSaveState();
    } catch (e) {
        console.error("Ошибка загрузки цветов:", e), S.err = (S.err ? S.err + "\n" : "") + "Не удалось загрузить палитру цветов."
    }
}
async function loadPartsForCategory(e) {
    // Отключаем анимации при загрузке категории для улучшения производительности
    document.body.classList.add('category-navigation');
    document.body.classList.add('catalog-view');
    document.body.classList.add('catalog-parts-view');
    setTimeout(() => {
        document.body.classList.remove('category-navigation');
        document.body.classList.remove('catalog-view');
        document.body.classList.remove('catalog-parts-view');
    }, 800);
    
    // Показываем индикатор загрузки для загрузки категории
    updateLoadingStatus("Загрузка деталей категории...", 65, "Загрузка данных из CSV");
    
    if (S.selCatId = e, S.selFigNum = null, S.showRelatedSets = false, S.loading = !0, S.err = null, S.searchGroups = null, S.q = '', S.catGroups = null, S.toDisplay = S.increment, S.gridStale = !0, updateUI(), S.filters.colorIds?.length > 1) return S.catGroups = {}, S.loading = !1, void updateUI();
    
    let o = []; // Объявляем o в начале функции
    let l = []; // Объявляем l в начале функции
    try {
        // Загружаем детали из данных CSV вместо API
        o = Object.values(PART_MAP).filter(part => part.categoryId === e);
        
        // Применяем фильтр цвета, если указан (оптимизировано)
        if (S.filters.colorIds?.length === 1) {
            const colorSet = getPartsWithColorSet(S.filters.colorIds[0]);
            if (colorSet.size > 0) {
                o = o.filter(part => colorSet.has(String(part.id)));
            }
        }
        
        l = o;
        S.filters.inCollectionOnly && (l = o.filter(e => S.coll[e.id] && Object.keys(S.coll[e.id]).length > 0));
        S.catGroups = groupParts(l);
    } catch (t) {
        console.error("CSV parts fetch failed:", t), S.err = t.message
        S.catGroups = {}; // Инициализируем catGroups в случае ошибки
    } finally {
        S.loading = !1;
        
        // Скрываем индикатор загрузки после загрузки категории
        if (S.catGroups && Object.keys(S.catGroups).length !== undefined) {
            updateLoadingStatus("Детали категории загружены", 100, `Загружено ${Object.keys(S.catGroups || {}).length} групп деталей`);
            setTimeout(() => {
                hideLoadingIndicator();
            }, 1000);
        }
        
        updateUI();
    }
}
function getRelevanceScore(e, t) {
    const o = t.toLowerCase(),
        l = e.name ? e.name.toLowerCase() : '',
        a = e.part_num ? e.part_num.toLowerCase() : e.id ? e.id.toLowerCase() : '';
    return a === o ? 100 : l === o ? 90 : a.startsWith(o) ? 80 : l.startsWith(o) ? 70 : a.includes(o) ? 60 : l.includes(o) ? 50 : 0
}

function partCmp(e, t) {
    if (!t || (!t.part_num && !t.id) || !t.name) return -1;
    if (!e || (!e.part_num && !e.id) || !e.name) return 1;
    const o = e.name.toLowerCase().includes("print") || e.name.toLowerCase().includes("sticker") || e.name.toLowerCase().includes("pattern"),
        l = t.name.toLowerCase().includes("print") || t.name.toLowerCase().includes("sticker") || t.name.toLowerCase().includes("pattern");
    if (o && !l) return 1;
    if (!o && l) return -1;
    const a = (e.part_num || e.id).match(/[a-zA-Z]/),
        i = (t.part_num || t.id).match(/[a-zA-Z]/);
    if (a && !i) return 1;
    if (!a && i) return -1;
    const n = (t.num_sets || 0) - (e.num_sets || 0);
    if (0 !== n) return n;
    const r = e.name.length - t.name.length;
    return 0 !== r ? r : (e.part_num || e.id).localeCompare(t.part_num || t.id, 'en')
}
async function searchRebrickableParts(e) {
    // Отключаем анимации при поиске для улучшения производительности
    document.body.classList.add('searching');
    document.body.classList.add('catalog-view');
    document.body.classList.add('catalog-parts-view');
    setTimeout(() => {
        document.body.classList.remove('searching');
        document.body.classList.remove('catalog-view');
        document.body.classList.remove('catalog-parts-view');
    }, 800);
    
    if (!e || e.trim().length === 0) return S.searchGroups = null, S.loading = !1, S.selCatId = null, S.selFigNum = null, S.showRelatedSets = false, S.gridStale = !0, void updateUI();
    if (S.loading = !0, S.err = null, S.selCatId = null, S.selFigNum = null, S.showRelatedSets = false, S.catGroups = null, S.toDisplay = S.increment, S.gridStale = !0, updateUI(), S.filters.colorIds?.length > 1) return S.searchGroups = {}, S.loading = !1, void updateUI();
    
    let o = []; // Объявляем o в начале функции
    let l = {}; // Объявляем l в начале функции
    let a = []; // Объявляем a в начале функции
    let i = {}; // Объявляем i в начале функции
    
    try {
        // Ищем в данных CSV вместо API
        o = searchInCSVData(e, 'parts');
        
        // Применяем фильтр цвета, если указан (оптимизировано)
        if (S.filters.colorIds?.length === 1) {
            const colorSet = getPartsWithColorSet(S.filters.colorIds[0]);
            if (colorSet.size > 0) {
                o = o.filter(part => colorSet.has(String(part.id)));
            }
        }
        
        // Применяем фильтр коллекции, если указан
        S.filters.inCollectionOnly && (o = o.filter(e => S.coll[e.id] && Object.keys(S.coll[e.id]).length > 0));
        
        l = groupParts(o);
        console.log('Grouped parts:', Object.keys(l).length, 'groups');
        
        a = Object.entries(l).map(([t, o]) => ({
            groupId: t,
            partList: o,
            bestScore: Math.max(...o.map(t => getRelevanceScore(t, e)))
        }));
        a.sort((e, t) => {
            if (t.bestScore !== e.bestScore) return t.bestScore - e.bestScore;
            return partCmp(e.partList[0], t.partList[0])
        });
        i = {};
        a.forEach(e => {
            if (e.bestScore > 0) {
                // Для карточки-заместителя используем лучшую вариацию с изображением
                const bestForCard = pickBestPartVariantForCard(e.partList);
                i[e.groupId] = bestForCard ? [bestForCard, ...e.partList] : e.partList;
            }
        }), S.searchGroups = i;
        
        console.log('Final search groups:', Object.keys(i).length, 'groups');

    } catch (t) {
        console.error("CSV search failed:", t), S.err = t.message, S.searchGroups = {}
    } finally {
        S.loading = !1;
        
        // Скрываем индикатор загрузки после завершения поиска
        if (S.q && S.q.trim().length > 0 && S.searchGroups && Object.keys(S.searchGroups).length !== undefined) {
            updateLoadingStatus("Поиск завершен", 100, `Найдено ${Object.keys(S.searchGroups || {}).length} групп деталей`);
            setTimeout(() => {
                hideLoadingIndicator();
            }, 1000);
        }
        
        updateUI();
    }
}
async function fetchSets() {
    // Отключаем анимации при загрузке наборов для улучшения производительности
    document.body.classList.add('catalog-view');
    document.body.classList.add('catalog-sets-view');
    setTimeout(() => {
        document.body.classList.remove('catalog-view');
        document.body.classList.remove('catalog-sets-view');
    }, 800);
    
    // Показываем индикатор загрузки для загрузки наборов
    if (S.selThemeId) {
        updateLoadingStatus("Загрузка наборов темы...", 65, "Загрузка данных из CSV");
    } else if (S.q) {
        updateLoadingStatus("Поиск наборов...", 70, `Поиск по запросу: "${S.q}"`);
    } else {
        updateLoadingStatus("Загрузка всех наборов...", 65, "Загрузка данных из CSV");
    }
    
    let results = []; // Объявляем results в начале функции
    S.loading = !0, S.err = null, S.setRes = null, S.searchSetRes = null, S.toDisplay = S.increment, S.gridStale = !0, updateUI();
    try {
        if (S.q) {
                    // Ищем в данных CSV
        results = searchInCSVData(S.q, 'sets');
        } else if (S.selThemeId) {
            // Фильтруем по теме из данных CSV
            results = Object.values(SET_MAP).filter(set => 
                set.theme_id === S.selThemeId
            );
        } else {
                    // Получаем все наборы из CSV
        results = Object.values(SET_MAP);
        }
        
        // Применяем фильтры - исправлено для корректной работы
        if (S.setFilters.minYear && S.setFilters.minYear.trim() !== '') {
            const minYear = parseInt(S.setFilters.minYear);
            if (!isNaN(minYear)) {
                results = results.filter(set => set.year && set.year >= minYear);
            }
        }
        if (S.setFilters.maxYear && S.setFilters.maxYear.trim() !== '') {
            const maxYear = parseInt(S.setFilters.maxYear);
            if (!isNaN(maxYear)) {
                results = results.filter(set => set.year && set.year <= maxYear);
            }
        }
        if (S.setFilters.minParts && S.setFilters.minParts.trim() !== '') {
            const minParts = parseInt(S.setFilters.minParts);
            if (!isNaN(minParts)) {
                results = results.filter(set => set.num_parts && set.num_parts >= minParts);
            }
        }
        if (S.setFilters.maxParts && S.setFilters.maxParts.trim() !== '') {
            const maxParts = parseInt(S.setFilters.maxParts);
            if (!isNaN(maxParts)) {
                results = results.filter(set => set.num_parts && set.num_parts <= maxParts);
            }
        }
        
        // Применяем сортировку
        if (S.sortBy === "alpha_asc") {
            results.sort((a, b) => (a.name || '').localeCompare(b.name || '', 'en'));
        } else if (S.sortBy === "alpha_desc") {
            results.sort((a, b) => (b.name || '').localeCompare(a.name || '', 'en'));
        } else if (S.sortBy === "year_asc") {
            results.sort((a, b) => (a.year || 0) - (b.year || 0));
        } else if (S.sortBy === "year_desc") {
            results.sort((a, b) => (b.year || 0) - (a.year || 0));
        } else if (S.sortBy === "parts_asc") {
            results.sort((a, b) => (a.num_parts || 0) - (b.num_parts || 0));
        } else if (S.sortBy === "parts_desc") {
            results.sort((a, b) => (b.num_parts || 0) - (a.num_parts || 0));
        }
        
        if (S.q) {
            S.searchSetRes = results;
        } else {
            S.setRes = results;
        }
        
        console.log('Sets loaded:', results.length, 'results');
        console.log('Applied filters:', S.setFilters);
        console.log('Sort by:', S.sortBy);

    } catch (e) {
        console.error("Ошибка загрузки наборов из CSV:", e), S.err = e.message
        results = []; // Инициализируем results в случае ошибки
    } finally {
        S.loading = !1;
        
        // Скрываем индикатор загрузки после загрузки наборов
        if (S.subView === 'sets' && results && results.length !== undefined) {
            updateLoadingStatus("Наборы загружены", 100, `Загружено ${results.length} наборов`);
            setTimeout(() => {
                hideLoadingIndicator();
            }, 1000);
        }
        
        updateUI();
    }
}
async function fetchMinifigs() {
    // Отключаем анимации при загрузке минифигурок для улучшения производительности
    document.body.classList.add('catalog-view');
    document.body.classList.add('catalog-minifigs-view');
    setTimeout(() => {
        document.body.classList.remove('catalog-view');
        document.body.classList.remove('catalog-minifigs-view');
    }, 800);
    
            // Показываем индикатор загрузки для загрузки минифигурок
        if (S.q) {
            updateLoadingStatus("Поиск минифигурок...", 70, `Поиск по запросу: "${S.q}"`);
        } else {
            updateLoadingStatus("Загрузка всех минифигурок...", 65, "Загрузка данных из CSV");
        }
    
    let results = []; // Объявляем results в начале функции
    S.loading = !0, S.err = null, S.toDisplay = S.increment, S.gridStale = !0, updateUI();
    try {
        if (S.q) {
                    // Ищем в данных CSV
        results = searchInCSVData(S.q, 'minifigs');
            S.searchMinifigRes = results;
            S.minifigRes = null;
        } else {
                    // Получаем все минифигурки из CSV
        results = Object.values(MINIFIG_MAP);
            S.minifigRes = results;
            S.searchMinifigRes = null;
        }
        
        // Применяем сортировку - исправлено для корректной работы
        if (S.sortBy === "name_asc") {
            results.sort((a, b) => (a.name || '').localeCompare(b.name || '', 'en'));
        } else if (S.sortBy === "name_desc") {
            results.sort((a, b) => (b.name || '').localeCompare(a.name || '', 'en'));
        } else if (S.sortBy === "num_parts_desc") {
            results.sort((a, b) => (b.num_parts || 0) - (a.num_parts || 0));
        } else if (S.sortBy === "num_parts_asc") {
            results.sort((a, b) => (a.num_parts || 0) - (b.num_parts || 0));
        }
        
        console.log('Minifigs loaded:', results.length, 'results');
        console.log('Sort by:', S.sortBy);
        

    } catch (e) {
        console.error("Ошибка загрузки минифигурок из CSV:", e), S.err = e.message
        results = []; // Инициализируем results в случае ошибки
    } finally {
        S.loading = !1;
        
        // Скрываем индикатор загрузки после загрузки минифигурок
        if (S.subView === 'minifigs' && results && results.length !== undefined) {
            updateLoadingStatus("Минифигурки загружены", 100, `Загружено ${results.length} минифигурок`);
            setTimeout(() => {
                hideLoadingIndicator();
            }, 1000);
        }
        
        updateUI();
    }
}
async function fetchPartColors(e) {
    // Показываем индикатор загрузки для загрузки цветов
    updateLoadingStatus("Загрузка цветов детали...", 75, "Загрузка доступных цветов");
    
    S.partModal.loadingColors = !0;
    updateModalPartially({
        colors: !0
    });
    
    let t = []; // Объявляем t в начале функции
    try {
        t = (await apiFetchPaginated(`/parts/${e}/colors/`)).map(e => String(e.color_id));
        
        if (PART_MAP[e]) {
            PART_MAP[e].availableColorIds = t;
            
            if (t.length > 0 && (!S.partModal.selColorId || !t.includes(S.partModal.selColorId))) {
                S.partModal.selColorId = sortColorIds(t, e)[0];
            }
        }
    } catch (error) {
        console.error(`Failed to fetch colors for ${e}:`, error);
        if (!PART_MAP[e]) {
            PART_MAP[e] = {};
        }
        PART_MAP[e].availableColorIds = PART_MAP[e].availableColorIds || [];
    } finally {
        S.partModal.loadingColors = !1;
        
        // Обновляем статус загрузки для цветов
        if (PART_MAP[e] && PART_MAP[e].availableColorIds && PART_MAP[e].availableColorIds.length !== undefined) {
            updateLoadingStatus("Цвета загружены", 80, `Доступно ${PART_MAP[e].availableColorIds.length} ${getColorWord(PART_MAP[e].availableColorIds.length)}`);
        }
        
        updateModalPartially({
            colors: !0,
            controls: !0
        });
        
        if (S.partModal.selColorId) {
            fetchPartColorSpecifics(e, S.partModal.selColorId);
        }
    }
}
async function fetchPartColorSpecifics(e, t) {
    S.partModal.loadingImg = !0, updateModalPartially({
        image: !0
    });
    
    // Сначала проверяем кэш
    const cacheKey = `${e}-${t}`;
    if (COLOR_IMAGE_CACHE.has(cacheKey)) {
        S.partModal.imgUrl = COLOR_IMAGE_CACHE.get(cacheKey);
        S.partModal.loadingImg = !1;
        updateModalPartially({ image: !0 });
        return;
    }
    
    let now, timeSinceLastRequest, o, l, a; // Объявляем переменные в начале функции
    try {
        // Ограничение частоты запросов
        now = Date.now();
        timeSinceLastRequest = now - lastApiRequestTime;
        if (timeSinceLastRequest < API_REQUEST_DELAY) {
            await new Promise(resolve => setTimeout(resolve, API_REQUEST_DELAY - timeSinceLastRequest));
        }
        
        lastApiRequestTime = Date.now();
        o = `${REBRICKABLE_API_URL}/parts/${e}/colors/${t}/`;
        l = await fetch(o, {
            headers: {
                Authorization: `key ${getApiKey()}`
            }
        });
            
        if (l.status === 429) {
            // Превышен лимит запросов - ждем и показываем запасное изображение
            console.warn('Rate limited by API, using fallback image');
            S.partModal.imgUrl = PART_MAP[e]?.rebrickable_img_url || null;
            return;
        }
        
        if (!l.ok) throw new Error("Image not found for this color.");
        a = await l.json();
        
        if (a.part_img_url) {
            // Кэшируем результат
            COLOR_IMAGE_CACHE.set(cacheKey, a.part_img_url);
            S.partModal.imgUrl = a.part_img_url;
        } else {
            S.partModal.imgUrl = PART_MAP[e]?.rebrickable_img_url || null;
        }
    } catch (error) {
        console.warn("Could not fetch color-specific image:", error);
        S.partModal.imgUrl = PART_MAP[e]?.rebrickable_img_url || null;
    } finally {
        S.partModal.loadingImg = !1;
        
        // Показываем индикатор загрузки для загрузки изображения
        if (S.partModal.imgUrl !== undefined) {
            if (S.partModal.imgUrl) {
                updateLoadingStatus("Изображение загружено", 85, "Изображение детали готово");
            } else {
                updateLoadingStatus("Изображение недоступно", 85, "Используется стандартное изображение");
            }
        }
        
        updateModalPartially({
            image: !0
        });
    }
}
async function fetchColorDetailsForPart(e) {
    if (PART_MAP[e]?.colorImages) return;
    
    let now, timeSinceLastRequest, t, o, imageCount; // Объявляем переменные в начале функции
    
            // Ограничение частоты запросов
        now = Date.now();
        timeSinceLastRequest = now - lastApiRequestTime;
        if (timeSinceLastRequest < API_REQUEST_DELAY) {
            await new Promise(resolve => setTimeout(resolve, API_REQUEST_DELAY - timeSinceLastRequest));
        }
    
    try {
        lastApiRequestTime = Date.now();
        t = await apiFetchPaginated(`/parts/${e}/colors/`);
        if (!PART_MAP[e]) {
            PART_MAP[e] = {
                id: e
            };
        }
        o = {};
        if (Array.isArray(t)) {
            t.forEach(colorData => {
                if (colorData && colorData.part_img_url && colorData.color_id) {
                    o[String(colorData.color_id)] = colorData.part_img_url;
                    // Кэшируем отдельные URL изображений цветов
                    const cacheKey = `${e}-${colorData.color_id}`;
                    COLOR_IMAGE_CACHE.set(cacheKey, colorData.part_img_url);
                    // Счетчик изображений увеличиваем только при загрузке карточек, не в модалке
                }
            });
        }
        PART_MAP[e].colorImages = o;
        
        // Принудительно сохраняем состояние после загрузки деталей цвета для немедленного сохранения данных цвета
        forceSaveState();
    } catch (error) {
        console.warn(`Could not fetch color details for part ${e}:`, error);
        // Отмечаем эту деталь как неудачную, чтобы избежать повторных попыток
        if (!PART_MAP[e]) {
            PART_MAP[e] = { id: e };
        }
        PART_MAP[e].colorImages = {}; // Пустой объект для предотвращения повторных попыток
        
        // Принудительно сохраняем состояние после ошибки для сохранения неудачного состояния
        forceSaveState();
    }
}

// Функция для обеспечения загрузки базовых изображений деталей для элементов коллекции
async function ensureBasicPartImagesForCollection() {
    const partsNeedingImages = Object.keys(S.coll).filter(partId => {
        const part = PART_MAP[partId];
        // Обрабатываем только детали, у которых вообще нет URL изображения
        // Это должно быть очень редко, поскольку inventory_parts.csv должен предоставлять изображения
        return part && !part.part_img_url;
    });
    
    if (partsNeedingImages.length === 0) {
        return;
    }
    
    // Обрабатываем все детали немедленно без вызовов API
    partsNeedingImages.forEach(partId => {
        const part = PART_MAP[partId];
        if (part && !part.part_img_url) {
            // Генерируем запасной URL изображения только если изображения не существует
            part.part_img_url = `https://cdn.rebrickable.com/media/parts/${partId}.jpg`;
            part.rebrickable_img_url = part.part_img_url;

        }
    });
    
    // Сохраняем состояние для сохранения URL изображений
    saveState();
}

// Упрощенная функция для загрузки изображений конкретных цветов
async function fetchColorDetailsForCollectionParts() {
    // Пропускаем эту функцию, если пользователь предпочитает быструю загрузку вместо изображений конкретных цветов
    if (localStorage.getItem('disableColorSpecificImages') === 'true') {
        return;
    }
    
    const partsNeedingColorImages = Object.keys(S.coll).filter(partId => {
        const part = PART_MAP[partId];
        return part && !part.colorImages && part.part_img_url && part.part_img_url.startsWith('http');
    });
    
    if (partsNeedingColorImages.length === 0) return;
    

    
    try {
        // Обрабатываем все детали небольшими партиями, чтобы избежать ограничения частоты запросов
        for (let i = 0; i < partsNeedingColorImages.length; i += 3) {
            const batch = partsNeedingColorImages.slice(i, i + 3);
            await Promise.all(batch.map(partId => fetchColorDetailsForPart(partId)));
            
            // Добавляем задержку между партиями, чтобы избежать ограничения частоты запросов
            if (i + 3 < partsNeedingColorImages.length) {
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }
        
        // Принудительно сохраняем состояние после загрузки всех деталей цвета
        forceSaveState();
    } catch (error) {
        console.error('Error fetching color details for collection parts:', error);
        // Принудительно сохраняем состояние даже после ошибки для сохранения любых успешных загрузок
        forceSaveState();
    }
}
// Функция для принудительного обновления изображений деталей в представлении коллекции
async function forceRefreshPartImages() {
    if (S.view !== 'collection' || S.subView !== 'parts') return;
    
    const refreshButton = document.getElementById('refresh-images-button');
    const refreshIcon = document.getElementById('refresh-images-icon');
    
    if (!refreshButton || !refreshIcon) return;
    
    // Отключаем кнопку и показываем состояние загрузки
    refreshButton.disabled = true;
    refreshIcon.innerHTML = '<div class="loader !w-5 !h-5 !border-2"></div>';
    
    try {
        // Сначала обеспечиваем наличие базовых изображений для всех деталей
        await ensureBasicPartImagesForCollection();
        
        // Затем загружаем изображения конкретных цветов для всех деталей
        await fetchColorDetailsForCollectionParts();
        
        // Обновляем UI один раз в конце
        S.gridStale = true;
        updateUI();
    } catch (error) {
        console.error('Error refreshing part images:', error);
        // Обновляем UI даже после ошибки, чтобы показать любые успешные обновления
        S.gridStale = true;
        updateUI();
    } finally {
        // Включаем кнопку обратно и восстанавливаем иконку
        refreshButton.disabled = false;
        refreshIcon.innerHTML = I_Refresh("w-5 h-5");
    }
}

async function fetchMissingCollectionPartDetails() {
    // Отключаем анимации при загрузке деталей коллекции для улучшения производительности
    document.body.classList.add('collection-view');
    document.body.classList.add('collection-parts-view');
    setTimeout(() => {
        document.body.classList.remove('collection-view');
        document.body.classList.remove('collection-parts-view');
    }, 800);
    
    const e = Object.keys(S.coll).filter(e => !PART_MAP[e] || !PART_MAP[e].name);
    if (e.length === 0) return;
    
    try {
        for (let t = 0; t < e.length; t += 100) {
            const o = e.slice(t, t + 100);
            try {
                const parts = await apiFetchPaginated(`/parts/?part_nums=${o.join(",")}`);
                
                if (parts && Array.isArray(parts)) {
                    const processedParts = parts.map(procPart).filter(Boolean);
                    // Обновляем статистику загрузки API: по одному разу на элемент
                    processedParts.forEach(p => { try { markApiStatOnce('parts', p.id || p.part_num); } catch {} });
                }
            } catch (l) {
                console.error(`Could not fetch details for batch starting with part ${o[0]}:`, l);
                S.err = (S.err ? S.err + "\n" : "") + "Не удалось загрузить данные для некоторых деталей коллекции.";
            }
        }
        // Принудительно сохраняем состояние после загрузки деталей для сохранения всех данных деталей
        forceSaveState();
    } catch (error) {
        console.error('Error in fetchMissingCollectionPartDetails:', error);
        // Принудительно сохраняем состояние даже после ошибки для сохранения любых успешных загрузок
        forceSaveState();
    }
}
async function fetchMissingCollectionSetDetails() {
    // Отключаем анимации при загрузке наборов коллекции для улучшения производительности
    document.body.classList.add('collection-view');
    document.body.classList.add('collection-sets-view');
    setTimeout(() => {
        document.body.classList.remove('collection-view');
        document.body.classList.remove('collection-sets-view');
    }, 800);
    
    const e = Object.keys(S.setColl).filter(e => !SET_MAP[e] || !SET_MAP[e].name);
    if (e.length === 0) return;
    try {
        for (let t = 0; t < e.length; t += 50) {
            const o = e.slice(t, t + 50);
            try {
                const sets = await apiFetchPaginated(`/sets/?set_nums=${o.join(",")}`);
                if (sets && Array.isArray(sets)) {
                    const validSets = sets.filter(set => set && set.set_num);
                    validSets.forEach(set => {
                        if (set && set.set_num) {
                            SET_MAP[set.set_num] = { ...SET_MAP[set.set_num], ...set };
                        }
                    });
                    // Обновляем статистику загрузки API: по одному разу на элемент
                    validSets.forEach(set => { try { markApiStatOnce('sets', set.set_num); } catch {} });
                }
                // Сохраняем обновленный кэш деталей наборов для офлайн рендеринга
                saveState();
            } catch (l) {
                console.error(`Could not fetch details for batch of sets starting with ${o[0]}:`, l);
                S.err = (S.err ? S.err + "\n" : "") + "Не удалось загрузить данные для некоторых наборов коллекции.";
            }
        }
    } catch (error) {
        console.error('Error in fetchMissingCollectionSetDetails:', error);
        // Принудительно сохраняем состояние даже после ошибки для сохранения любых успешных загрузок
        saveState();
    }
}
async function fetchMinifigDetails(e) {
    if (MINIFIG_MAP[e]?.name) return;
    try {
        const t = await fetch(`${REBRICKABLE_API_URL}/minifigs/${e}/`, {
            headers: {
                Authorization: `key ${getApiKey()}`
            }
        });
        if (!t.ok) throw new Error(`Minifig ${e} not found.`);
        const o = await t.json();
        MINIFIG_MAP[e] = o
        
        // Обновляем статистику загрузки API: один раз на минифиг с данным id
        markApiStatOnce('minifigs', e);
        
        // Принудительно сохраняем состояние после загрузки деталей минифигурки для немедленного сохранения данных минифигурки
        saveState();
        
        // Обновляем UI, если эта минифигурка в данный момент отображается
        if (S.gridStale) {
            updateUI();
        }
        
        // Также обновляем UI, если мы в данный момент просматриваем минифигурки
        if (S.subView === 'minifigs') {
            S.gridStale = true;
            updateUI();
        }
    } catch (t) {
        console.error(`Could not fetch details for minifig ${e}:`, t)
        // Устанавливаем имя-заполнитель, чтобы избежать #undefined
        if (!MINIFIG_MAP[e]) {
            MINIFIG_MAP[e] = { set_num: e, name: 'Неизвестная минифигурка' };
        }
    }
}

async function fetchSetInventory(e, t = 1) {
            // Показываем индикатор загрузки для инвентаря набора
        updateLoadingStatus("Загрузка инвентаря набора...", 75, "Загрузка списка деталей");
    
    if (S.setModal.loading = !0, t === 1 && (S.setModal.inv = []), updateSetModalView(), !S.selSetNum) return;
    try {
        const o = `/sets/${e}/parts/?page=${t}&page_size=50`,
            l = await fetch(`${REBRICKABLE_API_URL}${o}`, {
                headers: {
                    Authorization: `key ${getApiKey()}`
                }
            });
        if (!l.ok) throw new Error("Could not fetch set inventory");
        const a = await l.json();
        const i = (a.results || []).map((e) => {
                procPart(e.part);
                const t = String(e.color.id);
                COLOR_MAP[t] || (COLOR_MAP[t] = {
                    id: t,
                    name: e.color.name,
                    hex: `#${e.color.rgb}`,
                    isTransparent: e.color.is_trans,
                    rgb: e.color.rgb,
                    is_trans: e.color.is_trans
                });
                return {
                    part: e.part,
                    color: COLOR_MAP[t],
                    quantity: e.quantity,
                    is_spare: e.is_spare,
                    element_id: e.element_id
                }
            }).filter((e) => !e.is_spare);
        S.setModal.inv = [...S.setModal.inv, ...i], S.setModal.invPage = t, S.setModal.hasNextInv = !!a.next
        // Принудительно сохраняем состояние после загрузки инвентаря набора для немедленного сохранения данных инвентаря
        forceSaveState();
    } catch (o) {
        console.error(`Failed to fetch inventory for ${e}:`, o)
    } finally {
        S.setModal.loading = !1;
        
        // Обновляем статус загрузки для инвентаря набора
        updateLoadingStatus("Инвентарь набора загружен", 80, `Загружено ${S.setModal.inv.length} деталей`);
        
        S.selSetNum && updateSetModalView();
    }
}
async function fetchAllSetInventory(e) {
    let t = [];
    let o = 1;
    for (;;) {
        const l = `/sets/${e}/parts/?page=${o}&page_size=500`,
            a = await fetch(`${REBRICKABLE_API_URL}${l}`, {
                headers: {
                    Authorization: `key ${getApiKey()}`
                }
            });
        if (!a.ok) {
            const e = await a.json().catch(() => ({
                detail: "Не удалось получить детали ошибки."
            }));
            throw new Error(`Ошибка API Rebrickable: ${a.status} - ${e.detail}`)
        }
        const i = await a.json();
        const n = (i.results || []).map((e) => {
                procPart(e.part);
                const t = String(e.color.id);
                return COLOR_MAP[t] || (COLOR_MAP[t] = {
                    id: t,
                    name: e.color.name,
                    hex: `#${e.color.rgb}`,
                    isTransparent: e.color.is_trans,
                    rgb: e.color.rgb,
                    is_trans: e.color.is_trans
                }), {
                    part: e.part,
                    color: COLOR_MAP[t],
                    quantity: e.quantity,
                    is_spare: e.is_spare,
                    element_id: e.element_id,
                }
            }).filter((e) => !e.is_spare);
        if (n.length > 0) {
            t = t.concat(n);
        }
        if (!i.next) break;
        o++, await new Promise(e => setTimeout(e, 1e3))
    }
            // Принудительно сохраняем состояние после загрузки всего инвентаря набора для немедленного сохранения данных инвентаря
        forceSaveState();
    return t
}
async function loadAllSetInventoryIntoModal(e) {
    // Показываем индикатор загрузки и очищаем текущий инвентарь
    updateLoadingStatus("Загрузка инвентаря набора...", 75, "Загрузка списка деталей");
    S.setModal.loading = !0;
    S.setModal.inv = [];
    S.setModal.invPage = 1;
    S.setModal.hasNextInv = !1;
    updateSetModalView();
    try {
        const allItems = await fetchAllSetInventory(e);
        S.setModal.inv = allItems || [];
        S.setModal.invPage = 1;
        S.setModal.hasNextInv = !1;
        // Принудительно сохраняем состояние после полной загрузки инвентаря
        forceSaveState();
    } catch (error) {
        console.error(`Failed to fully load inventory for ${e}:`, error);
    } finally {
        S.setModal.loading = !1;
        updateLoadingStatus("Инвентарь набора загружен", 80, `Загружено ${S.setModal.inv.length} деталей`);
        S.selSetNum && updateSetModalView();
    }
}
async function fetchSetMinifigs(e) {
    // Показываем индикатор загрузки для минифигурок набора
    updateLoadingStatus("Загрузка минифигурок набора...", 75, "Загрузка списка минифигурок");
    
    S.setModal.loadingMinifigs = !0, updateSetModalView();
    try {
        const t = await apiFetchPaginated(`/sets/${e}/minifigs/`);
        for (let e = 0; e < t.length; e += 5) {
            const o = t.slice(e, e + 5),
                l = o.map(e => fetchMinifigDetails(e.set_num));
            await Promise.all(l), e + 5 < t.length && await new Promise(e => setTimeout(e, 1e3))
        }
        S.setModal.minifigs = (t || []).map(e => ({ ...MINIFIG_MAP[e.set_num],
            quantity: e.quantity,
            isExpanded: !1,
            isLoadingParts: !1,
            parts: null,
            loadingError: !1
        }))
        // Принудительно сохраняем состояние после загрузки минифигурок набора для немедленного сохранения данных минифигурок
        forceSaveState();
    } catch (t) {
        console.error(`Failed to fetch minifigs for set ${e}:`, t), S.setModal.minifigs = []
    } finally {
        S.setModal.loadingMinifigs = !1, S.selSetNum && updateSetModalView()
    }
}
async function fetchMinifigParts(e) {
    // Показываем индикатор загрузки для деталей минифигурки
    updateLoadingStatus("Загрузка деталей минифигурки...", 75, "Загрузка списка деталей");
    
    try {
        const t = await apiFetchPaginated(`/minifigs/${e}/parts/`);
        const result = (t || []).map(e => {
            procPart(e.part);
            const t = String(e.color.id);
            return COLOR_MAP[t] || (COLOR_MAP[t] = {
                id: t,
                name: e.color.name,
                hex: `#${e.color.rgb}`,
                isTransparent: e.color.is_trans,
                rgb: e.color.rgb,
                is_trans: e.color.is_trans
            }), { ...e,
                color: COLOR_MAP[t]
            }
        });
        
        // Принудительно сохраняем состояние после загрузки деталей минифигурки для немедленного сохранения данных деталей
        forceSaveState();
        
        // Загружаем отсутствующие изображения деталей для деталей минифигурки
        await fetchMissingMinifigPartImages(result);
        
        // Обновляем статус загрузки для деталей минифигурки
        updateLoadingStatus("Детали минифигурки загружены", 80, `Загружено ${result.length} деталей`);
        
        return result;
    } catch (t) {
        throw console.error(`Failed to fetch parts for minifig ${e}:`, t), t
    }
}

// Функция для загрузки отсутствующих изображений деталей для деталей минифигурки
async function fetchMissingMinifigPartImages(minifigParts) {
    const partsWithoutImages = minifigParts.filter(p => !p.part.part_img_url);
    
    if (partsWithoutImages.length === 0) {
        return;
    }
    

    
    for (const partInfo of partsWithoutImages.slice(0, 5)) { // Ограничиваем до 5, чтобы избежать ограничения частоты запросов
        if (!partInfo || !partInfo.part || !partInfo.part.part_num) {
            console.warn('Invalid part info, skipping...');
            continue;
        }
        
        try {
            // Ограничение частоты запросов
            const now = Date.now();
            const timeSinceLastRequest = now - lastApiRequestTime;
            if (timeSinceLastRequest < API_REQUEST_DELAY) {
                await new Promise(resolve => setTimeout(resolve, API_REQUEST_DELAY - timeSinceLastRequest));
            }
            
            lastApiRequestTime = Date.now();
            
            const response = await fetch(`${REBRICKABLE_API_URL}/parts/${partInfo.part.part_num}/?key=${getApiKey()}`);
            
            if (response.status === 429) {
                console.warn('Превышен лимит запросов API, останавливаем загрузку изображений деталей');
                break;
            }
            
            if (response.ok) {
                const data = await response.json();
                if (data.results && data.results[0] && data.results[0].part_img_url) {
                    partInfo.part.part_img_url = data.results[0].part_img_url;
                    try {
                        markApiStatOnce('images', `part:${partInfo.part.part_num}`);
                        markApiStatOnce('parts', partInfo.part.part_num);
                    } catch {}

                }
            }
            
            // Добавляем задержку, чтобы избежать ограничения частоты запросов
            await new Promise(resolve => setTimeout(resolve, 100));
        } catch (error) {
            console.warn(`Failed to fetch image URL for part ${partInfo.part.part_num}:`, error);
        }
    }
}

// Функция для обработки долгого нажатия на кнопки бокового меню
function handleLongPress(type) {
    console.log(`🎲 Long press detected for: ${type}`);
    
    // Защита от повторного вызова
    if (window.handleLongPressInProgress) {
        console.log('🚫 handleLongPress already in progress, skipping...');
        return;
    }
    window.handleLongPressInProgress = true;
    
    // НЕМЕДЛЕННО блокируем updateUI для предотвращения перерисовки
    const originalUpdateUI = window.updateUI;
    const originalRenderMainContent = window.renderMainContent;
    
    // Создаем глобальный флаг блокировки
    window.UI_BLOCKED = true;
    console.log('🚫 UI blocked globally during long press');
    
    window.updateUI = () => {
        console.log('🚫 updateUI blocked during long press (early)');
        return;
    };
    
    // Также блокируем renderMainContent
    if (typeof renderMainContent === 'function') {
        window.renderMainContent = () => {
            console.log('🚫 renderMainContent blocked during long press');
            return;
        };
    }
    
    // Добавляем анимацию нажатия
    const button = document.querySelector(`[data-long-press="${type}"]`);
    if (button) {
        button.style.transform = 'scale(0.95)';
        button.style.transition = 'transform 0.1s ease';
        
        // Устанавливаем флаг долгого нажатия для блокировки обычного клика
        button.setAttribute('data-long-press-triggered', 'true');
        
        // Также устанавливаем глобальный флаг
        S.longPressTriggered = true;
        
        // Возвращаем кнопку в нормальное состояние
        setTimeout(() => {
            button.style.transform = '';
            button.style.transition = '';
        }, 100);
    }
    
    // Показываем случайный элемент без перерисовки UI
    console.log('🚀 Calling showRandomElement...');
    showRandomElement(type, originalUpdateUI, originalRenderMainContent);
    
    // Сбрасываем флаг выполнения
    window.handleLongPressInProgress = false;
    console.log('🔄 handleLongPress execution flag reset');
}

// Функция для показа случайного элемента без перерисовки UI
async function showRandomElement(type, originalUpdateUI, originalRenderMainContent) {
    console.log(`🎲 showRandomElement called for type: ${type}`);
    
    // Защита от повторного вызова
    if (window.showRandomElementInProgress) {
        console.log('🚫 showRandomElement already in progress, skipping...');
        return;
    }
    window.showRandomElementInProgress = true;
    
    // updateUI и renderMainContent уже заблокированы в handleLongPress
    
    // Небольшая задержка для лучшего UX
    await new Promise(resolve => setTimeout(resolve, 300));
    
    try {
        if ("parts" === type) {
            console.log('🎯 Opening random part modal...');
            // Показываем случайную деталь
            const hasCats = Array.isArray(flatCategories) && flatCategories.length > 0;
            let pool = [];
            if (hasCats) {
                const tries = Math.min(10, flatCategories.length);
                for (let i = 0; i < tries && pool.length === 0; i++) {
                    const randomCat = flatCategories[Math.floor(Math.random() * flatCategories.length)];
                    pool = Object.values(PART_MAP).filter(p => p && p.categoryId === randomCat.id && p.name);
                }
            }
            if (pool.length === 0) {
                pool = Object.values(PART_MAP).filter(p => p && p.name);
            }
            if (pool.length === 0) throw new Error("Детали еще не загружены.");
            
            const randomPart = pool[Math.floor(Math.random() * pool.length)];
            const partId = randomPart.id || randomPart.part_num;
            if (!partId) throw new Error("Некорректные данные детали.");
            
            const groupId = getGroupId(partId);
            let variants = Object.values(PART_MAP).filter(v => 
                v && (v.id || v.part_num) && getGroupId(v.id || v.part_num) === groupId
            );
            if (typeof partCmp === 'function') variants = variants.sort(partCmp);
            
            openModalForPart(partId, groupId, variants.length ? variants : [randomPart]);
            
        } else if ("sets" === type) {
            console.log('🎯 Opening random set modal...');
            // Небольшая задержка для лучшего UX
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // Показываем случайный набор
            let setPool = Object.values(SET_MAP).filter(s => s && s.name);
            if (setPool.length === 0) throw new Error("Наборы еще не загружены.");
            
            // Пытаемся найти наборы с определенной темой для разнообразия
            const themeIds = Object.keys(THEME_MAP || {});
            if (themeIds.length > 0) {
                const tries = Math.min(5, themeIds.length);
                for (let i = 0; i < tries; i++) {
                    const themeId = parseInt(themeIds[Math.floor(Math.random() * themeIds.length)], 10);
                    const themed = setPool.filter(s => s && s.theme_id === themeId);
                    if (themed.length > 0) { 
                        setPool = themed; 
                        break; 
                    }
                }
            }
            
            const randomSet = setPool[Math.floor(Math.random() * setPool.length)];
            if (!randomSet || !randomSet.set_num) throw new Error("Некорректные данные набора.");
            
            SET_MAP[randomSet.set_num] = randomSet;
            
            openModalForSet(randomSet.set_num);
            
        } else if ("minifigs" === type) {
            console.log('🎯 Opening random minifig modal...');
            // Небольшая задержка для лучшего UX
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // Показываем случайную минифигурку
            let figs = Object.values(MINIFIG_MAP).filter(f => f && f.name);
            if (figs.length === 0) throw new Error("Минифигурки еще не загружены.");
            
            const randomFig = figs[Math.floor(Math.random() * figs.length)];
            MINIFIG_MAP[randomFig.set_num] = randomFig;
            
            openModalForMinifig(randomFig.set_num);
        }
        
        // Сбрасываем флаг долгого нажатия после успешного показа элемента
        S.longPressTriggered = false;
        console.log('🔄 Long press flag reset');
        
        // Восстанавливаем updateUI и renderMainContent
        if (originalUpdateUI) {
            window.updateUI = originalUpdateUI;
            console.log('🔄 updateUI restored');
        }
        if (originalRenderMainContent) {
            window.renderMainContent = originalRenderMainContent;
            console.log('🔄 renderMainContent restored');
        }
        
        // Сбрасываем глобальный флаг блокировки
        window.UI_BLOCKED = false;
        console.log('🔄 Global UI block removed');
        
    } catch (e) {
        console.error("showRandomElement failed:", e);
        // Показываем ошибку пользователю без перерисовки UI
        const errorNotification = document.createElement('div');
        errorNotification.className = 'fixed top-20 left-1/2 transform -translate-x-1/2 bg-red-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 text-sm font-medium';
        errorNotification.textContent = `❌ Ошибка: ${e.message}`;
        document.body.appendChild(errorNotification);
        
        setTimeout(() => {
            if (errorNotification.parentNode) {
                errorNotification.parentNode.removeChild(errorNotification);
            }
        }, 3000);
        
        // Сбрасываем флаг долгого нажатия даже при ошибке
        S.longPressTriggered = false;
        
        // Восстанавливаем updateUI и renderMainContent даже при ошибке
        if (originalUpdateUI) {
            window.updateUI = originalUpdateUI;
            console.log('🔄 updateUI restored after error');
        }
        if (originalRenderMainContent) {
            window.renderMainContent = originalRenderMainContent;
            console.log('🔄 renderMainContent restored after error');
        }
        
        // Сбрасываем глобальный флаг блокировки
        window.UI_BLOCKED = false;
        console.log('🔄 Global UI block removed after error');
    } finally {
        // Всегда сбрасываем флаг выполнения
        window.showRandomElementInProgress = false;
        console.log('🔄 showRandomElement execution flag reset');
    }
}

// Функция для настройки обработчиков долгого нажатия
function setupLongPressHandlers() {
    const longPressButtons = document.querySelectorAll('[data-long-press]');
    
    longPressButtons.forEach(button => {
        let pressTimer = null;
        const longPressDelay = 1000; // 1 секунда
        let pressStartTime = 0;
        let longPressTriggered = false; // Флаг для блокировки обычного клика
        
        const startPress = (e) => {
            pressStartTime = Date.now();
            longPressTriggered = false; // Сбрасываем флаг при начале нажатия
            
            // Добавляем визуальную обратную связь
            button.style.transition = 'all 0.3s ease';
            button.style.filter = 'brightness(1.1)';
            
            pressTimer = setTimeout(() => {
                const type = button.getAttribute('data-long-press');
                if (type) {
                    longPressTriggered = true; // Устанавливаем флаг при срабатывании долгого нажатия
                    handleLongPress(type);
                }
            }, longPressDelay);
        };
        
        const endPress = () => {
            if (pressTimer) {
                clearTimeout(pressTimer);
                pressTimer = null;
            }
            
            // Возвращаем кнопку в нормальное состояние
            button.style.filter = '';
            
            // Если нажатие было коротким, убираем все эффекты
            const pressDuration = Date.now() - pressStartTime;
            if (pressDuration < longPressDelay) {
                button.style.transition = '';
            }
        };
        
        // Блокируем обычный клик после долгого нажатия
        const blockClick = (e) => {
            if (longPressTriggered) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                longPressTriggered = false; // Сбрасываем флаг
                return false;
            }
        };
        
        // Обработчики для мобильных устройств
        button.addEventListener('touchstart', startPress, { passive: true });
        button.addEventListener('touchend', endPress, { passive: true });
        button.addEventListener('touchcancel', endPress, { passive: true });
        button.addEventListener('click', blockClick, true); // Используем capture для блокировки
        
        // Обработчики для десктопа
        button.addEventListener('mousedown', startPress);
        button.addEventListener('mouseup', endPress);
        button.addEventListener('mouseleave', endPress);
        button.addEventListener('click', blockClick, true); // Используем capture для блокировки
        
        // Предотвращаем контекстное меню при долгом нажатии
        button.addEventListener('contextmenu', (e) => e.preventDefault());
    });
}

async function handleFeelingLucky(type = null) {
    // Если тип не передан, используем текущий subView
    const targetType = type || S.subView;
    console.log('🎲 handleFeelingLucky called, targetType:', targetType, 'current subView:', S.subView, 'loading:', S.loading);
    
    // Анимация кнопки
    const button = document.getElementById('feeling-lucky-button');
    const icon = document.getElementById('feeling-lucky-icon');
    const text = document.getElementById('feeling-lucky-text');
    
    if (button && icon && text) {
        button.disabled = true;
        button.classList.add('opacity-75', 'cursor-not-allowed');
        icon.innerHTML = '<div class="loader !w-6 !h-6 !border-2"></div>';
        text.textContent = 'Ищем сокровище...';
    }
    
    console.log('🔄 Setting loading state and calling updateUI');
    S.loading = !0, S.err = null, S.gridStale = !0, updateUI();
    try {
                if ("parts" === targetType) {
            // Небольшая задержка для лучшего UX
            await new Promise(resolve => setTimeout(resolve, 800));
            
            // Показываем случайную деталь из всей библиотеки (каталога)
            const hasCats = Array.isArray(flatCategories) && flatCategories.length > 0;
            let pool = [];
            if (hasCats) {
                const tries = Math.min(10, flatCategories.length);
                for (let i = 0; i < tries && pool.length === 0; i++) {
                    const randomCat = flatCategories[Math.floor(Math.random() * flatCategories.length)];
                    pool = Object.values(PART_MAP).filter(p => p && p.categoryId === randomCat.id && p.name);
                }
            }
            if (pool.length === 0) {
                pool = Object.values(PART_MAP).filter(p => p && p.name);
            }
            if (pool.length === 0) throw new Error("Детали еще не загружены.");
            
            const randomPart = pool[Math.floor(Math.random() * pool.length)];
            const partId = randomPart.id || randomPart.part_num;
            if (!partId) throw new Error("Некорректные данные детали.");
            
            const groupId = getGroupId(partId);
            let variants = Object.values(PART_MAP).filter(v => 
                v && (v.id || v.part_num) && getGroupId(v.id || v.part_num) === groupId
            );
            if (typeof partCmp === 'function') variants = variants.sort(partCmp);
            
            openModalForPart(partId, groupId, variants.length ? variants : [randomPart]);
            
        } else if ("sets" === targetType) {
            // Небольшая задержка для лучшего UX
            await new Promise(resolve => setTimeout(resolve, 800));
            
            // Показываем случайный набор из всей библиотеки (каталога)
            let setPool = Object.values(SET_MAP).filter(s => s && s.name);
            if (setPool.length === 0) throw new Error("Наборы еще не загружены.");
            
            // Пытаемся найти наборы с определенной темой для разнообразия
            const themeIds = Object.keys(THEME_MAP || {});
            if (themeIds.length > 0) {
                const tries = Math.min(5, themeIds.length);
                for (let i = 0; i < tries; i++) {
                    const themeId = parseInt(themeIds[Math.floor(Math.random() * themeIds.length)], 10);
                    const themed = setPool.filter(s => s && s.theme_id === themeId);
                    if (themed.length > 0) { 
                        setPool = themed; 
                        break; 
                    }
                }
            }
            
            const randomSet = setPool[Math.floor(Math.random() * setPool.length)];
            if (!randomSet || !randomSet.set_num) throw new Error("Некорректные данные набора.");
            
            SET_MAP[randomSet.set_num] = randomSet;
            
            openModalForSet(randomSet.set_num);
            S.loading = !1;
            return void updateUI();
            
        } else {
            // Небольшая задержка для лучшего UX
            await new Promise(resolve => setTimeout(resolve, 800));
            
            // Показываем случайную минифигурку из всей библиотеки (каталога)
            let figs = Object.values(MINIFIG_MAP).filter(f => f && f.name);
            if (figs.length === 0) throw new Error("Минифигурки еще не загружены.");
            
            const randomFig = figs[Math.floor(Math.random() * figs.length)];
            MINIFIG_MAP[randomFig.set_num] = randomFig;
            
            openModalForMinifig(randomFig.set_num);
        }
    } catch (e) {
        console.error("Feeling lucky failed:", e);
        S.err = `Не удалось совершить чудо: ${e.message}`;
    } finally {
        S.loading = !1;
        updateUI();
        
        // Восстанавливаем кнопку
        const button = document.getElementById('feeling-lucky-button');
        const icon = document.getElementById('feeling-lucky-icon');
        const text = document.getElementById('feeling-lucky-text');
        
        if (button && icon && text) {
            button.disabled = false;
            button.classList.remove('opacity-75', 'cursor-not-allowed');
            icon.innerHTML = I_Dice("w-6 h-6");
            text.textContent = 'Мне повезёт!';
        }
        
        // Обновляем подсказку при каждом клике с анимацией
        const tipElement = document.getElementById('feeling-lucky-tip');
        if (tipElement && window.getRandomTip && window.animateTipChange) {
            const newTip = window.getRandomTip();
            window.animateTipChange(tipElement, newTip, () => {
                // Добавляем подсказку в историю после анимации
                if (window.addTipToHistory) {
                    window.addTipToHistory(newTip, 'feelingLucky');
                }
            });
        }
        
        // Перезапускаем автоматическую смену подсказок при каждом клике
        // ОТКЛЮЧЕНО: конфликт с системой неактивности
        // setTimeout(() => {
        //     if (window.startTipRotation) {
        //         console.log('Restarting tip rotation after feeling lucky click');
        //         window.startTipRotation();
        //     }
        // }, 500);
    }
}

// Функция для обновления статистики кнопки "Мне повезёт"
function updateFeelingLuckyStats() {
    console.log('🔍 updateFeelingLuckyStats called, subView:', S.subView, 'loading:', S.loading);
    
    const statsElement = document.getElementById('feeling-lucky-stats');
    const tipElement = document.getElementById('feeling-lucky-tip');
    
    if (!statsElement) {
        console.log('❌ statsElement not found');
        return;
    }
    
    try {
        let stats = '';
        if (S.subView === 'parts') {
            const totalParts = Object.values(PART_MAP).filter(p => p && p.name).length;
            stats = `🎲 ${totalParts.toLocaleString()} деталей в каталоге`;
        } else if (S.subView === 'sets') {
            const totalSets = Object.values(SET_MAP).filter(s => s && s.name).length;
            stats = `🎲 ${totalSets.toLocaleString()} наборов в каталоге`;
        } else {
            const totalMinifigs = Object.values(MINIFIG_MAP).filter(f => f && f.name).length;
            stats = `🎲 ${totalMinifigs.toLocaleString()} минифигурок в каталоге`;
        }
        
        statsElement.textContent = stats;
        
        // Обновляем подсказку с анимацией
        if (tipElement && window.getRandomTip && window.animateTipChange) {
            const newTip = window.getRandomTip();
            // Если это первая подсказка, показываем её без анимации исчезновения
            if (!tipElement.textContent || tipElement.textContent === '💡 Загружаем подсказку...') {
                tipElement.textContent = newTip;
                tipElement.classList.add('fade-in', 'show');
                setTimeout(() => {
                    tipElement.classList.remove('fade-in', 'show');
                }, 600);
                // Добавляем первую подсказку в историю
                if (window.addTipToHistory) {
                    window.addTipToHistory(newTip, 'feelingLucky');
                }
            } else {
                window.animateTipChange(tipElement, newTip, () => {
                    // Добавляем подсказку в историю после анимации
                    if (window.addTipToHistory) {
                        window.addTipToHistory(newTip, 'feelingLucky');
                    }
                });
            }
        }
        
        // Запускаем автоматическую смену подсказок, если еще не запущена
        // ОТКЛЮЧЕНО: конфликт с системой неактивности
        // if (window.startTipRotation && !window.tipRotationInterval) {
        //     console.log('🚀 Starting tip rotation from updateFeelingLuckyStats');
        //     window.startTipRotation();
        // } else if (window.startTipRotation && window.tipRotationInterval) {
        //     console.log('⚠️ Tip rotation already running, interval ID:', window.tipRotationInterval);
        //     // НЕ перезапускаем ротацию - это создает бесконечный цикл!
        // } else {
        //     console.log('❌ startTipRotation function not available');
        // }
    } catch (e) {
        console.error('💥 Error in updateFeelingLuckyStats:', e);
        statsElement.textContent = 'Статистика недоступна';
        if (tipElement) {
            tipElement.textContent = '💡 Подсказка недоступна';
        }
    }
}



function getPartImageUrl(e) {
    const t = `data:image/svg+xml,${encodeURIComponent(I_Img("w-full h-full text-gray-500"))}`;
    
    // Debug: Log the URL being processed
    // console.debug('getPartImageUrl:', e);
    
    if (!e || typeof e !== 'string' || e.trim() === '') {
        // console.debug('Empty or invalid URL, using fallback');
        return `src="${t}"`;
    }
    
    // Принимаем различные типы URL изображений
    const trimmedUrl = e.trim();
    // console.debug('Trimmed URL:', trimmedUrl);
    
    // Принимаем HTTP URL, data URL и относительные пути
    if (trimmedUrl.startsWith('http') || trimmedUrl.startsWith('data:') || trimmedUrl.startsWith('./') || trimmedUrl.startsWith('/')) {
        // console.debug('Valid URL format detected, using:', trimmedUrl);
        return `src="${trimmedUrl}" onerror="this.onerror=null; this.src='${t}';"`
    }
    
    // Для других случаев пытаемся использовать URL как есть, но выводим предупреждение
    console.warn('Potentially invalid image URL detected:', trimmedUrl);
    return `src="${trimmedUrl}" onerror="this.onerror=null; this.src='${t}';"`
}

// Специальные атрибуты изображения для детали с авто-подбором вариации при ошибке
function getPartImageAttrs(partId, url) {
    const fallback = `data:image/svg+xml,${encodeURIComponent(I_Img("w-full h-full text-gray-500"))}`;
    const u = (url || '').trim();
    if (u && (u.startsWith('http') || u.startsWith('./') || u.startsWith('/'))) {
        return `src="${u}" onerror="window.onPartImgError && window.onPartImgError('${partId}', this)"`;
    }
    return `src="${fallback}"`;
}

// При ошибке загрузки картинки детали пытаемся найти другую вариацию с изображением
window.onPartImgError = (partId, imgEl) => {
    try {
        if (!partId || !imgEl) return;
        const fallback = `data:image/svg+xml,${encodeURIComponent(I_Img("w-full h-full text-gray-500"))}`;
        const tried = (imgEl.getAttribute('data-tried-ids') || '').split(',').filter(Boolean);
        const gid = getGroupId(partId);
        const variants = Object.values(PART_MAP).filter(v => {
            const vid = v.id || v.part_num;
            return vid && getGroupId(vid) === gid;
        });
        const hasImg = v => {
            const u = (v.part_img_url || v.rebrickable_img_url || '').trim();
            return u.startsWith('http');
        };
        const next = variants.find(v => hasImg(v) && !tried.includes(v.id));
        if (next) {
            tried.push(partId, next.id);
            imgEl.setAttribute('data-tried-ids', tried.join(','));
            imgEl.onerror = () => window.onPartImgError(next.id, imgEl);
            imgEl.src = next.part_img_url || next.rebrickable_img_url;
            return;
        }
        // Не нашли подходящую вариацию – ставим заглушку
        imgEl.onerror = null;
        imgEl.src = fallback;
    } catch {}
};
// Специальные атрибуты изображения для набора с обработкой ошибки загрузки
function getSetImageAttrs(setNum, url) {
    const fallback = `data:image/svg+xml,${encodeURIComponent(I_Img("w-full h-full text-gray-500"))}`;
    const u = (url || '').trim();
    if (u && (u.startsWith('http') || u.startsWith('./') || u.startsWith('/'))) {
        return `src="${u}" onerror="window.onSetImgError && window.onSetImgError('${setNum}', this)"`;
    }
    return `src="${fallback}"`;
}
// Глобальный обработчик ошибки загрузки изображения набора
window.onSetImgError = async (setNum, imgEl) => {
    try {
        if (!setNum) return;
        // Если уже в процессе — просто запомним imgEl как ждущий и выходим
        if (SET_IMAGE_PENDING.has(setNum)) {
            if (imgEl) {
                const waiters = SET_IMAGE_WAITERS.get(setNum) || [];
                waiters.push(imgEl);
                SET_IMAGE_WAITERS.set(setNum, waiters);
            }
            return;
        }
        // Создаём единый запрос и расшариваем результат между всеми карточками
        const pending = (async () => {
            SET_IMAGE_FETCHING.add(setNum);
            try {
                
                const resp = await fetch(`${REBRICKABLE_API_URL}/sets/${setNum}/`, {
                    headers: { Authorization: `key ${getApiKey()}` }
                });
                if (!resp.ok) return undefined;
                const data = await resp.json();
                return data?.set_img_url || undefined;
            } catch {
                return undefined;
            } finally {
                SET_IMAGE_FETCHING.delete(setNum);
            }
        })();
        SET_IMAGE_PENDING.set(setNum, pending);
        const url = await pending;
        SET_IMAGE_PENDING.delete(setNum);
        const allWaiters = [imgEl, ...(SET_IMAGE_WAITERS.get(setNum) || [])].filter(Boolean);
        SET_IMAGE_WAITERS.delete(setNum);
        if (!SET_MAP[setNum]) SET_MAP[setNum] = { set_num: setNum };
        if (!url) {
            // Нет изображения в API – ставим стандартную заглушку и запоминаем отсутствие
            SET_MAP[setNum].set_img_url = '';
            saveState();
            const fallback = `data:image/svg+xml,${encodeURIComponent(I_Img("w-full h-full text-gray-500"))}`;
            allWaiters.forEach(el => {
                try {
                    el.onerror = null;
                    el.src = fallback;
                    const parent = el.closest('[data-action="view-image-fullscreen"]');
                    if (parent) parent.setAttribute('data-image-url', '');
                } catch {}
            });
            return;
        }
        // Успешно получили URL
        SET_MAP[setNum].set_img_url = url;
        markApiStatOnce('images', `set:${setNum}`);
        markApiStatOnce('sets', setNum);
        saveState();
        allWaiters.forEach(el => {
            try {
                el.onerror = null;
                el.src = url;
                const parent = el.closest('[data-action="view-image-fullscreen"]');
                if (parent) parent.setAttribute('data-image-url', url || '');
            } catch {}
        });
        // Мягкое обновление списка без полного мигания
        if (S.view === 'catalog') {
            requestAnimationFrame(() => { S.gridStale = false; });
        } else {
            S.gridStale = true; updateUI();
        }
    } catch (err) {
        console.warn('onSetImgError: failed to recover image for set', setNum, err);
    } finally {
        // no-op, очищается выше
    }
};


        

        


function sortColorIds(e, t) {
    const o = ["0", "15", "4", "1", "14", "2", "71", "72", "88", "19", "5", "34"],
        l = Object.keys(S.coll[t] || {});
    return [...e].sort((e, t) => {
        const a = o.includes(e),
            i = o.includes(t);
        if (a && !i) return -1;
        if (!a && i) return 1;
        const n = l.includes(e),
            r = l.includes(t);
        if (n && !r) return -1;
        if (!n && r) return 1;
        const s = COLOR_MAP[e],
            c = COLOR_MAP[t];
        return s && c ? s.name.localeCompare(c.name, 'en') : 0
    })
}

function getPluralizedColorString(e) {
    const t = Math.abs(e),
        o = t % 10,
        l = t % 100;
    return l >= 11 && l <= 19 ? "цветов" : 1 === o ? "цвет" : [2, 3, 4].includes(o) ? "цвета" : "цветов"
}

function parseCsvLine(e) {
    const t = [];
    let o = "",
        l = !1;
    const a = '"';
    for (let i = 0; i < e.length; i++) {
        const n = e[i];
        n === a ? l && e[i + 1] === a ? (o += a, i++) : l = !l : "," === n && !l ? (t.push(o), o = "") : o += n
    }
    return t.push(o), t.map(e => e.trim())
}
const CATEGORY_ICONS = {
    'Bricks': I_Brick,
    'Plates': I_Plate,
    'Technic': I_Tech,
    'Slopes & Wedges': I_Slope,
    'Tiles': I_Tile,
    'Panels, Doors & Windows': I_Win,
    'Wheels & Tyres': I_Wheel,
    'Minifig': I_Minifig,
    'Bars, Hinges & Connectors': I_Bar,
    'Arches & Curves': I_Arch,
    'Other': I_Other
};

function filterThemeTreeForCollection(e, t) {
    return Array.isArray(e) ? e.map(e => {
        if (!e || !e.id) return null;
        const o = Array.isArray(e.children) && e.children.length > 0 ? filterThemeTreeForCollection(e.children, t) : [];
        return t.has(e.id) || o.length > 0 ? { ...e,
            children: o
        } : null
    }).filter(Boolean) : []
}

// Функция для подсчета количества деталей в категории
function getCategoryPartCount(categoryId) {
    if (!S.coll || !categoryId) return 0;
    let count = 0;
    Object.keys(S.coll).forEach(partId => {
        const part = PART_MAP[partId];
        if (part && part.categoryId === categoryId) {
            // Считаем общее количество деталей всех цветов
            Object.values(S.coll[partId]).forEach(colorQty => {
                count += colorQty;
            });
        }
    });
    return count;
}

// Функция для подсчета количества наборов в теме
function getThemeSetCount(themeId) {
    if (!S.setColl || !themeId) return 0;
    let count = 0;
    Object.keys(S.setColl).forEach(setId => {
        const set = SET_MAP[setId];
        if (set && set.theme_id === themeId) {
            count += S.setColl[setId].qty;
        }
    });
    return count;
}

// Функция для подсчета количества минифигурок в коллекции
function getMinifigCount() {
    if (!S.minifigColl) return 0;
    let count = 0;
    Object.values(S.minifigColl).forEach(minifig => {
        count += minifig.qty;
    });
    return count;
}

// Функция для получения случайного изображения минифигурки
    function getRandomMinifigImage() {
        // Если случайное изображение уже выбрано, возвращаем его
        if (S.randomMinifigImage) {
            return S.randomMinifigImage;
        }
        
        const min = 1;
        let max = 30; // Fallback значение
        
        // Используем количество из загруженного файла, если доступно
        if (window.MINIFIG_COUNT && window.MINIFIG_COUNT > 0) {
            max = window.MINIFIG_COUNT;
        }
        
        let randomNum;
        // Выбираем случайное число, отличное от предыдущего
        do {
            randomNum = Math.floor(Math.random() * (max - min + 1)) + min;
        } while (randomNum === S.lastMinifigNumber && max > 1); // Повторяем, если выбрали ту же фигурку (если есть больше 1 фигурки)
        
        const imagePath = `./Minifig_png/fig-${randomNum}.png`;
        
        // Предзагружаем изображение в кэш, если оно еще не загружено
        const img = new Image();
        img.src = imagePath;
        
        // Сохраняем выбранное изображение в состоянии
        S.randomMinifigImage = imagePath;
        S.lastMinifigNumber = randomNum;
        
        return imagePath;
    }
    
    // Функция для сброса случайного изображения минифигурки
    function resetRandomMinifigImage() {
        S.randomMinifigImage = null;
        S.lastMinifigNumber = null;
    }
    
    // Функция для настройки управления боковой панелью во время загрузки
    function setupSidebarDuringLoading() {
        const e = window.innerWidth < 1024;
        // На малых экранах настраиваем боковую панель согласно состоянию S.sidebarOpen
        if (e) {
            if (S.sidebarOpen) {
                sidebarEl.classList.remove("-translate-x-full");
                backdropEl.classList.remove("hidden");
                document.body.style.overflow = "hidden";
            } else {
                sidebarEl.classList.add("-translate-x-full");
                backdropEl.classList.add("hidden");
                document.body.style.overflow = "";
            }
        }
    }
    
    // Функция для настройки управления боковой панелью
    function setupSidebarManagement() {
        const e = window.innerWidth < 1024;
        // На больших экранах (>=1024px) боковая панель всегда открыта
        if (window.innerWidth >= 1024) {
            S.sidebarOpen = true;
            sidebarEl.classList.remove("-translate-x-full");
            backdropEl.classList.add("hidden");
            document.body.style.overflow = "";
            document.body.classList.add('sidebar-open-large');
        } else {
            // На малых экранах логика остается прежней
            e ? S.sidebarOpen ? (sidebarEl.classList.remove("-translate-x-full"), backdropEl.classList.remove("hidden"), document.body.style.overflow = "hidden") : (sidebarEl.classList.add("-translate-x-full"), backdropEl.classList.add("hidden"), document.body.style.overflow = "") : (sidebarEl.classList.remove("-translate-x-full"), backdropEl.classList.add("hidden"), document.body.style.overflow = "")
            
            // Убираем класс sidebar-open-large для малых экранов
            document.body.classList.remove('sidebar-open-large');
        }
    }

function renderSidebar() {
    // Сохраняем позицию прокрутки списка, чтобы избежать подпрыгивания при перерисовке
    const prevScrollTop = sidebarEl.querySelector('#sidebar-scroll-container')?.scrollTop || 0;
    const e = Object.values(S.coll).reduce((e, t) => e + Object.values(t).reduce((e, t) => e + t, 0), 0);
    const t = Object.keys(S.coll).reduce((e, t) => e + Object.keys(S.coll[t]).length, 0);
    const o = Object.values(S.setColl).reduce((e, t) => e + t.qty, 0);
    const l = Object.keys(S.setColl).length;
    const a = Object.values(S.minifigColl).reduce((e, t) => e + t.qty, 0);
    const i = Object.keys(S.minifigColl).length;
    const n = (e) => `flex items-center w-full p-3 text-base font-semibold rounded-lg transition-colors duration-150 ${S.view===e?"bg-blue-600 text-white":"text-gray-400 hover:bg-gray-700 hover:text-white"}`;
    const r = (e) => `relative flex-1 py-2 px-1 rounded-lg text-sm font-semibold transition-colors duration-200 flex flex-col items-center justify-center gap-1 ${S.subView===e?"bg-blue-600 text-white":"text-gray-300 hover:bg-gray-700 hover:text-white"}`;
    const s = (e, t, o) => {
        if (o === 0 || "collection" !== S.view) return "";
        const l = t;
        const i = l >= 1e3 ? "text-[10px] px-1" : "text-xs px-1.5";
        const a = `absolute top-1 right-1 ${i} py-0.5 rounded-full font-bold ${S.subView===e?"bg-blue-200 text-blue-800":"bg-gray-600 text-gray-200"}`;
        return `<span class="${a}">${String(l)}</span>`
    };
    let c = "",
        d = "";
    if ("sets" === S.subView) {
        d = "Темы";
        let e = S.themeTree;
        let t = "";
        if ("collection" === S.view || "catalog" === S.view) {
            if ("collection" === S.view) {
                const isActive = (S.selCollThemeId === null);
                const btnClass = isActive ? "bg-blue-600 text-white" : "text-gray-300 hover:bg-gray-700 hover:text-white";
                t = `
                  <li>
                    <button data-action="show-all-collection-items" class="w-full text-left flex items-start justify-between p-2 rounded-md transition-colors duration-150 ${btnClass}">
                      <span class="break-words leading-tight flex-1 self-center">Все наборы</span>
                    </button>
                  </li>
                `;
            } else {
                // Каталог: кнопка активна только когда действительно открыт и загружен полный список наборов
                const isActive = (
                  S.view === "catalog" &&
                  S.subView === "sets" &&
                  S.selThemeId === null &&
                  (S.q ?? "") === "" &&
                  Array.isArray(S.setRes) && S.setRes.length > 0
                );
                const btnClass = isActive ? "bg-blue-600 text-white" : "text-gray-300 hover:bg-gray-700 hover:text-white";
                // Используем общее количество всех наборов в каталоге, независимо от выбранной темы
                const totalSetsInCatalog = S.totalSetsInCatalog || 0;
                const countBadge = totalSetsInCatalog > 0 ? `
                    <span class="ml-2 bg-gray-600 text-white text-xs font-bold rounded-full px-2 py-1 min-w-[20px] text-center">
                        ${totalSetsInCatalog}
                    </span>
                ` : '';
                t = `
                  <li>
                    <button data-action="show-all-items-sets" class="w-full text-left flex items-start justify-between p-2 rounded-md transition-colors duration-150 ${btnClass}">
                      <span class="break-words leading-tight flex-1 self-center">Все наборы</span>
                      <div class="flex-shrink-0 ml-2 self-center">
                        ${countBadge}
                      </div>
                    </button>
                  </li>
                `;
            }
            if ("collection" === S.view) {
                const a = new Set();
                Object.keys(S.setColl).forEach(e => {
                    const t = SET_MAP[e];
                    if (t && t.theme_id) {
                        let e = t.theme_id;
                        for (; e;) {
                            a.add(e);
                            e = THEME_MAP[e]?.parent_id
                        }
                    }
                });
                e = filterThemeTreeForCollection(S.themeTree, a)
            }
        }
        const o = (e) => {
            if (!Array.isArray(e)) return [];
            e.forEach(e => {
                e && Array.isArray(e.children) && o(e.children)
            });
            return e.sort((e, t) => {
                const o = S.favThemeIds.has(e.id),
                    l = S.favThemeIds.has(t.id);
                return o && !l ? -1 : !o && l ? 1 : e.name.localeCompare(t.name, 'en')
            }), e
        };
        o(e);
        const l = (e, t = 0) => {
            if (!Array.isArray(e)) return "";
            return e.map(e => {
                if (!e) return "";
                const o = S.expThemes.has(e.id),
                    a = ("catalog" === S.view && S.selThemeId === e.id || "collection" === S.view && S.selCollThemeId === e.id) ? "bg-blue-600/80 text-white" : "text-gray-400 hover:bg-gray-700/50 hover:text-gray-200",
                    i = Array.isArray(e.children) && e.children.length > 0 ? `<ul class="space-y-1 ${o?"":"hidden"}">${l(e.children,t+1)}</ul>` : "",
                    n = S.favThemeIds.has(e.id),
                    r = n ? "text-red-400 opacity-100" : "text-gray-500 lg:opacity-0 lg:group-hover:opacity-100";
                const setCount = getThemeSetCount(e.id);
                const countBadge = ("collection" === S.view && setCount > 0) ? `
                    <span class="ml-2 bg-gray-600 text-white text-xs font-bold rounded-full px-2 py-1 min-w-[20px] text-center">
                        ${setCount}
                    </span>
                ` : '';
                return `
                    <li class="space-y-1">
                        <button data-theme-id="${e.id}" class="w-full text-left flex items-start justify-between p-2 rounded-md transition-colors duration-150 ${a} group" style="padding-left: ${.5+1.5*t}rem;">
                            <div class="flex flex-1 min-w-0">
                                <span data-action="toggle-favorite-theme" data-theme-id="${e.id}" class="p-1 rounded-full hover:bg-gray-600 hover:text-red-400 transition-opacity z-10 mr-2 ${r} flex-shrink-0 self-center" aria-label="Добавить в избранное">
                                    ${I_Heart("w-4 h-4",n)}
                                </span>
                                <span class="break-words leading-tight">${e.name}</span>
                            </div>
                            <div class="flex items-center gap-2 flex-shrink-0 ml-2 self-center">
                                ${countBadge}
                                ${Array.isArray(e.children)&&e.children.length>0?I_Chev(`w-5 h-5 text-gray-400 transform transition-transform duration-200 flex-shrink-0 ${o?"rotate-180":""}`):""}
                            </div>
                        </button>
                        ${i}
                    </li>
                `
            }).join("")
        };
        if (S.sidebarLoading) {
            // Во время загрузки показываем содержимое с индикатором загрузки сверху
            c = '<div class="flex items-center justify-center p-3 mb-3 bg-gray-700/50 rounded-lg"><div class="loader !w-5 !h-5 mr-2"></div><span class="text-sm text-gray-300">Загрузка данных...</span></div>' + (t + l(e));
        } else {
            c = t + l(e);
        }
            } else if ("minifigs" === S.subView) {
                d = "Минифигурки";
                let minifigContent = '';
                
                if ("collection" === S.view) {
                    const totalMinifigsInCollection = getMinifigCount();
                    const countBadge = totalMinifigsInCollection > 0 ? `
                        <span class="ml-2 bg-gray-600 text-white text-xs font-bold rounded-full px-2 py-1 min-w-[20px] text-center">
                            ${totalMinifigsInCollection}
                        </span>
                    ` : '';
                    
                    minifigContent = `
                        <li class="text-gray-400 text-sm p-2">Используйте поиск или просмотрите каталог.</li>
                        <li class="flex justify-center p-2">
                            <div class="p-2 sm:p-3 md:p-4 lg:p-5">
                                <img src="${getRandomMinifigImage()}" alt="Случайная минифигурка" class="w-56 h-56 sm:w-72 sm:h-72 md:w-80 md:h-80 lg:w-96 lg:h-96 object-contain" onerror="this.style.display='none'">
                            </div>
                        </li>
                    `;
                } else {
                    minifigContent = `
                        <li class="text-gray-400 text-sm p-2">Используйте поиск или просмотрите каталог.</li>
                        <li class="flex justify-center p-2">
                            <div class="p-2 sm:p-3 md:p-4 lg:p-5">
                                <img src="${getRandomMinifigImage()}" alt="Случайная минифигурка" class="w-56 h-56 sm:w-72 sm:h-72 md:w-80 md:h-80 lg:w-96 lg:h-96 object-contain" onerror="this.style.display='none'">
                            </div>
                        </li>
                    `;
                }
                
                c = minifigContent;
            }
    else {
        d = "Категории";
        let e = S.catTree;
        let t = "";
        if ("collection" === S.view || "catalog" === S.view) {
            if ("collection" === S.view) {
                const isActive = (S.selCollCatId === null);
                const btnClass = isActive ? "bg-blue-600 text-white" : "text-gray-300 hover:bg-gray-700 hover:text-white";
                t = `
                  <li>
                    <button data-action="show-all-collection-items" class="w-full text-left flex items-start justify-between p-2 rounded-md transition-colors duration-150 ${btnClass}">
                      <span class="break-words leading-tight flex-1 self-center">Все детали</span>
                    </button>
                  </li>
                `;
                    } else {
            // Каталог: кнопка активна только когда действительно открыт и сформирован полный список деталей
            const isActive = (
              S.view === "catalog" &&
              S.subView === "parts" &&
              S.selCatId === null &&
              (S.q ?? "") === "" &&
              S.searchGroups && Object.keys(S.searchGroups || {}).length > 0
            );
            const btnClass = isActive ? "bg-blue-600 text-white" : "text-gray-300 hover:bg-gray-700 hover:text-white";
            // Используем общее количество всех деталей в каталоге, независимо от выбранной категории/темы
            const totalPartsInCatalog = S.totalPartsInCatalog || 0;
            const countBadge = totalPartsInCatalog > 0 ? `
                <span class="ml-2 bg-gray-600 text-white text-xs font-bold rounded-full px-2 py-1 min-w-[20px] text-center">
                    ${totalPartsInCatalog}
                </span>
            ` : '';
                t = `
                  <li>
                    <button data-action="show-all-items-parts" class="w-full text-left flex items-start justify-between p-2 rounded-md transition-colors duration-150 ${btnClass}">
                      <span class="break-words leading-tight flex-1 self-center">Все детали</span>
                      <div class="flex-shrink-0 ml-2 self-center">
                        ${countBadge}
                      </div>
                    </button>
                  </li>
                `;
            }
            if ("collection" === S.view) {
                const a = new Set(Object.keys(S.coll).map(e => PART_MAP[e]?.categoryId).filter(e => void 0 !== e && null !== e));
                e = JSON.parse(JSON.stringify(S.catTree));
                e = e.map(e => (Array.isArray(e.children) && (e.children = e.children.filter(e => a.has(e.id))), e)).filter(e => Array.isArray(e.children) && e.children.length > 0)
            }
        }
        if (S.sidebarLoading) {
            // Во время загрузки показываем содержимое с индикатором загрузки сверху
            c = '<div class="flex items-center justify-center p-3 mb-3 bg-gray-700/50 rounded-lg"><div class="loader !w-5 !h-5 mr-2"></div><span class="text-sm text-gray-300">Загрузка данных...</span></div>';
            if ("collection" === S.view && Object.keys(S.coll).length > 0 && 0 === e.length) {
                c += '<li class="text-gray-400 text-sm p-2">Нет деталей в категориях.</li>';
            } else {
                e.forEach(e => {
                    Array.isArray(e.children) && e.children.sort((e, t) => {
                        const o = S.favCatIds.has(e.id),
                            l = S.favCatIds.has(t.id);
                        return o && !l ? -1 : !o && l ? 1 : e.name.localeCompare(t.name, 'en')
                    })
                });
                c += t + e.map(e => {
                    const t = S.expCats.has(e.name),
                        o = e.children.map(e => {
                            const t = ("catalog" === S.view && S.selCatId === e.id || "collection" === S.view && S.selCollCatId === e.id) ? "bg-blue-600/80 text-white" : "text-gray-400 hover:bg-gray-700/50 hover:text-gray-200",
                                o = S.favCatIds.has(e.id),
                                l = o ? "text-red-400 opacity-100" : "text-gray-500 lg:opacity-0 lg:group-hover:opacity-100";
                            return `
                              <li>
                                  <button data-category-id="${e.id}" class="w-full text-left flex items-center p-2 pl-11 rounded-md transition-colors duration-150 ${t} group">
                                    <span data-action="toggle-favorite-category" data-category-id="${e.id}" class="p-1 rounded-full hover:bg-gray-600 hover:text-red-400 transition-opacity z-10 mr-2 -ml-2 ${l}" aria-label="Добавить в избранное">
                                        ${I_Heart("w-4 h-4",o)}
                                    </span>
                                    <span class="truncate flex-grow">${e.name}</span>
                                  </button>
                              </li>
                           `
                        }).join("");
                    const l = (CATEGORY_ICONS[e.name] || I_Other)("w-5 h-5 mr-3 text-gray-400 flex-shrink-0");
                    const totalPartsInCategory = e.children.reduce((total, child) => {
                        return total + getCategoryPartCount(child.id);
                    }, 0);
                    const countBadge = ("collection" === S.view && totalPartsInCategory > 0) ? `
                        <span class="ml-2 bg-gray-600 text-white text-xs font-bold rounded-full px-2 py-1 min-w-[20px] text-center">
                            ${totalPartsInCategory}
                        </span>
                    ` : '';
                    return `
                          <li class="space-y-1">
                              <button data-parent-category="${e.name}" class="w-full text-left flex items-center justify-between p-2 rounded-md hover:bg-gray-700 transition-colors duration-150">
                                  <div class="flex items-center truncate flex-1">
                                    ${l}
                                    <span class="font-semibold text-gray-200 truncate">${e.name}</span>
                                  </div>
                                  <div class="flex items-center gap-2">
                                    ${countBadge}
                                    ${I_Chev(`w-5 h-5 text-gray-400 transform transition-transform duration-200 ${t?"rotate-180":""}`)}
                                  </div>
                              </button>
                              <ul class="space-y-1 ${t?"":"hidden"}">
                                  ${o}
                              </ul>
                          </li>
                      `
                }).join("")
            }
        } else {
            if ("collection" === S.view && Object.keys(S.coll).length > 0 && 0 === e.length) {
                c = '<li class="text-gray-400 text-sm p-2">Нет деталей в категориях.</li>';
            } else {
                e.forEach(e => {
            Array.isArray(e.children) && e.children.sort((e, t) => {
                const o = S.favCatIds.has(e.id),
                    l = S.favCatIds.has(t.id);
                return o && !l ? -1 : !o && l ? 1 : e.name.localeCompare(t.name, 'en')
            })
        }), c = t + e.map(e => {
            const t = S.expCats.has(e.name),
                o = e.children.map(e => {
                    const t = ("catalog" === S.view && S.selCatId === e.id || "collection" === S.view && S.selCollCatId === e.id) ? "bg-blue-600/80 text-white" : "text-gray-400 hover:bg-gray-700/50 hover:text-gray-200",
                        o = S.favCatIds.has(e.id),
                        l = o ? "text-red-400 opacity-100" : "text-gray-500 lg:opacity-0 lg:group-hover:opacity-100";
                    const partCount = getCategoryPartCount(e.id);
                    const countBadge = ("collection" === S.view && partCount > 0) ? `
                        <span class="ml-2 bg-gray-600 text-white text-xs font-bold rounded-full px-2 py-1 min-w-[20px] text-center">
                            ${partCount}
                        </span>
                    ` : '';
                    return `
                      <li>
                          <button data-category-id="${e.id}" class="w-full text-left flex items-start justify-between p-2 pl-11 rounded-md transition-colors duration-150 ${t} group">
                            <div class="flex flex-1 min-w-0">
                                <span data-action="toggle-favorite-category" data-category-id="${e.id}" class="p-1 rounded-full hover:bg-gray-600 hover:text-red-400 transition-opacity z-10 mr-2 -ml-2 ${l} flex-shrink-0 self-center" aria-label="Добавить в избранное">
                                    ${I_Heart("w-4 h-4",o)}
                                </span>
                                <span class="break-words leading-tight">${e.name}</span>
                            </div>
                            <div class="flex-shrink-0 ml-2 self-center">
                                ${countBadge}
                            </div>
                          </button>
                      </li>
                   `
                }).join("");
            const l = (CATEGORY_ICONS[e.name] || I_Other)("w-5 h-5 mr-3 text-gray-400 flex-shrink-0");
            return `
                  <li class="space-y-1">
                      <button data-parent-category="${e.name}" class="w-full text-left flex items-start justify-between p-2 rounded-md hover:bg-gray-700 transition-colors duration-150">
                          <div class="flex flex-1 min-w-0">
                            ${l}
                            <span class="font-semibold text-gray-200 break-words leading-tight">${e.name}</span>
                          </div>
                          <div class="flex-shrink-0 ml-2 self-center">
                            ${I_Chev(`w-5 h-5 text-gray-400 transform transition-transform duration-200 ${t?"rotate-180":""}`)}
                          </div>
                      </button>
                      <ul class="space-y-1 ${t?"":"hidden"}">
                          ${o}
                      </ul>
                  </li>
              `
        }).join("")
            }
        }
    }
    sidebarEl.innerHTML = `
        <div class="flex items-center justify-between mb-4 flex-shrink-0">
          <h1 class="text-xl font-bold text-white">Меню</h1>
          <button id="sidebar-close" class="modal-close-btn lg:hidden" title="Закрыть боковую панель">
                          ${I_X("w-4 h-4")}
          </button>
        </div>
        
        ${S.sidebarLoading ? `
        <div class="mb-4 p-3 bg-blue-900/30 border border-blue-700/50 rounded-lg">
          <div class="flex items-center gap-2 text-blue-300">
            <div class="loader !w-4 !h-4 !border-blue-400"></div>
            <span class="text-sm font-medium">Загрузка данных каталога...</span>
          </div>
        </div>
        ` : ''}

        <div class="space-y-2 mb-4 flex-shrink-0">
            <button data-view="catalog" class="${n("catalog")}" title="Переключиться на просмотр каталога деталей, наборов и минифигурок">${I_Cat("w-5 h-5 mr-3")}<span>Каталог</span></button>
            <button data-view="collection" class="${n("collection")}" title="Переключиться на просмотр вашей личной коллекции">${I_Coll("w-5 h-5 mr-3")}<span>Коллекция</span></button>
        </div>

        <div class="mb-4 p-1 bg-gray-900/50 rounded-xl grid grid-cols-3 gap-1">
            <button data-sub-view="parts" class="${r("parts")}" title="Показать детали" data-long-press="parts">
                ${I_Brick("w-5 h-5")}
                <span class="mt-1">Детали</span>
                ${s("parts",e,t)}
            </button>
            <button data-sub-view="sets" class="${r("sets")} relative" title="Показать наборы" data-long-press="sets">
                ${I_Set("w-5 h-5")}
                <span class="mt-1">Наборы</span>
                ${s("sets",o,l)}
                ${S.view === "catalog" && S.selFigNum && S.showRelatedSets ? `<div class="absolute top-1 right-1 w-5 h-5 bg-blue-200 text-blue-800 rounded-full flex items-center justify-center text-xs font-bold">${I_Minifig("w-3 h-3")}</div>` : ''}
            </button>
            <button data-sub-view="minifigs" class="${r("minifigs")}" title="Показать минифигурки" data-long-press="minifigs">
                ${I_Minifig("w-5 h-5")}
                <span class="mt-1">Фигурки</span>
                ${s("minifigs",a,i)}
            </button>
        </div>
        

        
        <div id="sidebar-scroll-container" class="flex-grow overflow-y-auto no-scrollbar">
          <h2 class="text-lg font-semibold text-white mb-3">${d}</h2>
          <nav>
            <ul id="category-list" class="space-y-1">${c}</ul>
          </nav>
        </div>
        
        <div class="flex-shrink-0 mt-4 border-t border-gray-700 pt-4 space-y-4">
            ${"collection"===S.view?`
            <div class="bg-gray-800/50 border border-gray-700 rounded-lg overflow-hidden">
                <button id="collection-summary-toggle" class="w-full flex items-center justify-between text-left p-3 group hover:bg-gray-700/30 transition-all duration-200" title="${S.collectionSummaryExpanded ? 'Свернуть сводку коллекции' : 'Развернуть сводку коллекции'}">
                    <div class="flex items-center">
                        <div class="w-8 h-8 bg-blue-600/20 rounded-lg flex items-center justify-center mr-3 group-hover:bg-blue-600/30 transition-colors">
                            <svg class="w-4 h-4 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                            </svg>
                        </div>
                        <h3 class="text-sm font-semibold text-gray-300 group-hover:text-white transition-colors">
                            Сводка коллекции
                        </h3>
                    </div>
                    <div class="flex items-center">
                        <div class="w-6 h-6 bg-gray-600/50 rounded-full flex items-center justify-center group-hover:bg-gray-600/70 transition-colors">
                            <svg class="w-3 h-3 text-gray-400 group-hover:text-gray-300 transition-colors transform ${S.collectionSummaryExpanded ? 'rotate-180' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path>
                            </svg>
                        </div>
                    </div>
                </button>
                <div id="collection-summary-content" class="${S.collectionSummaryExpanded ? 'block' : 'hidden'} p-3 pt-0 space-y-1.5 transition-all duration-200">
                                          ${0===e&&0===l&&0===i?'<div class="text-center py-4"><div class="text-gray-400 text-sm mb-2 font-medium">Ваша коллекция пуста</div><div class="text-gray-500 text-xs">Начните собирать LEGO прямо сейчас</div></div>':`
                        <div class="space-y-1.5">
                          <div class="flex items-center justify-between text-sm py-1.5 px-3 rounded-lg bg-gray-700/20 hover:bg-gray-700/40 border border-gray-600/20 hover:border-gray-600/40 transition-all duration-200">
                              <span class="text-gray-300 flex items-center">
                                  ${I_Brick("inline-block w-4 h-4 mr-2 text-blue-400")} 
                                  Детали
                              </span>
                              <div class="text-right flex items-center gap-2">
                                  <div class="text-center">
                                      <div class="text-white font-semibold text-sm">${String(t)}</div>
                                      <div class="text-gray-400 text-xs">уник.</div>
                                  </div>
                                  <div class="text-gray-500 text-sm">/</div>
                                  <div class="text-center">
                                      <div class="text-white font-semibold text-sm">${String(e)}</div>
                                      <div class="text-gray-400 text-xs">всего</div>
                                  </div>
                              </div>
                          </div>
                          <div class="flex items-center justify-between text-sm py-1.5 px-3 rounded-lg bg-gray-700/20 hover:bg-gray-700/40 border border-gray-600/20 hover:border-gray-600/40 transition-all duration-200">
                              <span class="text-gray-300 flex items-center">
                                  ${I_Set("inline-block w-4 h-4 mr-2 text-green-400")} 
                                  Наборы
                              </span>
                              <div class="text-right flex items-center gap-2">
                                  <div class="text-center">
                                      <div class="text-white font-semibold text-sm">${String(l)}</div>
                                      <div class="text-gray-400 text-xs">уник.</div>
                                  </div>
                                  <div class="text-gray-500 text-sm">/</div>
                                  <div class="text-center">
                                      <div class="text-white font-semibold text-sm">${String(o)}</div>
                                      <div class="text-gray-400 text-xs">всего</div>
                                  </div>
                              </div>
                          </div>
                          <div class="flex items-center justify-between text-sm py-1.5 px-3 rounded-lg bg-gray-700/20 hover:bg-gray-700/40 border border-gray-600/20 hover:border-gray-600/40 transition-all duration-200">
                              <span class="text-gray-300 flex items-center">
                                  ${I_Minifig("inline-block w-4 h-4 mr-2 text-purple-400")} 
                                  Минифигурки
                              </span>
                              <div class="text-right flex items-center gap-2">
                                  <div class="text-center">
                                      <div class="text-white font-semibold text-sm">${String(i)}</div>
                                      <div class="text-gray-400 text-xs">уник.</div>
                                  </div>
                                  <div class="text-gray-500 text-sm">/</div>
                                  <div class="text-center">
                                      <div class="text-white font-semibold text-sm">${String(a)}</div>
                                      <div class="text-gray-400 text-xs">всего</div>
                                  </div>
                              </div>
                          </div>
                      </div>
                    `}
                </div>
            </div>
            `:""}
            <button id="settings-button" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-600 hover:bg-gray-500 text-white shadow-lg hover:shadow-gray-500/25" title="Открыть настройки приложения, управление коллекцией и импорт/экспорт данных">
                ${I_Settings("w-5 h-5 mr-2")} Настройки
            </button>
        </div>
      `
    // Восстанавливаем позицию прокрутки после перерисовки
    const scrollEl = document.getElementById('sidebar-scroll-container');
    if (scrollEl) scrollEl.scrollTop = prevScrollTop;
    
    // Настраиваем обработчики долгого нажатия для кнопок бокового меню
    setupLongPressHandlers();
}

function renderHeader() {
    const {
        subView: e
    } = S;
    let t = "Поиск по деталям...";
    "sets" === e && (t = "Поиск по наборам..."), "minifigs" === e && (t = "Поиск по минифигуркам...");
    
    const selCount = S.multiSelect.items?.size || 0;
    const showMultiselectBar = S.multiSelect.active && !((S.view === 'collection') && !S.collectionMultiSelectEnabled);
    const selBar = showMultiselectBar ? `
        <div id="multiselect-bar" class="mt-3 bg-gray-800/80 border border-gray-700 rounded-lg p-2 flex items-center justify-between gap-2 flex-nowrap overflow-x-auto no-scrollbar" style="${S.multiSelect.justActivated ? 'animation: msSlideFadeIn .36s cubic-bezier(.22,.61,.36,1) both;' : ''}">
            <div class="flex items-center gap-3 flex-shrink-0">
                <button data-action="cancel-multiselect" class="text-gray-300 hover:text-white" title="Отменить мультивыбор">${I_X('w-5 h-5')}</button>
                <span class="text-sm text-gray-300">Выбрано: <strong>${selCount}</strong></span>
            </div>
            <div class="flex items-center gap-2 flex-nowrap flex-shrink-0">
                <button data-action="share-multiselect" class="flex items-center gap-2 bg-gray-700 hover:bg-gray-600 text-white text-sm font-semibold px-3 py-2 rounded-md transition-colors duration-150 shadow-lg hover:shadow-gray-500/25" title="Поделиться выбранными элементами через CSV файл и изображение">${I_Share('w-5 h-5')} <span class="hidden sm:inline">Поделиться</span></button>
                ${S.view==='catalog' ? `<button data-action="add-multiselect-to-collection" class="flex items-center gap-2 bg-green-600 hover:bg-green-700 text-white text-sm font-semibold px-3 py-2 rounded-md transition-colors duration-150 shadow-lg hover:shadow-green-500/25" title="Добавить выбранные элементы в коллекцию">+ В коллекцию</button>` : `<button data-action="delete-multiselect" class="flex items-center gap-2 bg-red-600 hover:bg-red-700 text-white text-sm font-semibold px-3 py-2 rounded-md transition-colors duration-150 shadow-lg hover:shadow-red-500/25" title="Удалить выбранные элементы из коллекции">${I_Trash('w-5 h-5')} <span class=\"hidden sm:inline\">Удалить</span></button>`}
            </div>
        </div>
    ` : '';
    headerEl.innerHTML = `
            <div class="flex justify-between items-center gap-4">
                <div class="flex items-center">
                    <button id="sidebar-toggle" class="sidebar-toggle-btn lg:hidden" title="Открыть/закрыть боковую панель навигации">
                        ${I_Menu("w-4 h-4")}
                    </button>
                                          <h1 class="text-xl font-bold text-white hidden sm:block main-title">
                         <span class="bg-gradient-to-r from-blue-400 via-blue-500 to-blue-600 bg-clip-text text-transparent font-extrabold tracking-tight">LEGO® Catalog</span>
                          ${S.view === "catalog" && S.subView === "sets" && S.selFigNum && S.showRelatedSets ? 
                              `<span class="text-sm font-normal text-blue-400 ml-2">• Связанные наборы</span>` : ''}
                      </h1>
                </div>
                <div class="flex items-center space-x-2 w-full max-w-sm">
                    <div class="relative flex-grow">
                        <input id="search-input" type="search" placeholder="${t}" value="${S.q}" class="w-full bg-gray-700 border border-gray-600 rounded-md pl-4 pr-12 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500" title="Поиск по деталям"/>
                        <button id="clear-search" class="absolute inset-y-0 right-0 flex items-center justify-center w-10 text-gray-400 hover:text-white ${S.q?"":"hidden"}" title="Очистить поисковый запрос">${I_X("w-5 h-5")}</button>
                    </div>
                     <button id="search-button" class="px-3 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors duration-150 shadow-lg hover:shadow-blue-500/25 flex-shrink-0" aria-label="Поиск" title="Выполнить поиск по введенному запросу">
                        ${I_Search("w-5 h-5")}
                    </button>
                    <button id="filter-button" class="px-3 bg-gray-600 text-white rounded-md hover:bg-gray-500 transition-colors duration-150 shadow-lg hover:shadow-gray-500/25 flex-shrink-0" aria-label="Фильтры" title="Открыть панель фильтров и сортировки">
                        ${I_Filter("w-5 h-5")}
                    </button>

                </div>
            </div>
            ${selBar}
        `
}
function renderSetCard(e, t, o = 0) {
    if (!e) return "";
    const l = "", // ВРЕМЕННО ОТКЛЮЧЕНО: t ? "animate-in" : "",
        a = "", // ВРЕМЕННО ОТКЛЮЧЕНО: t ? S.getAnimationDelay(o) : "",
        i = S.setColl[e.set_num] ? S.setColl[e.set_num].qty : 0;
    // Если у набора нет корректного изображения — пробуем получить его через API один раз
    if ((!e.set_img_url || !String(e.set_img_url).startsWith('http')) && e.set_num && !SET_IMAGE_FETCHING.has(e.set_num) && !SET_IMAGE_FAILED.has(e.set_num)) {
        if (API_IMAGE_FETCH_COUNT >= API_IMAGE_FETCH_LIMIT) {
            // Достигли лимита запросов на сессию — больше не пытаемся
            SET_IMAGE_FAILED.add(e.set_num);
        } else {
        SET_IMAGE_FETCHING.add(e.set_num);
        (async () => {
            try {
                API_IMAGE_FETCH_COUNT++;
                
                const resp = await fetch(`${REBRICKABLE_API_URL}/sets/${e.set_num}/`, { headers: { Authorization: `key ${getApiKey()}` }});
                if (resp.ok) {
                    const data = await resp.json();
                    if (data && data.set_img_url) {
                        e.set_img_url = data.set_img_url;
                        SET_MAP[e.set_num] = { ...SET_MAP[e.set_num], set_img_url: data.set_img_url };
                        markApiStatOnce('images', `set:${e.set_num}`);
                        markApiStatOnce('sets', e.set_num);
                        saveState();
                        S.gridStale = true; updateUI();
                    } else {
                        // Нет изображения — помечаем как неудачную попытку, чтобы не дергать API бесконечно
                        SET_IMAGE_FAILED.add(e.set_num);
                    }
                }
            } catch (err) {
                console.error('Failed to fetch set image via API:', e.set_num, err);
                SET_IMAGE_FAILED.add(e.set_num);
            } finally {
                SET_IMAGE_FETCHING.delete(e.set_num);
            }
        })();
        }
    }
    return `
            <div data-set-num="${e.set_num}" style="${a}" class="set-card ${l} relative bg-gray-800 rounded-lg overflow-hidden group cursor-pointer">
                ${i>0?`<div class="absolute top-3 left-3 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md pointer-events-none">${i}</div>`:""}
                <div class="w-full h-40 bg-gray-700 flex items-center justify-center p-2 rounded-t-lg card-image-container">
                    <div class="w-full h-full bg-white rounded-md flex items-center justify-center overflow-hidden shadow-inner relative">
                        <img ${getSetImageAttrs(e.set_num, e.set_img_url)} alt="${e.name}" class="w-full h-full object-contain pointer-events-none" loading="lazy" />
                        ${((S.view==="collection" && S.collectionMultiSelectEnabled) || (S.view==="catalog" && S.catalogMultiSelectEnabled))?`
                        <button data-action="toggle-select" data-item-type="set" data-item-id="${e.set_num}" class="absolute top-1.5 right-1.5 bg-gray-900/40 hover:bg-gray-900/60 text-white/80 hover:text-white rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md ${S.multiSelect.active && S.multiSelect.items.has(`sets:${e.set_num}`)?'opacity-100 text-white hover:text-white bg-gray-900/70':'opacity-100 md:opacity-0 md:group-hover:opacity-100'}">
                            ${S.multiSelect.active && S.multiSelect.items.has(`sets:${e.set_num}`) ? I_CheckCircle('w-4 h-4') : I_Circle('w-4 h-4')}
                        </button>
                        `:""}
                ${S.view==="collection"?`
                        <button aria-label="Удалить ${e.name}" data-action="delete-set-from-collection" data-set-num="${e.set_num}" class="absolute bottom-2 right-2 bg-red-600 text-white p-1.5 rounded-full z-10 shadow-lg hover:shadow-red-500/25 opacity-100 focus:opacity-100 md:opacity-0 md:group-hover:opacity-100 transition-all duration-150" title="Удалить набор из коллекции">
                    ${I_Trash("w-4 h-4")}
                </button>`:""}
                    </div>
                </div>
                <div class="p-4 space-y-1 card-info-container">
                    <h3 class="text-sm font-semibold text-white truncate pointer-events-none card-title">${e.name}</h3>
                    <p class="text-xs text-gray-400 pointer-events-none card-info-text">#${e.set_num} • ${e.num_parts} деталей</p>
                    <p class="text-xs text-gray-300 pointer-events-none card-info-text">Год выпуска: ${e.year}</p>
                </div>
            </div>
        `
}
function renderMinifigCard(e, t, o = 0) {
    if (!e) return `
        <div class="minifig-card relative bg-gray-800 rounded-lg overflow-hidden group p-4 flex flex-col items-center justify-center" style="min-height: 180px;">
            <div class="w-16 h-16 bg-gray-700 rounded-full mb-4"></div>
            <div class="h-4 bg-gray-700 rounded w-24 mb-2"></div>
            <div class="h-3 bg-gray-700 rounded w-16 mb-1"></div>
            <div class="h-3 bg-gray-700 rounded w-12"></div>
            <span class="text-gray-400 text-xs mt-4 card-info-text">Загрузка...</span>
        </div>
    `;
    
    // Автоматически загружаем детали минифигурки, если имя отсутствует
    if (!e.name && e.set_num) {
        fetchMinifigDetails(e.set_num).catch(console.error);
    }
    const l = "", // ВРЕМЕННО ОТКЛЮЧЕНО: t ? "animate-in" : "",
        a = "", // ВРЕМЕННО ОТКЛЮЧЕНО: t ? S.getAnimationDelay(o) : "",
        i = S.minifigColl[e.set_num] ? S.minifigColl[e.set_num].qty : 0;
    return `
            <div data-fig-num="${e.set_num}" style="${a}" class="minifig-card ${l} relative bg-gray-800 rounded-lg overflow-hidden group cursor-pointer">
                ${S.view==="collection"?"":""}
                ${i>0?`<div class="absolute top-3 left-3 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md pointer-events-none">${i}</div>`:""}
                <div class="w-full h-40 bg-gray-700 flex items-center justify-center p-2 rounded-t-lg card-image-container">
                    <div class="w-full h-full bg-white rounded-md flex items-center justify-center overflow-hidden shadow-inner relative">
                        <img ${getPartImageUrl((e.minifig_img_url && e.minifig_img_url.startsWith('http')) || (e.set_img_url && e.set_img_url.startsWith('http')) ? (e.minifig_img_url || e.set_img_url) : null)} alt="${e.name}" class="w-full h-full object-contain pointer-events-none" loading="lazy" />
                        ${((S.view==="collection" && S.collectionMultiSelectEnabled) || (S.view==="catalog" && S.catalogMultiSelectEnabled))?`
                        <button data-action="toggle-select" data-item-type="minifig" data-item-id="${e.set_num}" class="absolute top-1.5 right-1.5 bg-gray-900/40 hover:bg-gray-900/60 text-white/80 hover:text-white rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md ${S.multiSelect.active && S.multiSelect.items.has(`minifigs:${e.set_num}`)?'opacity-100 text-white hover:text-white bg-gray-900/70':'opacity-100 md:opacity-0 md:group-hover:opacity-100'}">
                            ${S.multiSelect.active && S.multiSelect.items.has(`minifigs:${e.set_num}`) ? I_CheckCircle('w-4 h-4') : I_Circle('w-4 h-4')}
                        </button>
                        `:""}
                ${S.view==="collection"?`
                        <button aria-label="Удалить ${e.name || e.set_num}" data-action="delete-minifig-from-collection" data-fig-num="${e.set_num}" class="absolute bottom-2 right-2 bg-red-600 text-white p-1.5 rounded-full z-10 shadow-lg hover:shadow-red-500/25 opacity-100 focus:opacity-100 md:opacity-0 md:group-hover:opacity-100 transition-all duration-150" title="Удалить минифигурку из коллекции">
                    ${I_Trash("w-4 h-4")}
                </button>`:""}
                    </div>
                </div>
                <div class="p-4 space-y-1 card-info-container">
                    <h3 class="text-sm font-semibold text-white truncate pointer-events-none card-title">${e.name || 'Загрузка...'}</h3>
                    <p class="text-xs text-gray-400 pointer-events-none card-info-text">#${e.set_num}</p>
                    ${!e.name ? '<p class="text-xs text-blue-400 card-info-text">Загружаем детали...</p>' : ''}
                </div>
            </div>
        `
}

function renderPartCard(e, t, o, l, a = 0) {
    if (!e) return "";
    const i = "collection" === S.view,
        n = getGroupId(e.id),
        r = "", // ВРЕМЕННО ОТКЛЮЧЕНО: l ? "animate-in" : "",
        s = ""; // ВРЕМЕННО ОТКЛЮЧЕНО: l ? S.getAnimationDelay(a) : "";
    let c = "";
    o > 0 && (c = `<div class="absolute top-3 left-3 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md pointer-events-none">${o}</div>`);
            // ИСПРАВЛЕНО: Теперь правильно использует part_img_url из inventory_parts.csv как основной источник изображения
    let d = e.part_img_url || e.rebrickable_img_url;
    
    // Debug: Log image URL selection
    console.log(`Part ${e.id} (${e.name}): part_img_url=${e.part_img_url}, rebrickable_img_url=${e.rebrickable_img_url}, selected=${d}`);
    
    // Пытаемся получить изображения конкретного цвета только если функция включена и доступна
    if (i && t && localStorage.getItem('disableColorSpecificImages') !== 'true') {
        const colorImage = PART_MAP[e.id]?.colorImages?.[t.id];
        if (colorImage && colorImage.startsWith('http')) {
            d = colorImage;
            console.log(`Using color-specific image for part ${e.id} color ${t.id}: ${colorImage}`);
        }
    }
    
    // Убеждаемся, что у нас есть действительный URL изображения - но не перезаписываем существующие
    if (!d || typeof d !== 'string' || !d.startsWith('http')) {
        // Используем запасной вариант только если изображения вообще нет
        if (!e.part_img_url && !e.rebrickable_img_url) {
            d = `https://cdn.rebrickable.com/media/parts/${e.id}.jpg`;
            console.log(`Generated fallback URL for part ${e.id}: ${d}`);
        } else {
            // Используем существующее изображение, даже если это не HTTP (может быть data: URL или относительный путь)
            d = e.part_img_url || e.rebrickable_img_url;
            console.log(`Using existing non-HTTP URL for part ${e.id}: ${d}`);
        }
    }
    

    const tHtml = t ? `
        <div class="flex items-center pt-1 pointer-events-none">
            <span class="w-4 h-4 rounded-full border border-gray-500 ${t.isTransparent?"checkerboard":""}" style="background-color: ${t.hex};"></span>
            <span class="ml-2 text-xs text-gray-300 truncate card-info-text">${t.name}</span>
        </div>
    ` : "";
    return `
            <div data-group-id="${n}" data-part-id="${e.id}" ${i && t ?`data-color-id="${t.id}"`:""} style="${s}" class="part-card ${r} relative bg-gray-800 rounded-lg overflow-hidden group cursor-pointer">
                ${i && t ?"" :""}
                ${c}
                <div class="w-full h-40 bg-gray-700 flex items-center justify-center p-2 rounded-t-lg card-image-container">
                    <div class="w-full h-full bg-white rounded-md flex items-center justify-center overflow-hidden shadow-inner relative">
                        <img ${getPartImageAttrs(e.id, d)} alt="${e.name}" class="w-full h-full object-contain pointer-events-none" loading="lazy" />
                        ${(S.view==="collection" && S.collectionMultiSelectEnabled)?`
                        <button data-action="toggle-select" data-item-type="part" data-item-id="${e.id}" data-color-id="${t?.id || ''}" class="absolute top-1.5 right-1.5 bg-gray-900/40 hover:bg-gray-900/60 text-white/80 hover:text-white rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md ${S.multiSelect.active && S.multiSelect.items.has(`parts:${e.id}:${t?.id || ''}`)?'opacity-100 text-white hover:text-white bg-gray-900/70':'opacity-100 md:opacity-0 md:group-hover:opacity-100'}">
                            ${S.multiSelect.active && S.multiSelect.items.has(`parts:${e.id}:${t?.id || ''}`) ? I_CheckCircle('w-4 h-4') : I_Circle('w-4 h-4')}
                        </button>
                        `: ''}
                ${i && t ?`
                        <button aria-label="Удалить ${e.name} (${t.name})" data-action="delete-from-collection" data-part-id="${e.id}" data-color-id="${t.id}" class="absolute bottom-2 right-2 bg-red-600 text-white p-1.5 rounded-full z-10 shadow-lg hover:shadow-red-500/25 opacity-100 focus:opacity-100 md:opacity-0 md:group-hover:opacity-100 transition-all duration-150" title="Удалить деталь из коллекции">
                        ${I_Trash("w-4 h-4")}
                    </button>
                `:""}
                    </div>
                </div>
                <div class="p-4 space-y-1 card-info-container">
                    <h3 class="text-sm font-semibold text-white truncate pointer-events-none card-title">${e.name}</h3>
                    <p class="text-xs text-gray-400 pointer-events-none card-info-text">ID: ${e.id}</p>
                    ${i? tHtml :""}
                </div>
            </div>
        `
}

function renderAppliedFilters() {
    let e = "",
        t = !1,
        o = !1;
    if ("sets" === S.subView) {
        const {
            minYear: l,
            maxYear: a,
            minParts: i,
            maxParts: n
        } = S.setFilters, r = [(l && l.trim() !== '') && `Мин. год: ${l}`, (a && a.trim() !== '') && `Макс. год: ${a}`, (i && i.trim() !== '') && `Мин. деталей: ${i}`, (n && n.trim() !== '') && `Макс. деталей: ${n}`].filter(Boolean).map(e => `
                <div class="flex items-center bg-green-900/50 text-green-200 rounded-full pl-3 pr-2 py-1 text-sm">
                    <span class="mr-2">${e}</span>
                </div>`).join(""), s = {
            year_desc: "Год (новые)",
            year_asc: "Год (старые)",
            parts_desc: "Детали (убыв.)",
            parts_asc: "Детали (возр.)",
            alpha_asc: "Алфавит (А-Я)",
            alpha_desc: "Алфавит (Я-А)"
        },
        c = {
            [Symbol.iterator]: function*() {
                yield* Object.entries(this).map(([k, v]) => [k, v])
            }
        };
        Object.assign(c, s);
        t = S.q ? "relevance" === S.sortBy : "year_desc" === S.sortBy;
        const d = t || !s[S.sortBy] ? "" : `
                <div class="flex items-center bg-gray-600 text-gray-200 rounded-full pl-3 pr-2 py-1 text-sm">
                    <span class="mr-2">Сортировка: ${s[S.sortBy]}</span>
                </div>
            `;
        e = [d, r].filter(Boolean).join(""), o = (!t) || ((l && l.trim() !== '') || (a && a.trim() !== '') || (i && i.trim() !== '') || (n && n.trim() !== ''))
    } else if ("minifigs" === S.subView) {
        const l = {
            name_asc: "Алфавит (А-Я)",
            name_desc: "Алфавит (Я-А)",
            num_parts_desc: "Кол-во деталей (убыв.)",
            num_parts_asc: "Кол-во деталей (возр.)"
        },
        a = {
            [Symbol.iterator]: function*() {
                yield* Object.entries(this).map(([k, v]) => [k, v])
            }
        };
        Object.assign(a, l);
        t = S.q ? "relevance" === S.sortBy : "name_asc" === S.sortBy;
        const i = t || !l[S.sortBy] ? "" : `
                <div class="flex items-center bg-gray-600 text-gray-200 rounded-full pl-3 pr-2 py-1 text-sm">
                    <span class="mr-2">Сортировка: ${l[S.sortBy]}</span>
                </div>
            `;
        e = i, o = !t
    } else {
        const {
            colorIds: l,
            inCollectionOnly: a
        } = S.filters, i = l.map(e => {
            if (!COLOR_MAP[e]) return "";
            return `
                <div class="flex items-center bg-blue-900/50 text-blue-200 rounded-full pl-3 pr-2 py-1 text-sm">
                    <span class="mr-2">${COLOR_MAP[e].name}</span>
                    <button data-action="remove-filter" data-filter-type="color" data-color-id="${e}" class="text-blue-200 hover:bg-blue-500/50 rounded-full p-0.5">${I_X("w-4 h-4")}</button>
                </div>
                `
        }).join(""), n = a && "catalog" === S.view ? `
                <div class="flex items-center bg-green-900/50 text-green-200 rounded-full pl-3 pr-2 py-1 text-sm">
                    <span class="mr-2">В коллекции</span>
                    <button data-action="remove-filter" data-filter-type="inCollectionOnly" class="text-green-200 hover:bg-green-500/50 rounded-full p-0.5">${I_X("w-4 h-4")}</button>
                </div>
            ` : "", r = {
            relevance: "Релевантность",
            alpha_asc: "Алфавит (А-Я)",
            alpha_desc: "Алфавит (Я-А)",
            popularity: "Популярность",
            quantity_desc: "Кол-во в коллекции (убыв.)",
            quantity_asc: "Кол-во в коллекции (возр.)"
        },
        s = {
            [Symbol.iterator]: function*() {
                yield* Object.entries(this).map(([k, v]) => [k, v])
            }
        };
        Object.assign(s, r);
        t = S.q ? "relevance" === S.sortBy : "popularity" === S.sortBy;
        const c = t ? "" : `
                <div class="flex items-center bg-gray-600 text-gray-200 rounded-full pl-3 pr-2 py-1 text-sm">
                    <span class="mr-2">Сортировка: ${r[S.sortBy]}</span>
                    <button data-action="remove-filter" data-filter-type="sortBy" class="text-gray-200 hover:bg-gray-500/50 rounded-full p-0.5">${I_X("w-4 h-4")}</button>
                </div>
            `;
        e = [c, i, n].filter(Boolean).join(""), o = (!t && S.sortBy !== "popularity" && !S.selFigNum) || (l.length > 0 && !S.selFigNum) || (a && "catalog" === S.view && a === true && !S.selFigNum)
    }
    // Дополнительная проверка: не показывать кнопку "Очистить все" при показе связанных наборов
    // Также проверяем, что есть хотя бы один активный фильтр для отображения
    const hasActiveFilters = e.trim() !== "";
    const shouldShowClearButton = o && hasActiveFilters && !(S.subView === "sets" && S.selFigNum && S.showRelatedSets && !S.q);
    
    return shouldShowClearButton ? `
            <div class="px-4 pt-2 pb-0">
                <div class="flex items-center flex-wrap gap-2">
                    ${e}
                    <button data-action="remove-all-filters" class="text-sm text-blue-400 hover:underline">Очистить все</button>
                </div>
            </div>
        ` : ""
}

// Группировка для коллекции: в папку только детали, у которых > 1 цвета
function groupCollectionPartsForDisplay(items) {
    try {
        const partIdToGroup = new Map();
        (items || []).forEach(entry => {
            const pid = entry?.part?.id;
            if (!pid) return;
            if (!partIdToGroup.has(pid)) {
                partIdToGroup.set(pid, { part: entry.part, colors: [], totalQty: 0 });
            }
            const g = partIdToGroup.get(pid);
            g.colors.push({ color: entry.color, quantity: entry.quantity });
            g.totalQty += entry.quantity || 0;
        });
        const display = [];
        for (const g of partIdToGroup.values()) {
            const uniqueColors = new Map();
            g.colors.forEach(ci => {
                const key = String(ci?.color?.id);
                if (!uniqueColors.has(key)) uniqueColors.set(key, ci);
            });
            const colorList = Array.from(uniqueColors.values());
            if (colorList.length > 3 && S.foldersEnabled) {
                console.log(`Creating folder for part ${g.part?.id} with ${colorList.length} colors, total qty: ${g.totalQty}`);
                display.push({ type: 'folder', part: g.part, colors: colorList, totalQty: g.totalQty });
            } else {
                // Для 1-3 цветов или если папки отключены - показываем отдельные карточки по каждому цвету
                for (const ci of colorList) {
                    display.push({ type: 'single', entry: { part: g.part, color: ci?.color || null, quantity: ci?.quantity || 0 } });
                }
            }
        }
        // Сортировка по текущему режиму
        const getName = it => it.type === 'folder' ? (it.part?.name || '') : (it.entry?.part?.name || '');
        const getQty = it => it.type === 'folder' ? (it.totalQty || 0) : (it.entry?.quantity || 0);
        const getPopularity = it => it.type === 'folder' ? (PART_MAP[it.part?.id]?.num_sets || 0) : (PART_MAP[it.entry?.part?.id]?.num_sets || 0);
        switch (S.sortBy) {
            case 'alpha_desc':
                display.sort((a,b)=> (getName(b)).localeCompare(getName(a), 'en'));
                break;
            case 'quantity_desc':
                display.sort((a,b)=> getQty(b) - getQty(a) || getName(a).localeCompare(getName(b),'en'));
                break;
            case 'quantity_asc':
                display.sort((a,b)=> getQty(a) - getQty(b) || getName(a).localeCompare(getName(b),'en'));
                break;
            case 'popularity':
                display.sort((a,b)=> getPopularity(b) - getPopularity(a));
                break;
            case 'popular': // на всякий случай поддержим альтернативное имя
                display.sort((a,b)=> getPopularity(b) - getPopularity(a));
                break;
            default:
                display.sort((a,b)=> getName(a).localeCompare(getName(b),'en'));
        }
        return display;
    } catch (e) {
        console.warn('groupCollectionPartsForDisplay failed:', e);
        return [];
    }
}

// Визуализация папки (тайл размера карточки) с 4 миниатюрами первых цветов
function renderCollectionFolderCard(part, colors) {
    try {
        console.log(`Rendering folder card for part ${part?.id}:`, { part, colors, coll: S.coll?.[part?.id] });
        const groupId = getGroupId(part.id);
        const thumbs = (colors || []).slice(0,4);
        const thumbImgs = thumbs.map(ci => {
            const colorId = String(ci?.color?.id || '');
            const fallback = part.rebrickable_img_url || part.part_img_url || '';
            return `<div class="w-full h-full flex items-center justify-center bg-white rounded-lg overflow-hidden shadow-md border border-gray-200 hover:shadow-lg hover:scale-105 transition-all duration-200 cursor-pointer"><img ${getColorImageUrl(part.id, colorId, fallback)} alt="${part.name}" class="w-full h-full object-contain" loading="lazy" /></div>`;
        });
        while (thumbImgs.length < 4) {
            thumbImgs.push(`<div class="w-full h-full bg-gray-100 rounded-lg border border-gray-200 flex items-center justify-center opacity-60"><div class="w-6 h-6 bg-gray-300 rounded-full"></div></div>`);
        }
        const colorsCount = (colors || []).length;
        const inCollectionQty = Object.values(S.coll?.[part.id] || {}).reduce((a,b)=>a+b,0);
        const isExpanded = !!(S.expandedFolders && S.expandedFolders.has(String(part.id)));
        const ringClasses = isExpanded ? ' ring-2 ring-blue-500 ' : '';
        const expandedClasses = isExpanded ? ' shadow-lg shadow-blue-500/50 bg-gradient-to-br from-gray-800 to-gray-700 ' : '';
        return `
            <div data-group-id="${groupId}" data-part-id="${part.id}" data-folder="true" class="part-card${ringClasses}${expandedClasses} relative bg-gray-800 rounded-lg overflow-hidden group cursor-pointer transition-all duration-300">
                ${inCollectionQty>0?`<div class="absolute top-3 left-3 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md pointer-events-none">${inCollectionQty}</div>`:""}
                <div class="w-full h-40 bg-gradient-to-br from-gray-600 to-gray-700 flex items-center justify-center p-2 rounded-t-lg card-image-container">
                    <div class="w-full h-full relative grid grid-cols-2 grid-rows-2 gap-2">
                        ${thumbImgs.join('')}
                        ${(S.view==="collection" && S.collectionMultiSelectEnabled)?`
                        <button data-action="toggle-select" data-item-type="part-folder" data-item-id="${part.id}" class="absolute top-1.5 right-1.5 bg-gray-900/40 hover:bg-gray-900/60 text-white/80 hover:text-white rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md ${S.multiSelect.active && S.multiSelect.items.has(`parts-folder:${part.id}`)?'opacity-100 text-white hover:text-white bg-gray-900/70':'opacity-100 md:opacity-0 md:group-hover:opacity-100'}">
                            ${S.multiSelect.active && S.multiSelect.items.has(`parts-folder:${part.id}`) ? I_CheckCircle('w-4 h-4') : I_Circle('w-4 h-4')}
                        </button>
                        `:""}
                                          
                        ${S.view==="collection"?`
                        <button aria-label="Удалить все цвета ${part.name}" data-action="delete-folder-from-collection" data-part-id="${part.id}" class="absolute bottom-2 right-2 bg-red-600 text-white p-1.5 rounded-full z-10 shadow-md opacity-100 focus:opacity-100 md:opacity-0 md:group-hover:opacity-100" title="Удалить все ${getColorWord(colorsCount)} детали из коллекции">${I_Trash('w-4 h-4')}</button>
                        `:""}
                    </div>
                </div>
                <div class="p-4 space-y-1 card-info-container">
                    <h3 class="text-sm font-semibold text-white truncate pointer-events-none card-title">${part.name}</h3>
                    <p class="text-xs text-gray-400 pointer-events-none card-info-text">ID: ${part.id}</p>
                    <p class="text-xs text-gray-300 pointer-events-none card-info-text">${getColorWord(colorsCount)}: ${colorsCount}</p>
                </div>
            </div>
        `;
    } catch (e) {
        console.warn('renderCollectionFolderCard failed:', e);
        return '';
    }
}

function renderMainContent() {
    // Проверяем глобальный флаг блокировки
    if (window.UI_BLOCKED) {
        console.log('🚫 renderMainContent blocked by global flag');
        return;
    }
    
    let e = "";
    
    console.log('🎨 renderMainContent called:', {
        view: S.view,
        subView: S.subView,
        loading: S.loading,
        error: S.err,
        toDisplay: S.toDisplay,
        hasMoreItems: S.hasMoreItems,
        stack: new Error().stack?.split('\n').slice(1, 4).join('\n')
    });
    
    if (S.loading) e = '<div class="flex flex-col items-center justify-center h-full p-8 text-center"><div class="loader"></div><p class="mt-4 text-gray-400">Загрузка...</p></div>';
    else if (S.err) e = `<div class="flex flex-col items-center justify-center h-full p-8 text-center text-red-400"><p class="font-semibold">Произошла ошибка</p><p class="text-sm mt-2">${S.err}</p></div>`;
    else if ("catalog" === S.view) {
        let t, o, l, a = "sets-minifigs-grid";
        if ("parts" === S.subView) {
            let i = {};
            l = "Выберите категорию, чтобы увидеть детали, или воспользуйтесь поиском";
            
            // Инициализируем данные для деталей, если они не загружены
            if (!S.catGroups && !S.searchGroups && Object.keys(PART_MAP).length > 0) {
                console.log('🔧 Initializing parts data for parts subview');
                
                // Если есть поисковый запрос, ищем по нему
                if (S.q && S.q.trim()) {
                    console.log('🔍 Searching parts for query:', S.q);
                    const searchResults = Object.values(PART_MAP).filter(part => 
                        part.name && part.name.toLowerCase().includes(S.q.toLowerCase()) ||
                        part.part_num && part.part_num.toLowerCase().includes(S.q.toLowerCase())
                    );
                    S.searchGroups = { 'search': searchResults };
                    console.log('🔍 Search results for parts:', searchResults.length);
                } else {
                    // Загружаем ВСЕ доступные детали (не только первые 100)
                    const allParts = Object.values(PART_MAP);
                    S.catGroups = { 'default': allParts };
                    console.log('🔧 All parts loaded:', allParts.length);
                }
            }
            
            // Автоматически сортируем все детали по популярности (частота использования в наборах) после инициализации
            if (S.catGroups && Object.keys(S.catGroups).length > 0) {
                console.log('📊 Sorting parts by popularity (most used first)');
                Object.keys(S.catGroups).forEach(key => {
                    if (Array.isArray(S.catGroups[key])) {
                        S.catGroups[key].sort((a, b) => {
                            const popularityA = parseInt(a.num_sets) || 0;
                            const popularityB = parseInt(b.num_sets) || 0;
                            return popularityB - popularityA; // Популярные первыми
                        });
                    }
                });
                console.log('✅ Parts sorted by popularity, most used first');
            }
            
            if (S.searchGroups && Object.keys(S.searchGroups).length > 0) {
                console.log('📊 Sorting search results by popularity (most used first)');
                Object.keys(S.searchGroups).forEach(key => {
                    if (Array.isArray(S.searchGroups[key])) {
                        S.searchGroups[key].sort((a, b) => {
                            const popularityA = parseInt(a.num_sets) || 0;
                            const popularityB = parseInt(b.num_sets) || 0;
                            return popularityB - popularityA; // Популярные первыми
                        });
                    }
                });
                console.log('✅ Search results sorted by popularity, most used first');
            }
            
            if (S.filters.colorIds?.length > 1) {
                l = 'Фильтрация по нескольким цветам в режиме "Каталог" не поддерживается. Пожалуйста, выберите один цвет или просмотрите свою "Коллекцию".';
            } else if (S.searchGroups !== null) {
                i = S.searchGroups;
                l = "По вашему запросу ничего не найдено.";
            } else if (S.selCatId !== null) {
                i = S.catGroups;
                l = "В этой категории нет деталей.";
            } else {
                // Если нет ни поиска, ни выбранной категории, используем все детали
                if (S.catGroups && Object.keys(S.catGroups).length > 0) {
                    i = S.catGroups;
                    l = "Все детали";
                    console.log('🔧 Using all parts data:', Object.keys(S.catGroups));
                }
            }
            
            // Дополнительная проверка: если есть поисковый запрос, но searchGroups не инициализирован
            if (S.q && S.q.trim() && (!S.searchGroups || Object.keys(S.searchGroups).length === 0)) {
                console.log('🔍 Re-initializing search results for parts query:', S.q);
                const searchResults = Object.values(PART_MAP).filter(part => 
                    part.name && part.name.toLowerCase().includes(S.q.toLowerCase()) ||
                    part.part_num && part.part_num.toLowerCase().includes(S.q.toLowerCase())
                );
                S.searchGroups = { 'search': searchResults };
                i = S.searchGroups;
                l = searchResults.length > 0 ? `Результаты поиска для "${S.q}" (${searchResults.length})` : "По вашему запросу ничего не найдено.";
                console.log('🔍 Search results re-initialized:', searchResults.length);
            }
            
            // Дополнительная проверка: если есть выбранная категория, но catGroups не инициализирован
            if (S.selCatId && (!S.catGroups || Object.keys(S.catGroups).length === 0)) {
                console.log('🔧 Re-initializing category data for category ID:', S.selCatId);
                // Здесь можно добавить логику загрузки деталей по категории
                // Пока что используем все детали
                const allParts = Object.values(PART_MAP);
                S.catGroups = { 'category': allParts };
                i = S.catGroups;
                l = `Детали в категории (${allParts.length})`;
                console.log('🔧 Category data re-initialized:', allParts.length);
            }
            
            let n = Object.values(i).flat();
            console.log('📊 Parts processing:', {
                iKeys: Object.keys(i),
                nLength: n.length,
                filters: S.filters
            });
            
            // Дополнительная проверка: если i пустой, используем все детали
            if (n.length === 0 && S.catGroups && Object.keys(S.catGroups).length > 0) {
                console.log('⚠️ No parts found, falling back to all parts');
                i = S.catGroups;
                n = Object.values(i).flat();
                l = "Все детали";
                console.log('📊 Parts after fallback:', {
                    iKeys: Object.keys(i),
                    nLength: n.length
                });
            }
            
            // Фильтры для каталога «Все детали»
            if (S.filters) {
                // Только элементы, присутствующие в коллекции
                if (S.filters.inCollectionOnly) {
                    n = n.filter(p => S.coll[p.id] && Object.keys(S.coll[p.id]).length > 0);
                }
                // Фильтр по цвету (поддерживается только один цвет в каталоге)
                if (S.filters.colorIds && S.filters.colorIds.length === 1) {
                    const colorSet = getPartsWithColorSet(S.filters.colorIds[0]);
                    if (colorSet.size > 0) {
                        n = n.filter(p => colorSet.has(String(p.id)));
                    } else {
                        n = [];
                    }
                } else if (S.filters.colorIds && S.filters.colorIds.length > 1) {
                    n = [];
                }
            }
            
            console.log('📊 Parts after filtering:', {
                nLength: n.length,
                filtersApplied: !!S.filters
            });
            
            // Удаляем дубликаты и группируем вариации
            i = groupParts(n);
            const r = i ? Object.keys(i) : [];
            t = r.map(gid => pickBestPartVariantForCard(i[gid])).filter(Boolean);
            
            console.log('📊 Parts final result:', {
                iKeys: Object.keys(i),
                rLength: r.length,
                tLength: t?.length || 0
            });
            // Применяем сортировку к карточкам после выбора лучшей вариации
            if (S.sortBy) {
                switch (S.sortBy) {
                    case "alpha_asc":
                        t.sort((a, b) => (a.name || '').localeCompare(b.name || '', 'en'));
                        break;
                    case "alpha_desc":
                        t.sort((a, b) => (b.name || '').localeCompare(a.name || '', 'en'));
                        break;
                    case "popularity":
                        t.sort((a, b) => (b.num_sets || 0) - (a.num_sets || 0));
                        break;
                }
            }
            o = e => {
                const t = Object.values(S.coll[e.id] || {}).reduce((e, t) => e + t, 0);
                return renderPartCard(e, null, t, S.gridStale);
            }, a = "parts-grid";
        } else if ("sets" === S.subView) {
            console.log('Sets subview, selFigNum:', S.selFigNum, 'q:', S.q, 'view:', S.view);
            
            // Инициализируем данные для наборов, если они не загружены
            if (!S.setRes && !S.searchSetRes && Object.keys(SET_MAP).length > 0) {
                console.log('🔧 Initializing sets data for sets subview');
                // Загружаем все наборы или наборы по умолчанию
                if (S.q && S.q.trim()) {
                    // Если есть поисковый запрос, ищем по нему
                    const searchResults = Object.values(SET_MAP).filter(set => 
                        set.name && set.name.toLowerCase().includes(S.q.toLowerCase()) ||
                        set.set_num && set.set_num.toLowerCase().includes(S.q.toLowerCase())
                    );
                    S.searchSetRes = searchResults;
                    console.log('🔍 Search results for sets:', searchResults.length);
                } else {
                    // Если нет запроса, загружаем ВСЕ доступные наборы (не только первые 100)
                    const allSets = Object.values(SET_MAP);
                    S.setRes = allSets;
                    console.log('📦 All sets loaded:', allSets.length);
                }
            }
            
            // Автоматически сортируем все наборы по году (новые первыми) после инициализации
            if (S.setRes && Array.isArray(S.setRes)) {
                console.log('📅 Sorting sets by year (newest first)');
                S.setRes.sort((a, b) => {
                    const yearA = parseInt(a.year) || 0;
                    const yearB = parseInt(b.year) || 0;
                    return yearB - yearA; // Новые первыми
                });
                console.log('✅ Sets sorted by year, newest first');
            }
            
            if (S.searchSetRes && Array.isArray(S.searchSetRes)) {
                console.log('📅 Sorting search results by year (newest first)');
                S.searchSetRes.sort((a, b) => {
                    const yearA = parseInt(a.year) || 0;
                    const yearB = parseInt(b.year) || 0;
                    return yearB - yearA; // Новые первыми
                });
                console.log('✅ Search results sorted by year, newest first');
            }
            
            // Проверяем, есть ли выбранная минифигурка для показа связанных наборов
            if (S.selFigNum && S.showRelatedSets && !S.q) {
                // Показываем связанные наборы для выбранной минифигурки только при явном запросе
                const relatedSets = getRelatedSetsForMinifig(S.selFigNum);
                console.log('Related sets for minifig:', S.selFigNum, ':', relatedSets);
                if (relatedSets && relatedSets.length > 0) {
                    // Сортируем связанные наборы по году (новые первыми)
                    console.log('📅 Sorting related sets by year (newest first)');
                    relatedSets.sort((a, b) => {
                        const yearA = parseInt(a.year) || 0;
                        const yearB = parseInt(b.year) || 0;
                        return yearB - yearA; // Новые первыми
                    });
                    console.log('✅ Related sets sorted by year, newest first');
                    
                    t = relatedSets;
                    o = e => renderSetCard(e, S.gridStale);
                    l = `Связанные наборы для минифигурки "${MINIFIG_MAP[S.selFigNum]?.name || S.selFigNum}" (${relatedSets.length})`;
                    console.log('Setting t to relatedSets:', t);
                } else {
                    t = S.q ? S.searchSetRes : S.setRes;
                    o = e => renderSetCard(e, S.gridStale);
                    l = S.q ? "По вашему запросу ничего не найдено." : "Выберите тему для просмотра наборов, или воспользуйтесь поиском";
                    console.log('No related sets found, using default sets');
                }
            } else {
                // Обычное отображение наборов
                t = S.q ? S.searchSetRes : S.setRes;
                o = e => renderSetCard(e, S.gridStale);
                l = S.q ? "По вашему запросу ничего не найдено." : "Выберите тему для просмотра наборов, или воспользуйтесь поиском";
                console.log('Using default sets display');
            }
            console.log('Final t value for sets:', t);
        } else {
            // Инициализируем данные для минифигурок, если они не загружены
            if (!S.minifigRes && !S.searchMinifigRes && Object.keys(MINIFIG_MAP).length > 0) {
                console.log('🔧 Initializing minifigs data for minifigs subview');
                // Загружаем все минифигурки или минифигурки по умолчанию
                if (S.q && S.q.trim()) {
                    // Если есть поисковый запрос, ищем по нему
                    const searchResults = Object.values(MINIFIG_MAP).filter(minifig => 
                        minifig.name && minifig.name.toLowerCase().includes(S.q.toLowerCase()) ||
                        minifig.set_num && minifig.set_num.toLowerCase().includes(S.q.toLowerCase())
                    );
                    S.searchMinifigRes = searchResults;
                    console.log('🔍 Search results for minifigs:', searchResults.length);
                } else {
                    // Если нет запроса, загружаем ВСЕ доступные минифигурки (не только первые 100)
                    const allMinifigs = Object.values(MINIFIG_MAP);
                    S.minifigRes = allMinifigs;
                    console.log('👤 All minifigs loaded:', allMinifigs.length);
                }
            }
            
            // Автоматически сортируем все минифигурки по году (новые первыми) после инициализации
            if (S.minifigRes && Array.isArray(S.minifigRes)) {
                console.log('📅 Sorting minifigs by year (newest first)');
                S.minifigRes.sort((a, b) => {
                    const yearA = parseInt(a.year) || 0;
                    const yearB = parseInt(b.year) || 0;
                    return yearB - yearA; // Новые первыми
                });
                console.log('✅ Minifigs sorted by year, newest first');
            }
            
            if (S.searchMinifigRes && Array.isArray(S.searchMinifigRes)) {
                console.log('📅 Sorting minifig search results by year (newest first)');
                S.searchMinifigRes.sort((a, b) => {
                    const yearA = parseInt(a.year) || 0;
                    const yearB = parseInt(b.year) || 0;
                    return yearB - yearA; // Новые первыми
                });
                console.log('✅ Minifig search results sorted by year, newest first');
            }
            
            t = S.q ? S.searchMinifigRes : S.minifigRes;
            o = e => renderMinifigCard(e, S.gridStale);
            l = S.q ? "По вашему запросу ничего не найдено." : "catalog" === S.view && !S.q ? "Используйте поиск для нахождения минифигурок." : "В коллекции нет минифигурок.";
        }
        if (!t || 0 === t.length) e = `
                    <div class="flex flex-col items-center justify-center h-full p-4 text-center">
                        ${S.sidebarLoading ? `
                            <div class="flex items-center text-blue-400 text-sm mb-6">
                                <div class="loader !w-6 !h-6 !border-2 mr-3"></div>
                                <span>Загрузка данных...</span>
                            </div>
                        ` : ''}
                        <p class="text-gray-400 max-w-sm mb-6">${l}</p>
                                <button id="feeling-lucky-button" class="relative z-10 pointer-events-auto flex items-center gap-3 bg-gradient-to-r from-blue-600 to-purple-600 text-white font-bold py-3 px-6 rounded-lg hover:from-blue-700 hover:to-purple-700 transition-all duration-300 transform hover:scale-105 hover:shadow-xl shadow-lg group" title="Случайная деталь/набор из каталога">
            <span id="feeling-lucky-icon" class="group-hover:rotate-12 transition-transform duration-300">${I_Dice("w-6 h-6")}</span>
            <span id="feeling-lucky-text">Мне повезёт!</span>
        </button>
        <div class="text-center text-sm text-gray-500 mt-2">
            <span id="feeling-lucky-stats">Загружаем статистику...</span>
        </div>
        <div class="text-center text-xs text-blue-400 mt-6 px-8">
            <div class="tip-container">
                <span id="feeling-lucky-tip" class="tip-text">💡 Загружаем подсказку...</span>
            </div>
        </div>
                    </div>`;
        else {
            // Используем S.toDisplay для ограничения количества отображаемых карточек/групп
            // Добавляем заголовок для связанных наборов, если они отображаются
            const headerHtml = (S.subView === "sets" && S.selFigNum && S.showRelatedSets && !S.q) ? `
                <div class="px-4 pt-4 pb-2">
                    <div class="flex items-center justify-between bg-gray-800/50 rounded-lg p-3 border border-gray-700">
                        <div class="flex items-center gap-3">
                            <span class="text-blue-400">${I_Minifig("w-5 h-5")}</span>
                            <div>
                                <h2 class="text-lg font-semibold text-white">Связанные наборы</h2>
                                <p class="text-sm text-gray-400">Для минифигурки "${MINIFIG_MAP[S.selFigNum]?.name || S.selFigNum}"</p>
                            </div>
                        </div>
                        
                        <!-- Превью-картинка минифигурки -->
                        <div class="flex items-center gap-3">
                            <div class="w-16 h-16 bg-white rounded-lg flex items-center justify-center overflow-hidden shadow-md cursor-pointer hover:shadow-lg transition-shadow relative group" 
                                 data-action="open-minifig-preview" 
                                 data-fig-num="${S.selFigNum}"
                                 title="Открыть детали минифигурки">
                                <img src="${MINIFIG_MAP[S.selFigNum]?.minifig_img_url || MINIFIG_MAP[S.selFigNum]?.set_img_url || `https://cdn.rebrickable.com/media/minifigs/${S.selFigNum}.jpg`}" 
                                     alt="${MINIFIG_MAP[S.selFigNum]?.name || S.selFigNum}" 
                                     class="w-full h-full object-contain"
                                     onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1zbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjY0IiBoZWlnaHQ9IjY0IiBmaWxsPSIjMzc0MTUxIi8+CjxwYXRoIGQ9Ik0zMiAxNkMyMy4xNjM0IDE2IDE2IDIzLjE2MzQgMTYgMzJDMTYgNDAuODM2NiAyMy4xNjM0IDQ4IDMyIDQ4QzQwLjgzNjYgNDggNDggNDAuODM2NiA0OCAzMkM0OCAyMy4xNjM0IDQwLjgzNjYgMTYgMzIgMTZaIiBmaWxsPSIjNkI3MjgwIi8+CjxwYXRoIGQ9Ik0yNCAyOEgyNEMyMi44OTU1IDI4IDIyIDI4Ljg5NTQgMjIgMzBWMzRIMjZWMzBDMjYgMjguODk1NCAyNS4xMDQ2IDI4IDI0IDI4WiIgZmlsbD0iIzZCNzI4MCIvPgo8cGF0aCBkPSJNMzIgMjhIMzJDMzAuODk1NCAyOCAzMCAyOC44OTU0IDMwIDMwVjM0SDM0VjMwQzM0IDI4Ljg5NTQgMzMuMTA0NiAyOCAzMiAyOFoiIGZpbGw9IiM2QjcyODAiLz4KPHBhdGggZD0iTTI0IDM2SDQwQzQxLjEwNDYgMzYgNDIgMzYuODk1NCA0MiAzOFY0MEg0MlY0MkM0MiA0My4xMDQ2IDQxLjEwNDYgNDQgNDAgNDRIMjRDMjIuODk1NCA0NCAyMiA0My4xMDQ2IDIyIDQyVjQwSDIyVjM4QzIyIDM2Ljg5NTQgMjIuODk1NCAzNiAyNCAzNloiIGZpbGw9IiM2QjcyODAiLz4KPC9zdmc+'">
                                
                                <!-- Иконка лупы при наведении -->
                                <div class="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-30 transition-all duration-200 flex items-center justify-center opacity-0 group-hover:opacity-100">
                                    <svg class="w-6 h-6 text-white drop-shadow-lg" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                                    </svg>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            ` : '';

            // Каталог (sets/minifigs) рендерим как раньше, а для деталей в коллекции включаем группировку по имени
            if (S.view === 'catalog' || S.subView !== 'parts') {
                // Старое поведение сетки
                // Рассчитываем лимит отображаемых элементов
                console.log('📊 Setting hasMoreItems for catalog view:', {
                    tLength: t?.length || 0,
                    toDisplay: S.toDisplay,
                    t: t,
                    subView: S.subView
                });
                
                // Защита от null/undefined значений
                if (!t || !Array.isArray(t)) {
                    console.log('⚠️ t is not a valid array, setting hasMoreItems to false');
                    S.hasMoreItems = false;
                    S.totalItems = 0;
                    S.loadedItems = 0;
                } else {
                    S.hasMoreItems = t.length > S.toDisplay;
                    S.totalItems = t.length;
                    const shown = t.slice(0, S.toDisplay);
                    S.loadedItems = shown.length;
                }
                
                console.log('📊 Catalog view stats:', {
                    hasMoreItems: S.hasMoreItems,
                    totalItems: S.totalItems,
                    loadedItems: S.loadedItems,
                    toDisplay: S.toDisplay,
                    subView: S.subView
                });
                
                if (S.hasMoreItems) {
                    console.log('✅ Will show more items button or auto-load');
                } else {
                    console.log('❌ No more items to load');
                }
                
                const shown = t ? t.slice(0, S.toDisplay) : [];
                e = `${headerHtml}<div class="grid ${a} gap-4 p-4">${shown.map((e,t)=>{const l=o(e,true,t);return l.replace('class=\"part-card ',`style=\"${S.getAnimationDelay(t)}\" class=\"part-card `).replace('class=\"set-card ',`style=\"${S.getAnimationDelay(t)}\" class=\"set-card `).replace('class=\"minifig-card ',`style=\"${S.getAnimationDelay(t)}\" class=\"minifig-card `)}).join("")}</div>`;
            } else {
                // Новое поведение: группировка карточек деталей по одинаковому названию
                const groups = groupCollectionPartsByName(t);
                S.hasMoreItems = groups.length > S.toDisplay;
                S.totalItems = groups.length;
                const shownGroups = groups.slice(0, S.toDisplay);
                S.loadedItems = shownGroups.length;
                const groupsHtml = shownGroups.map((g, idx) => renderCollectionNameGroup(g, idx)).join("");
                e = `${headerHtml}<div class="space-y-3 p-4">${groupsHtml}</div>`;
            }

            // Кнопка "Показать еще" убрана — используется авто-догрузка при прокрутке
        }
    } else {
        let t, o, l = `В вашей коллекции нет ${"parts"===S.subView?"деталей":"sets"===S.subView?"наборов":"минифигурок"}`,
            i = S.q.trim().toLowerCase(),
            n = "grid-cols-[repeat(auto-fill,minmax(150px,1fr))]";
        if ("parts" === S.subView) {
            const e = [];
            for (const t in S.coll)
                for (const o in S.coll[t]) {
                    const l = PART_MAP[t],
                        a = COLOR_MAP[o],
                        i = S.coll[t][o];
                    if (l && a && i > 0) {
                        e.push({
                            part: l,
                            color: a,
                            quantity: i
                        });
                        
                        // Загружаем отсутствующие детали для элементов коллекции
                        if (!l.name || !l.part_img_url) {
                            fetchMissingCollectionPartDetails().catch(console.error);
                        }
                    }
                }
            let filteredParts = e;
            S.selCollCatId && (filteredParts = e.filter(({
                part: e
            }) => PART_MAP[e.id]?.categoryId === S.selCollCatId));
            S.filters.colorIds?.length > 0 && (filteredParts = e.filter(e => S.filters.colorIds.includes(e.color.id)));
            i && (filteredParts = e.filter(({
                part: e
            }) => e.name.toLowerCase().includes(i) || e.id.toLowerCase().includes(i)));
            t = filteredParts;
            switch (S.sortBy) {
                case "alpha_asc":
                    t.sort((e, t) => e.part.name.localeCompare(t.part.name, 'en'));
                    break;
                case "alpha_desc":
                    t.sort((e, t) => t.part.name.localeCompare(e.part.name, 'en'));
                    break;
                case "quantity_desc":
                    t.sort((a, b) => b.quantity - a.quantity);
                    break;
                case "quantity_asc":
                    t.sort((a, b) => a.quantity - b.quantity);
                    break;
                case "popularity":
                    t.sort((e, t) => (PART_MAP[t.part.id]?.num_sets || 0) - (PART_MAP[e.part.id]?.num_sets || 0))
                    break;
                case "popular":
                    t.sort((e, t) => (PART_MAP[t.part.id]?.num_sets || 0) - (PART_MAP[e.part.id]?.num_sets || 0))
            }
            o = (e, t, o) => renderPartCard(e.part, e.color, e.quantity, t, o);
            n = "parts-grid";
        } else if ("sets" === S.subView) {
            let sets = Object.keys(S.setColl).map(e => SET_MAP[e]).filter(Boolean);
            
            // Загружаем отсутствующие детали набора для элементов коллекции
            sets.forEach(set => {
                if (!set.name || !set.set_img_url) {
                    fetchMissingCollectionSetDetails().catch(console.error);
                }
            });
            
            if (S.selCollThemeId) {
                const getAllChildThemeIds = (themeId) => {
                    const theme = THEME_MAP[themeId];
                    if (!theme) return [];
                    let ids = [theme.id];
                    if (Array.isArray(theme.children)) {
                        theme.children.forEach(child => {
                            ids = ids.concat(getAllChildThemeIds(child.id));
                        });
                    }
                    return ids;
                };
                const allowedThemeIds = getAllChildThemeIds(S.selCollThemeId);
                sets = sets.filter(set => set && allowedThemeIds.includes(set.theme_id));
            }
            i && (sets = sets.filter(e => e.name.toLowerCase().includes(i) || e.set_num.toLowerCase().includes(i)));

            // Применяем фильтры по годам и количеству деталей для наборов в коллекции
            if (S.setFilters) {
                const { minYear, maxYear, minParts, maxParts } = S.setFilters;
                if (minYear && minYear.trim() !== '') {
                    const v = parseInt(minYear);
                    if (!isNaN(v)) sets = sets.filter(s => s.year && s.year >= v);
                }
                if (maxYear && maxYear.trim() !== '') {
                    const v = parseInt(maxYear);
                    if (!isNaN(v)) sets = sets.filter(s => s.year && s.year <= v);
                }
                if (minParts && minParts.trim() !== '') {
                    const v = parseInt(minParts);
                    if (!isNaN(v)) sets = sets.filter(s => s.num_parts && s.num_parts >= v);
                }
                if (maxParts && maxParts.trim() !== '') {
                    const v = parseInt(maxParts);
                    if (!isNaN(v)) sets = sets.filter(s => s.num_parts && s.num_parts <= v);
                }
            }
            t = sets;
            switch (S.sortBy) {
                case "alpha_asc":
                    t.sort((e, t) => e.name.localeCompare(t.name, 'en'));
                    break;
                case "alpha_desc":
                    t.sort((e, t) => t.name.localeCompare(e.name, 'en'));
                    break;
                case "year_asc":
                    t.sort((e, t) => e.year - t.year);
                    break;
                case "year_desc":
                    t.sort((e, t) => t.year - e.year);
                    break;
                case "parts_asc":
                    t.sort((e, t) => e.num_parts - t.num_parts);
                    break;
                case "parts_desc":
                    t.sort((e, t) => t.num_parts - e.num_parts)
            }
            o = (e, t, o) => renderSetCard(e, t, o);
            n = "sets-minifigs-grid";
        } else {
            let minifigs = Object.keys(S.minifigColl).map(e => MINIFIG_MAP[e]).filter(Boolean);
            i && (minifigs = minifigs.filter(e => e.name.toLowerCase().includes(i) || e.set_num.toLowerCase().includes(i)));
            t = minifigs;
            
            // Загружаем отсутствующие детали минифигурки для элементов коллекции
            minifigs.forEach(minifig => {
                if (!minifig.name || !minifig.minifig_img_url) {
                    fetchMinifigDetails(minifig.set_num).catch(console.error);
                }
            });
            
            switch (S.sortBy) {
                case "name_asc":
                    t.sort((e, t) => e.name.localeCompare(t.name, 'en'));
                    break;
                case "name_desc":
                    t.sort((e, t) => t.name.localeCompare(e.name, 'en'));
                    break;
                case "num_parts_desc":
                    t.sort((e, t) => t.num_parts - e.num_parts);
                    break;
                case "num_parts_asc":
                    t.sort((e, t) => e.num_parts - e.num_parts)
            }
            o = (e, t, o) => renderMinifigCard(e, t, o);
            n = "sets-minifigs-grid";
        }
        if (t.length === 0) {
            (i || "parts"===S.subView && (S.filters.colorIds.length > 0 || S.selCollCatId) || "sets" === S.subView && S.selCollThemeId) && (l += ", соответствующих фильтрам");
            e = `<div class="flex flex-col items-center justify-center h-full p-4 text-center">
                    ${S.sidebarLoading ? `
                        <div class="flex items-center text-blue-400 text-sm mb-6">
                            <div class="loader !w-6 !h-6 !border-2 mr-3"></div>
                            <span>Загрузка данных...</span>
                        </div>
                    ` : ''}
                    <p class="text-gray-400">${l}</p>
                </div>`;
        } else {
            // Для коллекции деталей включаем группировку по названию
            if (S.subView === 'parts') {
                // Преобразуем список в смесь одиночных карточек и папок по условию (>1 цвета)
                const display = groupCollectionPartsForDisplay(t);
                S.hasMoreItems = display.length > S.toDisplay;
                S.totalItems = display.length;
                const shown = display.slice(0, S.toDisplay);
                S.loadedItems = shown.length;
                if (!S.expandedFolders) S.expandedFolders = new Set();
                const html = shown.map((d, idx) => {
                    if (d.type === 'folder') {
                        const base = renderCollectionFolderCard(d.part, d.colors)
                            .replace('class="part-card ', `style="${S.getAnimationDelay(idx)}" class="part-card `);
                        // Если папка раскрыта — отрисуем общий контейнер с синей рамкой вокруг папки и карточек цветов
                        if (S.expandedFolders.has(String(d.part.id))) {
                            const baseNoRing = base.replace(' ring-2 ring-blue-500 ', ' ');
                            const colorCardsWrapped = d.colors.map(ci => {
                                const entry = { part: d.part, color: ci.color, quantity: (S.coll?.[d.part.id]?.[String(ci.color?.id)] || 0) };
                                const html = o(entry, true, idx + 1);
                                return html;
                            }).join("");
                            return `
                                <div class="part-folder-group-container" style="grid-column: 1 / -1;">
                                    <div class="border-2 border-blue-500 rounded-xl p-6 shadow-2xl shadow-blue-500/30 bg-blue-50/10 backdrop-blur-sm relative">
                                        <!-- Кнопка закрытия папки в правом верхнем углу контейнера -->
                                        <button data-action="close-folder" data-part-id="${d.part.id}" class="absolute top-2 right-2 bg-red-600 hover:bg-red-700 text-white rounded-full w-6 h-6 flex items-center justify-center z-20 shadow-lg hover:shadow-red-500/25 transition-all duration-200 hover:scale-110" title="Закрыть папку">
                                            ${I_X('w-4 h-4')}
                                        </button>
                                        
                                        <div class="folder-grid">
                                            <div class="transform scale-105 transition-transform duration-200">${baseNoRing}</div>
                                            ${colorCardsWrapped}
                                        </div>
                                    </div>
                                </div>
                            `;
                        }
                        return base;
                    }
                    // одиночные карточки: сразу обычная карточка (открывает модалку детали)
                    return o(d.entry, true, idx);
                }).join("");
                e = `<div class="${n} p-4">${html}</div>`;
            } else {
                // Сетки для наборов и минифигурок без изменений
                S.hasMoreItems = t.length > S.toDisplay;
                S.totalItems = t.length;
                const shown = t.slice(0, S.toDisplay);
                S.loadedItems = shown.length;
                e = `<div class="${n} p-4">${shown.map((e,t)=>o(e,true,t)).join("")}</div>`;
            }
            // Кнопка "Показать еще" убрана — используется авто-догрузка при прокрутке
        }
    }
    mainEl.innerHTML = renderAppliedFilters() + e;
    // После рендера контента обновляем индикатор прогресса, т.к. размеры могли измениться
    if (typeof window.refreshScrollProgress === 'function') {
        try { window.refreshScrollProgress(); } catch {}
    }
    // И обновляем границы трека, если высота шапки изменилась
    (function(){
        const track = document.getElementById('scroll-progress');
        const header = document.getElementById('header-container');
        if (track) {
            const headerHeight = header?.offsetHeight || 0;
            const top = Math.max(12, headerHeight + 8);
            track.style.top = top + 'px';
            track.style.bottom = '12px';
        }
    })();
            S.gridStale = !1;
        
        // Дополнительная оптимизация: отключаем анимации после завершения рендеринга
        if (document.body.classList.contains('tab-switching')) {
            setTimeout(() => {
                document.body.classList.remove('tab-switching');
            }, 200);
        }

    // Автоматически загружать больше контента, если нет полосы прокрутки
    requestAnimationFrame(() => {
        if (!S.loading && S.hasMoreItems && mainEl.scrollHeight <= mainEl.clientHeight) {
            S.toDisplay += S.increment;
            renderMainContent();
        }
        // Обновляем прогресс после автоподгрузки/проверки
        if (typeof window.refreshScrollProgress === 'function') {
            try { window.refreshScrollProgress(); } catch {}
        }
    });
    
    // Убрана автоматическая загрузка изображений для предотвращения постоянных обновлений UI
    
    // Обновляем статистику кнопки "Мне повезёт" после рендеринга
    setTimeout(() => updateFeelingLuckyStats(), 100);
}
// Добавляем слушатель события прокрутки для автоматической загрузки дополнительных элементов
function setupScrollListener() {
    console.log('🔧 setupScrollListener called, mainEl:', mainEl);
    
    if (mainEl.hasAttribute('data-scroll-listener')) {
        console.log('⚠️ Scroll listener already set up, skipping');
        return; // Уже настроено
    }
    
    mainEl.setAttribute('data-scroll-listener', 'true');
    console.log('✅ Scroll listener attribute set');
    
    let scrollTimeout;
    
    mainEl.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        
        scrollTimeout = setTimeout(() => {
            const scrollTop = mainEl.scrollTop;
            const scrollHeight = mainEl.scrollHeight;
            const clientHeight = mainEl.clientHeight;
            
            // Проверяем, достигли ли мы конца страницы
            const isAtBottom = scrollTop + clientHeight >= scrollHeight - 100; // 100px от конца
            
            if (isAtBottom && !S.loading && S.hasMoreItems) {
                console.log('📜 Auto-loading more items on scroll...', {
                    current: S.toDisplay,
                    increment: S.increment,
                    hasMore: S.hasMoreItems,
                    scrollTop,
                    scrollHeight,
                    clientHeight
                });
                
                // Проверяем, не превышаем ли мы общее количество элементов
                if (S.totalItems && S.toDisplay >= S.totalItems) {
                    console.log('⚠️ Already showing all items, skipping auto-load');
                    S.hasMoreItems = false;
                    return;
                }
                
                // Защита от бесконечного увеличения
                if (S.toDisplay > 10000) {
                    console.log('⚠️ toDisplay too high, stopping auto-load');
                    S.hasMoreItems = false;
                    return;
                }
                
                S.toDisplay += S.increment;
                S.gridStale = true;
                console.log('🔄 Calling updateUI from scroll listener, new toDisplay:', S.toDisplay);
                updateUI();
            }
        }, 100); // Задержка 100ms для оптимизации
    }, { passive: true });
    
    console.log('✅ Scroll listener added successfully');
}

function renderSetCollectionControls() {
    if (!S.selSetNum) return "";
    const {
        qty: e
    } = S.setModal, t = S.setColl[S.selSetNum]?.qty || 0;
    return `
            <div class="bg-gray-700/50 rounded-lg p-4">
                <div class="space-y-4">
                    <div class="flex justify-between items-center">
                        <h3 class="text-white font-semibold">Коллекция наборов</h3>
                        <p class="text-sm text-gray-400 text-right">В коллекции: <span id="set-modal-in-collection-qty" class="font-bold text-white">${t}</span></p>
                    </div>
                    
                    <div class="flex justify-between items-center gap-4">
                        <div class="flex items-center gap-2">
                            <button data-action="decrease-set-qty" class="p-2 rounded-full ${e > 0 ? 'bg-gray-600 hover:bg-gray-500 shadow-lg hover:shadow-gray-500/25' : 'bg-gray-700 cursor-not-allowed'} text-white transition-colors duration-150" ${e <= 0 ? 'disabled' : ''}" title="Уменьшить количество">${I_Minus("w-5 h-5")}</button>
                            <input id="set-modal-quantity-input" type="number" value="${e}" readonly class="w-12 text-center bg-gray-900 text-white font-bold rounded-md py-1"/>
                            <button data-action="increase-set-qty" class="p-2 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors duration-150 shadow-lg hover:shadow-gray-500/25" title="Увеличить количество">${I_Plus("w-5 h-5")}</button>
                        </div>
                        <button data-action="update-set-collection" class="flex-grow bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors duration-150 shadow-lg hover:shadow-blue-500/25">
                            ${t>0?"Обновить":"Добавить"}
                        </button>
                    </div>
                    ${t>0?`
                        <div class="flex justify-center">
                            <button data-action="delete-from-set-collection-modal" class="mt-1 text-sm bg-red-600 hover:bg-red-700 text-white rounded-md py-1.5 px-3 transition-colors duration-150 shadow-lg hover:shadow-red-500/25">Удалить из коллекции</button>
                        </div>
                    `:"<div></div>"}
                </div>
            </div>
        `
}

function renderSetBulkPartsControls() {
    return S.selSetNum ? S.setModal.bulkUpdate ? `
                <div class="bg-gray-700/50 rounded-lg p-4 mt-4">
                     <h3 class="text-md font-semibold text-gray-300 mb-2">Коллекция деталей</h3>
                     <div class="flex items-center justify-center gap-3 text-white h-10">
                        <div class="loader !w-5 !h-5 !border-2"></div>
                        <span>Обновление...</span>
                     </div>
                </div>
            ` : `
            <div class="bg-gray-700/50 rounded-lg p-4 mt-4">
                <h3 class="text-md font-semibold text-gray-300 mb-2">Коллекция деталей</h3>
                <div class="grid grid-cols-2 gap-2">
                    <button data-action="bulk-add-parts" class="flex items-center justify-center px-2 sm:px-3 py-2 text-xs sm:text-sm font-semibold rounded-md transition-colors duration-150 bg-green-600 hover:bg-green-700 text-white shadow-lg hover:shadow-green-500/25 whitespace-nowrap" title="Добавить все детали из набора в коллекцию деталей">
                        ${I_Plus("w-4 h-4 sm:w-5 sm:h-5 mr-1 sm:mr-2")} Добавить все
                    </button>
                    <button data-action="bulk-remove-parts" class="flex items-center justify-center px-2 sm:px-3 py-2 text-xs sm:text-sm font-semibold rounded-md transition-colors duration-150 bg-red-600 hover:bg-red-700 text-white shadow-lg hover:shadow-red-500/25 whitespace-nowrap" title="Удалить все детали из набора из коллекции деталей">
                        ${I_Minus("w-4 h-4 sm:w-5 sm:h-5 mr-1 sm:mr-2")} Удалить все
                    </button>
                </div>
            </div>
        ` : ""
}

function renderSetModalToggleButton() {
    const e = SET_MAP[S.selSetNum];
    return e ? "details" === S.setModal.view ? `<button data-action="toggle-set-modal-view" class="flex items-center gap-2 px-3 py-1.5 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-600 hover:bg-gray-500 text-white shadow-lg hover:shadow-gray-500/25">
                ${I_Brick("w-5 h-5")}
                <span>Инвентарь</span>
                <span class="text-xs bg-gray-700 text-gray-200 px-1.5 py-0.5 rounded-full">${e.num_parts}</span>
            </button>` : `<button data-action="toggle-set-modal-view" class="flex items-center gap-2 px-3 py-1.5 text-sm font-semibold rounded-md transition-colors duration-150 bg-blue-600 hover:bg-blue-700 text-white shadow-lg hover:shadow-blue-500/25">
                ${I_Cat("w-5 h-5")}
                <span>Детали набора</span>
            </button>` : ""
}

function renderSetModalDetailsView() {
    const e = SET_MAP[S.selSetNum];
    const t = THEME_MAP[e.theme_id];
    return `
        <div class="flex flex-col lg:flex-row">
            <div class="lg:w-1/2 p-4 sm:p-6 bg-gray-900/30 flex items-center justify-center flex-shrink-0 border-b lg:border-b-0 lg:border-r border-gray-700">
                 <div data-action="view-image-fullscreen" data-image-url="${e.set_img_url||""}" class="w-48 h-48 sm:w-64 sm-h-64 bg-white rounded-lg flex items-center justify-center overflow-hidden shadow-lg relative cursor-pointer group">
                    <img ${getSetImageAttrs(e.set_num, e.set_img_url)} alt="${e.name}" class="max-w-full max-h-full object-contain">
                    <div class="absolute inset-0 bg-black/40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                        ${I_Search("w-10 h-10 text-white")}
                    </div>
                 </div>
            </div>
            
            <div class="lg:w-1/2 p-4 sm:p-6 flex flex-col">
                <div class="space-y-6">
                    <div>
                        <h3 class="text-md font-semibold text-gray-300 mb-3">Детали</h3>
                        <div class="space-y-1 text-sm text-gray-400">
                            <p><span class="font-semibold text-gray-300">Название:</span> ${e.name}</p>
                            <p>ID: ${e.set_num}</p>
                            <p>Год: ${e.year}</p>
                            <p>Кол-во деталей: ${e.num_parts}</p>
                            ${t?`<div class="flex items-center">
                                <span class="mr-1">Тема:</span>
                                <button data-action="go-to-theme" data-theme-id="${t.id}" class="text-blue-400 hover:text-blue-300 hover:underline text-left truncate">
                                    ${t.name}
                                </button>
                            </div>`:""}
                        </div>
                    </div>

                    <div id="set-modal-controls-container">
                        ${renderSetCollectionControls()}
                        ${renderSetBulkPartsControls()}
                    </div>
                    
                     ${S.setModal.status?`
                        <div class="mt-4 p-2 text-sm rounded-md ${"error"===S.setModal.statusType?"bg-red-900/50 text-red-300":"bg-green-900/50 text-green-300"}">
                            ${S.setModal.status}
                        </div>
                     `:""}
                </div>
            </div>
        </div>
        `
}

function renderSetModalInventoryView() {
    return `<div id="set-inventory-container" class="p-4 flex flex-col">
            ${renderSetInventory()}
        </div>`
}

function updateSetModalView() {
    if (!S.selSetNum) return;
    const e = document.getElementById("set-modal-view-container");
    if (!e) return;
    if ("details" === S.setModal.view) {
        e.innerHTML = renderSetModalDetailsView();
    } else {
        e.innerHTML = renderSetModalInventoryView();
    }
    
    // НЕ проверяем и не восстанавливаем z-index - ModalManager сам управляет этим
    // if (setModalEl) {
    //     console.log('Set modal z-index after view update:', setModalEl.style.zIndex);
    //     // Принудительно восстанавливаем z-index если он сбросился
    //     if (setModalEl.style.zIndex !== '95') {
    //         setModalEl.style.zIndex = '95';
    //         console.log('Set modal z-index restored to 95');
    //     }
    // }
    // Трек прокрутки фиксирован относительно контента модалки и создаётся при рендере модалки
    // После рендера вида обновляем границы и прогресс индикатора в модалке
    (function(){
        const track = document.getElementById('set-scroll-progress');
        const content = document.getElementById('set-modal-content');
        if (track && content) {
            const header = content.querySelector('.border-b');
            const headerH = header?.offsetHeight || 0;
            const top = Math.max(12, headerH + 8);
            track.style.top = top + 'px';
            track.style.bottom = '12px';
        }
        const scrollArea = document.getElementById('set-modal-view-container');
        const bar = track?.querySelector('.bar');
        const update = () => {
            if (!track || !bar || !scrollArea) return;
            const max = scrollArea.scrollHeight - scrollArea.clientHeight;
            const percent = max <= 0 ? 100 : Math.min(100, Math.max(0, (scrollArea.scrollTop / max) * 100));
            const containerH = track.clientHeight || 0;
            const barH = bar.clientHeight || 24;
            const maxOffset = Math.max(0, containerH - barH);
            const translatePx = (percent / 100) * maxOffset;
            bar.style.transform = `translateY(${translatePx}px)`;
        };
        update();
        let to;
        const onScroll = () => {
            track?.classList.add('visible');
            update();
            clearTimeout(to);
            to = setTimeout(() => track?.classList.remove('visible'), 200);
        };
        scrollArea?.addEventListener('scroll', onScroll, { passive: true });
        const obs = new MutationObserver(update);
        scrollArea && obs.observe(scrollArea, { childList: true, subtree: true });
        window.addEventListener('resize', () => { update(); }, { passive: true });
    })();
}

// Прогресс прокрутки в модалке минифигурки
;(function(){
    const setupMinifigScrollProgress = () => {
        const track = document.getElementById('minifig-scroll-progress');
        const content = document.getElementById('minifig-modal-content');
        if (track && content) {
            const header = content.querySelector('.border-b');
            const headerH = header?.offsetHeight || 0;
            const top = Math.max(12, headerH + 8);
            track.style.top = top + 'px';
            track.style.bottom = '12px';
        }
        const scrollArea = document.getElementById('minifig-modal-view-container');
        const bar = track?.querySelector('.bar');
        const update = () => {
            if (!track || !bar || !scrollArea) return;
            const max = scrollArea.scrollHeight - scrollArea.clientHeight;
            const percent = max <= 0 ? 100 : Math.min(100, Math.max(0, (scrollArea.scrollTop / max) * 100));
            const containerH = track.clientHeight || 0;
            const barH = bar.clientHeight || 24;
            const maxOffset = Math.max(0, containerH - barH);
            const translatePx = (percent / 100) * maxOffset;
            bar.style.transform = `translateY(${translatePx}px)`;
        };
        update();
        let to;
        const onScroll = () => {
            track?.classList.add('visible');
            update();
            clearTimeout(to);
            to = setTimeout(() => track?.classList.remove('visible'), 200);
        };
        scrollArea?.addEventListener('scroll', onScroll, { passive: true });
        const obs = new MutationObserver(update);
        scrollArea && obs.observe(scrollArea, { childList: true, subtree: true });
        window.addEventListener('resize', () => { update(); }, { passive: true });
    };
    // Инициализация после каждого рендера модалки минифигурки
    const _updateMinifigModalView = updateMinifigModalView;
    updateMinifigModalView = function() {
        _updateMinifigModalView();
        setupMinifigScrollProgress();
    };
})();

function renderSetModal(e = !1) {
    if (!S.selSetNum) return void closeSetModal();
    const t = SET_MAP[S.selSetNum];
    if (!t) return void closeSetModal();
    const o = e ? "modal-content-enter" : "",
        l = "inventory" === S.setModal.view;
            e && (document.body.classList.add("overflow-hidden"), setModalEl.classList.remove("modal-hidden"), requestAnimationFrame(() => setModalEl.classList.add("visible"))), setModalEl.innerHTML = `
        <div id="set-modal-content" class="bg-gray-800 rounded-lg shadow-xl w-[calc(100%-2rem)] ${l?"max-w-6xl":"max-w-4xl"} flex flex-col ${l?"h-[calc(100vh-4rem)]":"max-h-[calc(100vh-2rem)]"} ${o} transition-all duration-300 relative">
            <div class="flex-shrink-0 p-4 border-b border-gray-700 flex justify-between items-center gap-4">
                 <h2 class="text-xl lg:text-2xl font-bold text-white truncate pr-4">${t.name}</h2>
                 <div class="flex items-center gap-2 flex-shrink-0">
                    ${renderSetModalToggleButton()}
                    <button data-action="share-set" class="text-gray-300 hover:text-white transition-colors" title="Поделиться набором через изображение и CSV файл">${I_Share("w-6 h-6")}</button>
                    <button id="set-modal-close" class="modal-close-btn" title="Закрыть модальное окно набора">${I_X("w-4 h-4")}</button>
                 </div>
            </div>
            <div id="set-scroll-progress"><div class="bar"></div></div>
            <div id="set-modal-view-container" class="flex-grow overflow-y-auto no-scrollbar" style="min-height: 0;"></div>
        </div>
        `, updateSetModalView();
        
        // НЕ устанавливаем z-index принудительно - ModalManager сам управляет этим
        // if (setModalEl) {
        //     setModalEl.style.zIndex = '95';
        //     console.log('Set modal z-index forced to 95 after render');
        // }
}
function renderSetInventory() {
    const {
        inv: e,
        loading: t,
        hasNextInv: o,
        minifigs: l,
        loadingMinifigs: a
    } = S.setModal;
    let i = "";
    a ? i = '<div class="flex items-center justify-center p-4"><div class="loader !w-6 !h-6"></div></div>' : l?.length > 0 && (i = l.map(e => {
        const t = e.set_num,
            o = S.minifigColl[t]?.qty || 0,
            l = e.name || "Загрузка...";
        const n = e.isLoadingParts ? '<div class="flex items-center justify-center p-2"><div class="loader !w-5 !h-5"></div></div>' : e.loadingError ? `
                        <div class="text-center p-2">
                            <p class="text-xs text-red-400 mb-2">Не удалось загрузить детали.</p>
                            <button data-action="retry-load-minifig-parts" data-fig-num="${t}" class="text-xs px-2 py-1 rounded-md bg-blue-600 hover:bg-blue-700 text-white transition-colors duration-150 shadow-lg hover:shadow-blue-500/25">
                                Попробовать снова
                            </button>
                        </div>
                    ` : (e.parts || []).map((e) => `
                                <div class="flex items-center p-1.5 rounded-md gap-2 text-xs cursor-pointer hover:bg-gray-700/50"
                                     data-action="open-part-from-inventory"
                                     data-part-id="${e.part.part_num}"
                                     data-color-id="${e.color.id}"
                                     data-quantity="${e.quantity}">
                                    <div class="w-8 h-8 bg-white rounded flex items-center justify-center flex-shrink-0">
                                        <img ${getPartImageUrl(e.part.part_img_url)} alt="${e.part.name}" class="w-full h-full object-contain p-0.5">
                                    </div>
                                    <div class="flex-grow truncate">
                                        <p class="text-gray-200 truncate">${e.part.name}</p>
                                        <p class="text-gray-400 truncate">${e.part.part_num}</p>
                                    </div>
                                    <div class="flex items-center gap-2 flex-shrink-0">
                                        <span class="w-4 h-4 rounded-full border border-gray-500 ${e.color.isTransparent?"checkerboard":""}" style="background-color: ${e.color.hex};" title="${e.color.name}"></span>
                                        <span class="text-gray-300 w-6 text-right">${e.quantity}x</span>
                                    </div>
                                </div>
                            `).join("") || (e.parts && 0 === e.parts.length ? '<p class="text-xs text-gray-400 text-center p-2">Детали не найдены.</p>' : "");
        return `
                    <div class="bg-gray-700/50 rounded-lg overflow-hidden">
                        <div class="flex items-center p-2 gap-3 text-sm cursor-pointer hover:bg-gray-700/50"
                             data-action="open-minifig-from-inventory" data-fig-num="${t}">
                            <div class="w-12 h-12 bg-white rounded-md flex items-center justify-center flex-shrink-0">
                                <img ${getPartImageUrl(e.minifig_img_url || e.set_img_url)} alt="${l}" class="w-full h-full object-contain p-1">
                            </div>
                            <div class="flex-grow truncate">
                                <p class="text-white font-semibold truncate">${l}</p>
                                <p class="text-gray-400 truncate">${t}</p>
                            </div>
                            <div class="flex items-center gap-2 flex-shrink-0">
                                <span class="text-gray-300 w-8 text-right font-semibold">${e.quantity}x</span>
                                <button data-action="add-minifig-to-collection" data-fig-num="${t}" data-quantity="${e.quantity}" class="z-10 relative p-2 rounded-full text-white transition-colors duration-150 ${o>0?"bg-green-600 shadow-lg hover:shadow-green-500/25":"bg-blue-600 hover:bg-blue-700 shadow-lg hover:shadow-blue-500/25"}" title="${o>0?`В коллекции: ${o}`:`Добавить ${e.quantity} в коллекцию минифигурок`}">
                                    ${I_Minifig("w-5 h-5")}
                                </button>
                                <button data-action="toggle-minifig-parts" data-fig-num="${t}" class="z-10 relative p-2 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors duration-150 shadow-lg hover:shadow-gray-500/25" title="Показать/скрыть детали">
                                    ${I_Chev(`w-5 h-5 transform transition-transform duration-200 ${e.isExpanded?"rotate-180":""}`)}
                                </button>
                            </div>
                        </div>
                        <div id="minifig-parts-${t.replace(/[^a-zA-Z0-9]/g,"-")}" class="${e.isExpanded?"bg-gray-900/40 p-2 max-h-60 overflow-y-auto no-scrollbar":"hidden"}">
                             ${e.isExpanded?`
                                <div class="flex justify-end items-center mb-2 px-1.5">
                                    <button data-action="add-minifig-parts-to-collection" data-fig-num="${t}" class="flex items-center gap-2 text-xs px-2 py-1 rounded-md bg-blue-600 hover:bg-blue-700 text-white transition-colors duration-150 shadow-lg hover:shadow-blue-500/25 disabled:opacity-50" title="Добавить все детали этой минифигурки в вашу коллекцию деталей" ${S.setModal.bulkUpdate?"disabled":""}>
                                        ${I_Plus("w-4 h-4")}
                                        <span>Добавить детали</span>
                                    </button>
                                </div>
                            `:""}
                            ${n}
                        </div>
                    </div>
                `
    }).join(""));
    const r = e.map(e => `
            <div class="flex items-center bg-gray-700/50 p-2 rounded-md gap-3 text-sm cursor-pointer hover:bg-gray-700/70"
                 data-action="open-part-from-inventory"
                 data-part-id="${e.part.part_num}"
                 data-color-id="${e.color.id}"
                 data-quantity="${e.quantity}">
                <div class="w-12 h-12 bg-white rounded-md flex items-center justify-center flex-shrink-0">
                        <img ${getPartImageUrl(e.part.part_img_url)} alt="${e.part.name}" class="w-full h-full object-contain p-1">
                </div>
                <div class="flex-grow truncate">
                    <p class="text-white font-semibold truncate">${e.part.name}</p>
                    <p class="text-gray-400 truncate">${e.part.part_num}</p>
                </div>
                <div class="flex items-center gap-2 flex-shrink-0">
                    <span class="w-5 h-5 rounded-full border border-gray-500 ${e.color.isTransparent?"checkerboard":""}" style="background-color: ${e.color.hex};" title="${e.color.name}"></span>
                    <span class="text-gray-300 w-8 text-right">${e.quantity}x</span>
                </div>
            </div>
        `).join("");
    let s = "";
    return t ? s = '<div class="flex justify-center p-4 flex-shrink-0"><div class="loader !w-8 !h-8"></div></div>' : s = "", `
            <div class="space-y-6">
                ${i?`
                    <div>
                        <h3 class="text-lg font-semibold text-white mb-3 flex items-center gap-2">
                            ${I_Minifig("w-5 h-5")} Минифигурки
                        </h3>
                        <div class="space-y-2">${i}</div>
                    </div>`:""}
                <div>
                    <h3 class="text-lg font-semibold text-white mb-3 flex items-center gap-2">
                        ${I_Brick("w-5 h-5")} Детали
                    </h3>
                    ${e.length>0||t?`
                        <div class="space-y-2">${r}</div>
                        ${s}
                    `:'<div class="text-sm text-gray-400 p-2">Инвентарь (кроме минифигурок) не найден.</div>'}
                </div>
            </div>
        `
}

function updateSetModalControlsState() {
    if (!S.selSetNum) return;
    const e = document.getElementById("set-modal-controls-container");
    e && (e.innerHTML = renderSetCollectionControls() + renderSetBulkPartsControls())
}
function renderModal() {
    if (!S.selPartId) return void(partModalEl.classList.contains("modal-hidden") || closeModal());
    const e = PART_MAP[S.selPartId];
    if (!e) return void closeModal();
    const t = flatCategories.find(t => t.id === e.categoryId)?.name, {
        variants: o,
        imgUrl: l
    } = S.partModal;
    let a = "";
    o?.length > 1 && (a = `
                <div>
                    <label for="variation-select" class="block text-sm font-medium text-gray-400 mb-2">Вариация</label>
                    <div class="relative variation-select-container">
                        <button id="variation-select-button" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500 cursor-pointer pr-10 text-left flex justify-between items-center hover:bg-gray-600 transition-colors duration-200">
                            <span id="variation-select-text" class="truncate flex-1">${o.find(e => e.id === S.selPartId)?.name || (o[0]?.name || '')}</span>
                            <svg class="w-4 h-4 text-gray-400 transition-transform duration-200 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </button>
                        <div id="variation-dropdown" class="absolute bg-gray-700 border border-gray-600 rounded-md shadow-lg z-[99999] max-h-60 overflow-y-auto" style="display: none; background-color: #374151; border: 1px solid #4B5563; border-radius: 6px; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); min-width: 200px;">
                            ${(() => { const seen = new Set(); return o.filter(v=>{const id=v?.id; if(!id||seen.has(id)) return false; seen.add(id); return true;}).map(e=>`
                                <div data-value="${e.id}" class="variation-option px-3 py-2 text-white hover:bg-gray-600 cursor-pointer transition-colors duration-150 ${e.id===S.selPartId?'selected':''}">
                                    <span class="truncate block">${e.name}</span>
                                </div>
                            `).join("") })()}
                        </div>
                    </div>
                </div>
            `), document.body.classList.add("overflow-hidden"), partModalEl.classList.remove("modal-hidden"), partModalEl.style.zIndex = '60', requestAnimationFrame(() => {
        partModalEl.classList.add("visible")
    }), partModalEl.innerHTML = `
        <div id="modal-content" class="bg-gray-800 rounded-lg shadow-xl w-[calc(100%-2rem)] max-w-lg lg:max-w-4xl flex flex-col max-h-[calc(100vh-2rem)] modal-content-enter">
            
            <div class="flex-shrink-0 p-4 border-b border-gray-700 flex justify-between items-center">
                 <h2 class="text-xl lg:text-2xl font-bold text-white truncate pr-8">${e.name}</h2>
                 <div class="flex items-center gap-2">
                    <button data-action="share-part" class="text-gray-300 hover:text-white transition-colors duration-150" title="Поделиться деталью через изображение и CSV файл">${I_Share("w-6 h-6")}</button>
                    <button id="modal-close" class="modal-close-btn" title="Закрыть модальное окно">${I_X("w-4 h-4")}</button>
                 </div>
            </div>
            
            <div id="modal-scroll-area" class="flex-grow flex flex-col lg:flex-row overflow-y-auto no-scrollbar">
                <div class="lg:w-1/2 p-4 sm:p-6 bg-gray-900/30 flex items-center justify-center flex-shrink-0 border-b lg:border-b-0 lg:border-r border-gray-700">
                     <div id="modal-image-container" data-action="view-image-fullscreen" data-image-url="${l||""}" class="w-48 h-48 sm:w-64 sm:h-64 bg-white rounded-lg flex items-center justify-center overflow-hidden shadow-lg relative cursor-pointer group">
                        <img ${getPartImageUrl(l)} alt="${e.name}" class="max-w-full max-h-full object-contain">
                        <div class="absolute inset-0 bg-black/40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                           ${I_Search("w-10 h-10 text-white")}
                        </div>
                     </div>
                </div>
                
                <div class="lg:w-1/2 p-4 sm:p-6 flex flex-col">
                    <div>
                        <div class="modal-section-spacing">
                            <h3 class="text-md font-semibold text-gray-300 modal-section-title">Деталь</h3>
                            <div class="space-y-1 text-sm text-gray-400">
                                <p><span class="font-semibold text-gray-300">Название:</span> ${e.name}</p>
                                <p>ID: ${e.id}</p>
                                ${t?`
                                    <div class="flex items-center">
                                        <span class="mr-1">Категория:</span>
                                        <button data-action="go-to-category" data-category-id="${e.categoryId}" class="text-blue-400 hover:text-blue-300 hover:underline text-left truncate">
                                            ${t}
                                        </button>
                                    </div>
                                `:""}
                            </div>
                            ${a?`<div class="mt-4">${a}</div>`:""}
                        </div>
                        
                        <div class="modal-section-spacing">
                          <h3 class="text-md font-semibold text-gray-300 modal-section-title">Цвета</h3>
                           <div id="color-selector-container" class="min-h-[120px] sm:min-h-[120px] lg:min-h-[160px]">${renderColorSelector()}</div>
                        </div>
                        
                        <div id="modal-controls-container" class="modal-section-spacing">${renderModalControls()}</div>
                    </div>
                </div>
            </div>
        </div>
        `, updateModalPartially({
        image: !0
    });
    
    // Добавляем слушатель событий для селектора пользовательских вариаций
    const variationSelectButton = document.getElementById("variation-select-button");
    const variationDropdown = document.getElementById("variation-dropdown");
    const variationSelectText = document.getElementById("variation-select-text");
    
    if (variationSelectButton && variationDropdown) {
        console.log('Variation elements found:', {
            button: variationSelectButton,
            dropdown: variationDropdown,
            text: variationSelectText
        });
        
        
        // Переключаем выпадающее меню
        variationSelectButton.addEventListener("click", (event) => {
            event.preventDefault();
            console.log('Variation button clicked');
            const isOpen = variationDropdown.style.display !== 'none';
            console.log('Is dropdown open:', isOpen);
            
            if (!isOpen) {
                // Показываем выпадающий список
                variationDropdown.style.display = 'block';
                variationSelectButton.classList.add('open');
                
                // Позиционируем выпадающий список точно под кнопкой
                const buttonRect = variationSelectButton.getBoundingClientRect();
                const modalContainer = document.querySelector('#modal-content');
                const modalRect = modalContainer.getBoundingClientRect();
                
                // Устанавливаем позицию выпадающего списка относительно модального окна
                variationDropdown.style.position = 'absolute';
                variationDropdown.style.left = '0px';
                variationDropdown.style.top = '100%';
                variationDropdown.style.marginTop = '4px';
                variationDropdown.style.width = '100%';
                variationDropdown.style.minWidth = '100%';
                
                console.log('Dropdown positioned at:', {
                    position: 'absolute',
                    left: '0px',
                    top: '100%',
                    width: '100%',
                    buttonWidth: buttonRect.width,
                    modalWidth: modalRect.width
                });
            } else {
                variationDropdown.style.display = 'none';
                variationSelectButton.classList.remove('open');
                console.log('Dropdown closed');
            }
        });
        
        // Обрабатываем выбор опции
        variationDropdown.addEventListener("click", (event) => {
            const option = event.target.closest('.variation-option');
            if (option) {
                const selectedVariationId = option.dataset.value;
                const selectedVariation = S.partModal.variants?.find(v => v.id === selectedVariationId);
                
                if (selectedVariation && selectedVariation.id !== S.selPartId) {
                    // Обновляем выбранный ID детали на новую вариацию
                    S.selPartId = selectedVariationId;
                    
                    // Обновляем текст кнопки
                    variationSelectText.textContent = selectedVariation.name;
                    
                    // Обновляем стиль опций
                    variationDropdown.querySelectorAll('.variation-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    option.classList.add('selected');
                    
                    // Закрываем выпадающее меню
                    variationDropdown.style.display = 'none';
                    variationSelectButton.classList.remove('open');
                    
                    // Обновляем данные модального окна детали для новой вариации
                    const newPart = PART_MAP[selectedVariationId];
                    if (newPart) {
                        S.partModal.imgUrl = newPart.rebrickable_img_url || null;
                        S.partModal.selColorId = null;
                        S.partModal.qty = 0;
                        
                        // Обновляем изображение
                        updateModalPartially({
                            image: true
                        });
                        
                        // Обновляем заголовок модального окна для отображения имени выбранной вариации
                        const modalTitle = document.querySelector('#modal-content h2');
                        if (modalTitle) {
                            modalTitle.textContent = selectedVariation.name;
                        }
                        
                        // Загружаем цвета для новой вариации
                        if (newPart.availableColorIds && newPart.availableColorIds.length > 0) {
                            S.partModal.selColorId = sortColorIds(newPart.availableColorIds, newPart.id)[0];
                            S.partModal.qty = S.coll[selectedVariationId]?.[S.partModal.selColorId] || 0;
                            updateModalPartially({
                                colors: true,
                                controls: true
                            });
                            fetchPartColorSpecifics(newPart.id, S.partModal.selColorId);
                        } else {
                            fetchPartColors(newPart.id);
                        }
                    }
                }
            }
        });
        
        // Закрываем выпадающее меню при клике вне его
        document.addEventListener("click", (event) => {
            if (!variationSelectButton.contains(event.target) && !variationDropdown.contains(event.target)) {
                variationDropdown.style.display = 'none';
                variationSelectButton.classList.remove('open');
            }
        });
        
        // Закрываем выпадающее меню при нажатии клавиши Escape
        document.addEventListener("keydown", (event) => {
            if (event.key === "Escape") {
                variationDropdown.style.display = 'none';
                variationSelectButton.classList.remove('open');
            }
        });
        
        // Закрываем выпадающее меню при прокрутке (важно для фиксированного позиционирования)
        window.addEventListener("scroll", () => {
            if (variationDropdown.style.display !== 'none') {
                variationDropdown.style.display = 'none';
                variationSelectButton.classList.remove('open');
            }
        });
        
        // Закрываем выпадающее меню при изменении размера окна
        window.addEventListener("resize", () => {
            if (variationDropdown.style.display !== 'none') {
                variationDropdown.style.display = 'none';
                variationSelectButton.classList.remove('open');
            }
        });
    }
}

function renderColorSelector() {
    if (!S.selPartId) return "";
    const e = PART_MAP[S.selPartId];
    if (!e) return "";
    const {
        selColorId: t,
        loadingColors: o
    } = S.partModal, l = e.availableColorIds || [];
    
    if (o) {
        return '<div class="flex items-center justify-center h-24"><div class="loader !w-8 !h-8"></div></div>';
    }
    
    if (l.length === 0) {
        return '<div class="text-center py-4">\n                        <p class="text-sm text-gray-400 mb-3">Нет информации о доступных цветах.</p>\n                        <button data-action="retry-fetch-colors" class="bg-blue-600 text-white font-bold py-1.5 px-4 rounded-lg hover:bg-blue-700 transition-colors text-sm">\n                            Попробовать снова\n                        </button>\n                    </div>';
    }
    
    return `
            <div class="bg-gray-900/50 rounded-lg">
                <div class="relative color-palette-wrapper">
                    <div class="color-palette-container no-scrollbar">
                        <div class="flex flex-wrap justify-center gap-3 p-3 color-palette-inner">
                            ${sortColorIds(l,e.id).map(e=>{const o=COLOR_MAP[e];if(!o)return"";const l=S.coll[S.selPartId]&&S.coll[S.selPartId][e]>0;return`
                <button data-color-id="${e}" title="${o.name}" class="w-8 h-8 rounded-full border-2 transition-transform duration-150 overflow-hidden flex-shrink-0 flex items-center justify-center ${o.isTransparent?"checkerboard":""} ${t===e?"border-blue-500 scale-110":"border-gray-600 hover:border-gray-400"}" style="background-color: ${o.hex};">
                    ${l?`<div class="w-2 h-2 bg-white rounded-full ${o.isTransparent || o.hex === '#FFFFFF' || o.hex === '#fff' ? 'border border-black' : ''}"></div>`:""}
                </button>
            `}).join("")}
                        </div>
                    </div>
                    ${l.length>1.5*COLOR_COLLAPSE_THRESHOLD?'<div class="absolute bottom-0 left-0 right-0 h-8 bg-gradient-to-t from-gray-900/50 to-transparent pointer-events-none color-palette-gradient"></div>':""}
                </div>
            </div>
        `;
}
function renderModalControls() {
    const {
        selColorId: e,
        qty: t
    } = S.partModal, o = e ? COLOR_MAP[e] : null;
    if (!o || !S.selPartId) return "";
    const l = S.coll[S.selPartId]?.[e] || 0;
    return `
            <div class="bg-gray-700/50 rounded-lg p-3">
                <div class="space-y-2">
                    <div class="flex justify-between items-center">
                        <p class="text-white font-semibold truncate" title="${o.name}">${o.name}</p>
                        <p class="text-sm text-gray-400 text-right">В коллекции: <span id="modal-in-collection-qty" class="font-bold text-white">${l}</span></p>
                    </div>
                    
                    <div class="flex justify-between items-center gap-3">
                        <div class="flex items-center gap-1.5">
                            <button data-action="decrease-qty" class="p-2 rounded-full ${t > 0 ? 'bg-gray-600 hover:bg-gray-500 shadow-lg hover:shadow-gray-500/25' : 'bg-gray-700 cursor-not-allowed'} text-white transition-colors duration-150" ${t <= 0 ? 'disabled' : ''} title="Уменьшить количество">${I_Minus("w-5 h-5")}</button>
                            <input id="modal-quantity-input" type="number" value="${t}" readonly class="w-12 text-center bg-gray-900 text-white font-bold rounded-md py-1"/>
                            <button data-action="increase-qty" class="p-2 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors duration-150 shadow-lg hover:shadow-gray-500/25" title="Увеличить количество">${I_Plus("w-5 h-5")}</button>
                        </div>
                        <button id="modal-update-collection-btn" data-action="update-collection" class="flex-grow bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors duration-150 shadow-lg hover:shadow-blue-500/25">
                            ${l>0?"Обновить":"Добавить"}
                        </button>
                    </div>
                    <div id="modal-delete-container" class="h-12 flex items-center justify-center">
                        ${l>0?`
                            <button data-action="delete-from-collection-modal" class="mt-1 text-sm bg-red-600 hover:bg-red-700 text-white rounded-md py-1.5 px-3 transition-colors duration-150 shadow-lg hover:shadow-red-500/25">Удалить из коллекции</button>
                        `:""}
                    </div>
                </div>
            </div>
        `
}
function renderFilterModal() {
    if (!S.filterOpen) return void closeFilterModal();
    
    // Скрываем указатель при открытии модального окна фильтров (всегда, так как это основное взаимодействие)
    hideSidebarHint();
    
    // Синхронизируем tempFilters с текущими фильтрами при открытии модального окна
    tempFilters.setFilters = { ...S.setFilters };
    tempFilters.sortBy = S.sortBy;
    tempFilters.filters = { ...S.filters };
    
    let e = "";
    if ("sets" === S.subView) {
        const t = [{
            id: "relevance",
            name: "Релевантность",
            desc: "Поиск"
        }, {
            id: "year_desc",
            name: "Год (новые)",
            desc: "По умолч."
        }, {
            id: "year_asc",
            name: "Год (старые)",
            desc: ""
        }, {
            id: "parts_desc",
            name: "Кол-во деталей (убыв.)",
            desc: ""
        }, {
            id: "parts_asc",
            name: "Кол-во деталей (возр.)",
            desc: ""
        }, {
            id: "alpha_asc",
            name: "Алфавит (А-Я)",
            desc: ""
        }, {
            id: "alpha_desc",
            name: "Алфавит (Я-А)",
            desc: ""
        }].map(e => {
            const t = tempFilters.sortBy === e.id,
                o = "relevance" === e.id && !S.q,
                l = ("relevance" === e.id && S.q || "year_desc" === e.id && !S.q ? `<span class="ml-2 text-xs bg-blue-600/50 text-blue-300 px-1.5 py-0.5 rounded-full">По умолч.</span>` : "");
            return `
                    <label class="flex items-center p-3 rounded-lg hover:bg-gray-700/50 transition-colors cursor-pointer ${o?"opacity-50 cursor-not-allowed":""}">
                        <input type="radio" name="sort" value="${e.id}" class="h-4 w-4 text-blue-600 bg-gray-700 border-gray-500 focus:ring-blue-500" ${t?"checked":""} ${o?"disabled":""} data-action="modal-set-sort">
                        <span class="ml-3 text-white">${e.name}</span>
                        ${l}
                    </label>
                `
        }).join("");
        e = `
                <div>
                    <h3 class="text-md font-semibold text-gray-300 mb-2">Сортировать по</h3>
                    <div class="bg-gray-900/50 rounded-lg space-y-1 p-2">${t}</div>
                </div>
                <div>
                    <h3 class="text-md font-semibold text-gray-300 mb-2">Фильтры</h3>
                    <div class="bg-gray-900/50 rounded-lg p-3 space-y-4">
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label for="min-year" class="block text-sm font-medium text-gray-400 mb-1">Мин. год</label>
                                <input type="number" id="min-year" value="${tempFilters.setFilters.minYear || ''}" data-filter-key="minYear" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Например: 2020" oninput="updateFilterValue(this, 'minYear')" onchange="updateFilterValue(this, 'minYear')">
                            </div>
                             <div>
                                <label for="max-year" class="block text-sm font-medium text-gray-400 mb-1">Макс. год</label>
                                <input type="number" id="max-year" value="${tempFilters.setFilters.maxYear || ''}" data-filter-key="maxYear" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Например: 2023" oninput="updateFilterValue(this, 'maxYear')" onchange="updateFilterValue(this, 'maxYear')">
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label for="min-parts" class="block text-sm font-medium text-gray-400 mb-1">Мин. деталей</label>
                                <input type="number" id="min-parts" value="${tempFilters.setFilters.minParts || ''}" data-filter-key="minParts" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Например: 100" oninput="updateFilterValue(this, 'minParts')" onchange="updateFilterValue(this, 'minParts')">
                            </div>
                             <div>
                                <label for="max-parts" class="block text-sm font-medium text-gray-400 mb-1">Макс. деталей</label>
                                <input type="number" id="max-parts" value="${tempFilters.setFilters.maxParts || ''}" data-filter-key="maxParts" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Например: 1000" oninput="updateFilterValue(this, 'maxParts')" onchange="updateFilterValue(this, 'maxParts')">
                            </div>
                        </div>
                    </div>
                </div>
            `
    } else if ("minifigs" === S.subView) {
        const t = [{
            id: "relevance",
            name: "Релевантность",
            desc: "Поиск"
        }, {
            id: "name_asc",
            name: "Алфавит (А-Я)",
            desc: "По умолч."
        }, {
            id: "name_desc",
            name: "Алфавит (Я-А)",
            desc: ""
        }, {
            id: "num_parts_desc",
            name: "Кол-во деталей (убыв.)",
            desc: ""
        }, {
            id: "num_parts_asc",
            name: "Кол-во деталей (возр.)",
            desc: ""
        }].map(e => {
            const t = tempFilters.sortBy === e.id,
                o = "relevance" === e.id && !S.q,
                l = ("relevance" === e.id && S.q || "name_asc" === e.id && !S.q ? `<span class="ml-2 text-xs bg-blue-600/50 text-blue-300 px-1.5 py-0.5 rounded-full">По умолч.</span>` : "");
            return `
                    <label class="flex items-center p-3 rounded-lg hover:bg-gray-700/50 transition-colors cursor-pointer ${o?"opacity-50 cursor-not-allowed":""}">
                        <input type="radio" name="sort" value="${e.id}" class="h-4 w-4 text-blue-600 bg-gray-700 border-gray-500 focus:ring-blue-500" ${t?"checked":""} ${o?"disabled":""} data-action="modal-set-sort">
                        <span class="ml-3 text-white">${e.name}</span>
                        ${l}
                    </label>
                `
        }).join("");
        e = `
                <div>
                    <h3 class="text-md font-semibold text-gray-300 mb-2">Сортировать по</h3>
                    <div class="bg-gray-900/50 rounded-lg space-y-1 p-2">${t}</div>
                </div>
            `
    } else {
        const sortOptions = [{
            id: "relevance",
            name: "Релевантность",
            desc: "Поиск"
        }, {
            id: "popularity",
            name: "Популярность",
            desc: "Каталог"
        }, {
            id: "alpha_asc",
            name: "Алфавит (А-Я)",
            desc: ""
        }, {
            id: "alpha_desc",
            name: "Алфавит (Я-А)",
            desc: ""
        }];
        if (S.view !== "catalog") {
            sortOptions.push({
                id: "quantity_desc",
                name: "Кол-во в коллекции (убыв.)",
                desc: ""
            }, {
                id: "quantity_asc",
                name: "Кол-во в коллекции (возр.)",
                desc: ""
            });
        }
        const t = sortOptions.map(e => {
            const t = tempFilters.sortBy === e.id,
                o = "relevance" === e.id && !S.q || "popularity" === e.id && S.q,
                l = S.q && "relevance" === e.id || !S.q && "popularity" === e.id ? '<span class="ml-2 text-xs bg-blue-600/50 text-blue-300 px-1.5 py-0.5 rounded-full">По умолч.</span>' : "";
            return `
                    <label class="flex items-center p-3 rounded-lg hover:bg-gray-700/50 transition-colors cursor-pointer ${o?"opacity-50 cursor-not-allowed":""}">
                        <input type="radio" name="sort" value="${e.id}" class="h-4 w-4 text-blue-600 bg-gray-700 border-gray-500 focus:ring-blue-500" ${t?"checked":""} ${o?"disabled":""} data-action="modal-set-sort">
                        <span class="ml-3 text-white">${e.name}</span>
                        ${l}
                    </label>
                `
        }).join(""), o = "catalog" === S.view ? `
                <div>
                    <h3 class="text-md font-semibold text-gray-300 mb-2">Фильтры</h3>
                    <div class="bg-gray-900/50 rounded-lg p-2">
                        <label class="flex justify-between items-center p-2 cursor-pointer">
                            <span class="text-white">Только детали в коллекции</span>
                            <div class="relative">
                                <input type="checkbox" class="sr-only peer" ${tempFilters.filters.inCollectionOnly?"checked":""} data-action="modal-toggle-collection">
                                <div class="w-11 h-6 bg-gray-600 rounded-full peer peer-focus:ring-2 peer-focus:ring-blue-500 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                            </div>
                        </label>
                    </div>
                </div>
                            ` : "", l = Object.keys(COLOR_MAP).sort((e, t) => COLOR_MAP[e].name.localeCompare(COLOR_MAP[t].name, 'en')).map(e => {
            const t = COLOR_MAP[e],
                o = tempFilters.filters.colorIds.includes(e);
            return `<button data-action="modal-set-color" data-color-id="${e}" title="${t.name}" class="w-8 h-8 rounded-full border-2 transition-transform duration-150 overflow-hidden flex-shrink-0 ${t.isTransparent?"checkerboard":""} ${o?"border-blue-500 scale-110":"border-gray-600 hover:border-gray-400"}" style="background-color: ${t.hex};"></button>`
        }).join("");
        e = `
                <div>
                    <h3 class="text-md font-semibold text-gray-300 mb-2">Сортировать по</h3>
                    <div class="bg-gray-900/50 rounded-lg space-y-1 p-2">${t}</div>
                </div>
                ${o}
                <div>
                     <h3 class="text-md font-semibold text-gray-300 mb-2">Фильтр по цвету</h3>
                     <div class="bg-gray-900/50 rounded-lg p-3">
                        <button data-action="modal-set-color" data-color-id="null" class="w-full mb-3 py-2 text-sm rounded-md transition-colors duration-150 ${0===tempFilters.filters.colorIds.length?"bg-blue-600 text-white font-semibold shadow-lg hover:shadow-blue-500/25":"bg-gray-600 hover:bg-gray-500 text-gray-200 shadow-lg hover:shadow-gray-500/25"}">Все цвета</button>
                        <div class="max-h-60 overflow-y-auto no-scrollbar pr-1">
                            <div class="grid gap-2" style="grid-template-columns: repeat(auto-fill,minmax(180px,1fr));">
                                ${Object.keys(COLOR_MAP).sort((a,b)=>COLOR_MAP[a].name.localeCompare(COLOR_MAP[b].name,'en')).map(id=>{const c=COLOR_MAP[id];const sel=tempFilters.filters.colorIds.includes(id);return `
                                    <button data-action="modal-set-color" data-color-id="${id}" class="flex items-center gap-3 p-2 rounded-md border ${sel?"border-blue-500 bg-blue-900/30":"border-gray-700 hover:border-gray-500"}">
                                        <span class="w-6 h-6 rounded-full border ${c.isTransparent?"checkerboard border-gray-500":"border-gray-500"}" style="background-color:${c.hex}"></span>
                                        <span class="text-sm text-gray-200 truncate">${c.name}</span>
                                    </button>`}).join("")}
                            </div>
                        </div>
                     </div>
                </div>`
    }
    S.filterOpen = true;
    modalManager.openModal('filter-modal-container', filterModalEl);
    filterModalEl.innerHTML = `
            <div id="filter-modal-content" class="bg-gray-800 rounded-lg shadow-xl w-[calc(100%-2rem)] max-w-md flex flex-col max-h-[calc(100vh-2rem)] modal-content-enter">
                <div class="flex-shrink-0 p-4 border-b border-gray-700 flex justify-between items-center">
                     <h2 class="text-xl font-bold text-white">Фильтры и сортировка</h2>
                     <button id="filter-modal-close" class="modal-close-btn" title="Закрыть модальное окно фильтров">${I_X("w-4 h-4")}</button>
                </div>
                <div class="flex-grow p-4 overflow-y-auto no-scrollbar space-y-6">${e}</div>
                <div class="flex-shrink-0 p-4 border-t border-gray-700 flex justify-between items-center gap-4">
                    <button data-action="modal-reset-filters" class="px-4 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-600 hover:bg-gray-500 text-white shadow-lg hover:shadow-gray-500/25" title="Сбросить все фильтры к значениям по умолчанию">Сбросить</button>
                    <button data-action="modal-apply-filters" class="flex-grow px-4 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-blue-600 hover:bg-blue-700 text-white shadow-lg hover:shadow-blue-500/25" title="Применить выбранные фильтры и сортировку">Применить</button>
                </div>
            </div>
        `
}
function renderSettingsModal() {
    if (!S.settingsOpen) return void closeSettingsModal();
    const isFirstOpen = settingsModalEl.classList.contains('modal-hidden');
    // Сохраняем позицию прокрутки содержимого, чтобы избежать дергания
    const prevScrollTop = settingsModalEl.querySelector('#settings-modal-scroll')?.scrollTop || 0;
    
    S.settingsOpen = true;
    if (isFirstOpen) {
        // Скрываем указатель при открытии модального окна настроек (всегда, так как это основное взаимодействие)
        hideSidebarHint();
        modalManager.openModal('settings-modal-container', settingsModalEl);
    }
    const {
        delConfirm: e,
        status: t,
        statusType: o
    } = S.settingsModal, l = Object.values(S.coll).reduce((e, t) => e + Object.keys(t).length, 0);
    const a = Object.keys(S.setColl).length;
    const i = Object.keys(S.minifigColl).length;
    let n = "";
    n = "parts" === e ? `
                <p class="text-yellow-300 text-sm text-center mb-2">Вы уверены? Это действие необратимо</p>
                <div class="flex gap-2">
                    <button data-action="cancel-delete" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-700 hover:bg-gray-600 text-white">Отмена</button>
                    <button data-action="confirm-delete-parts" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-700 hover:bg-red-600 text-white shadow-lg hover:shadow-red-500/25">Подтвердить удаление</button>
                </div>` : "all" === e ? `
                <p class="text-yellow-300 text-sm text-center mb-2">Вы уверены? Это действие необратимо и удалит ВСЕ данные в коллекции</p>
                <div class="flex gap-2">
                    <button data-action="cancel-delete" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-700 hover:bg-gray-600 text-white">Отмена</button>
                    <button data-action="confirm-delete-all" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-700 hover:bg-red-600 text-white shadow-lg hover:shadow-red-500/25">Подтвердить удаление ВСЕГО</button>
                </div>` : `<button data-action="delete-all-parts" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-700 hover:bg-red-600 text-white shadow-lg hover:shadow-red-500/25 ${0===l?"opacity-50 cursor-not-allowed":""}" ${0===l?"disabled":""}" title="Удалить все детали из коллекции (действие необратимо)">Удалить все детали</button>`;
    let r = "";
    r = "sets" === e ? `
                <p class="text-yellow-300 text-sm text-center mb-2">Вы уверены? Это действие необратимо</p>
                <div class="flex gap-2">
                    <button data-action="cancel-delete" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-700 hover:bg-gray-600 text-white">Отмена</button>
                    <button data-action="confirm-delete-sets" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-700 hover:bg-red-600 text-white shadow-lg hover:shadow-red-500/25">Подтвердить удаление</button>
                </div>` : `<button data-action="delete-all-sets" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-700 hover:bg-red-600 text-white shadow-lg hover:shadow-red-500/25 ${0===a?"opacity-50 cursor-not-allowed":""}" ${0===a?"disabled":""}" title="Удалить все наборы из коллекции (действие необратимо)">Удалить все наборы</button>`;
    let s = "";
    s = "minifigs" === e ? `
                <p class="text-yellow-300 text-sm text-center mb-2">Вы уверены? Это действие необратимо</p>
                <div class="flex gap-2">
                    <button data-action="cancel-delete" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-700 hover:bg-gray-600 text-white">Отмена</button>
                    <button data-action="confirm-delete-minifigs" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-700 hover:bg-red-600 text-white shadow-lg hover:shadow-red-500/25">Подтвердить удаление</button>
                </div>` : `<button data-action="delete-all-minifigs" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-700 hover:bg-red-600 text-white shadow-lg hover:shadow-red-500/25 ${0===i?"opacity-50 cursor-not-allowed":""}" ${0===i?"disabled":""}" title="Удалить все минифигурки из коллекции (действие необратимо)">Удалить все минифигурки</button>`;
    const c = "error" === o ? "bg-red-900/50 text-red-300" : "success" === o ? "bg-green-900/50 text-green-300" : "bg-blue-900/50 text-blue-300";
    const enterClass = isFirstOpen ? 'modal-content-enter' : '';
    settingsModalEl.innerHTML = `
             <div id="settings-modal-content" class="bg-gray-800 rounded-lg shadow-xl w-[calc(100%-2rem)] max-w-md flex flex-col max-h-[calc(100vh-2rem)] ${enterClass}">
                <div class="flex-shrink-0 p-4 border-b border-gray-700 flex justify-between items-center">
                     <h2 class="text-xl font-bold text-white">Настройки</h2>
                     <button id="settings-modal-close" class="modal-close-btn" title="Закрыть модальное окно настроек">${I_X("w-4 h-4")}</button>
                </div>
                <div id="settings-modal-scroll" class="flex-grow p-4 overflow-y-auto no-scrollbar space-y-6">
                     <div>
                        <h3 class="text-md font-semibold text-white mb-2">Импорт и экспорт CSV</h3>
                         ${t?`<div id="import-export-status" class="mb-2 p-2 text-sm rounded-md ${c}">${t}</div>`:'<div id="import-export-status" class="mb-2"></div>'}
                        <div class="bg-gray-800/60 border border-gray-700/50 rounded-lg p-3 space-y-3">
                            <p class="text-xs text-gray-400">Импорт и экспорт вашей коллекции в формате CSV. Импорт объединит данные с вашей текущей коллекцией</p>
                            <div class="grid grid-cols-2 gap-3">
                                <button data-action="import-csv" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-emerald-600 hover:bg-emerald-500 text-white shadow-lg hover:shadow-emerald-500/25" title="Импортировать коллекцию из CSV файла">
                                    ${I_Up("w-5 h-5 mr-2")} Импорт
                                </button>
                                <button data-action="export-csv" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-indigo-600 hover:bg-indigo-500 text-white shadow-lg hover:shadow-indigo-500/25" title="Экспортировать коллекцию в CSV файл">
                                    ${I_Down("w-5 h-5 mr-2")} Экспорт
                                </button>
                                <button data-action="share-collection" class="col-span-2 w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-blue-600 hover:bg-blue-700 text-white shadow-lg hover:shadow-blue-500/25" title="Поделиться коллекцией через социальные сети или скачать CSV файл">
                                    ${I_Share("w-5 h-5 mr-2")} Передать в соцсети
                                </button>
                                
                            </div>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-md font-semibold text-white mb-2">Мультивыбор</h3>
                        <div class="bg-gray-800/60 border border-gray-700/50 rounded-lg p-3 space-y-3">
                            <div class="flex items-center justify-between gap-2">
                                <span class="text-sm text-gray-300 flex items-center gap-2">${I_Cat('w-4 h-4 text-blue-400')} Каталог</span>
                                <button data-action="toggle-catalog-multiselect" class="toggle-switch ${S.catalogMultiSelectEnabled? 'on' : ''}" aria-pressed="${S.catalogMultiSelectEnabled}"><span class="knob"></span></button>
                            </div>
                            <div class="flex items-center justify-between gap-2">
                                <span class="text-sm text-gray-300 flex items-center gap-2">${I_Coll('w-4 h-4 text-green-400')} Коллекция</span>
                                <button data-action="toggle-collection-multiselect" class="toggle-switch ${S.collectionMultiSelectEnabled? 'on' : ''}" aria-pressed="${S.collectionMultiSelectEnabled}"><span class="knob"></span></button>
                            </div>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-md font-semibold text-white mb-2">Отображение коллекции</h3>
                        <div class="bg-gray-800/60 border border-gray-700/50 rounded-lg p-3 space-y-3">
                            <div class="flex items-center justify-between gap-2">
                                <span class="text-sm text-gray-300 flex items-center gap-2">${I_Folder('w-4 h-4 text-green-400')} Группировка в папки</span>
                                <button data-action="toggle-folders" class="toggle-switch ${S.foldersEnabled? 'on' : ''}" aria-pressed="${S.foldersEnabled}"><span class="knob"></span></button>
                            </div>
                            <p class="text-xs text-gray-400">Если включено, детали с более чем 3 цветами будут сгруппированы в папки. Если выключено, все детали будут показаны отдельными карточками.</p>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-md font-semibold text-white mb-2">Защита от случайной перезагрузки</h3>
                        <div class="bg-gray-800/60 border border-gray-700/50 rounded-lg p-3 space-y-3">
                            <div class="flex items-center justify-between gap-2">
                                <span class="text-sm text-gray-300 flex items-center gap-2">🛡️ Подтверждать перезагрузку</span>
                                <button data-action="toggle-prevent-exit" class="toggle-switch ${S.preventAccidentalExit? 'on' : ''}" aria-pressed="${S.preventAccidentalExit}"><span class="knob"></span></button>
                            </div>
                            <p class="text-xs text-gray-400">Рекомендуется для мобильных устройств: предотвратит потерю незаписанных изменений при случайном обновлении страницы.</p>
                        </div>
                    </div>

                     <div>
                        <h3 class="text-md font-semibold text-white mb-2">Очитска коллекции</h3>
                        <div class="bg-red-900/20 border border-red-600/30 rounded-lg p-3 space-y-3">
                           ${"all" !== e ? `<button data-action="delete-all-data" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-700 hover:bg-red-600 text-white mb-3 shadow-lg hover:shadow-red-500/25">
                               ${I_Trash("w-5 h-5 mr-2")} Удалить всё
                           </button>` : ""}
                           ${"all"===e ? `
                               <div class="p-3">
                                   <p class="text-yellow-300 text-sm text-center mb-2">Вы уверены? Это действие необратимо и удалит ВСЕ данные в коллекции</p>
                                   <div class="flex gap-2">
                                       <button data-action="cancel-delete" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-700 hover:bg-gray-600 text-white">Отмена</button>
                                       <button data-action="confirm-delete-all" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-700 hover:bg-red-600 text-white shadow-lg hover:shadow-red-500/25">Подтвердить удаление ВСЕГО</button>
                                   </div>
                               </div>
                           ` : `${n}${r}${s}`}
                        </div>
                    </div>
                    <div>
                        <h3 class="text-md font-semibold text-white mb-2">Управление кэшем</h3>
                        <div class="bg-gray-800/60 border border-gray-700/50 rounded-lg p-3 space-y-3">
                            <p class="text-xs text-gray-400">Управление кэшем приложения для улучшения производительности и освобождения места</p>
                            <div class="flex gap-3">
                                <button data-action="clear-app-cache" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-700 hover:bg-red-600 text-white shadow-lg hover:shadow-red-500/25">
                                    Очистить кэш
                                </button>
                            </div>
                            <div id="cache-usage" class="text-xs text-gray-400"></div>
                        </div>
                    </div>
                    <div>
                        <button data-action="toggle-settings-stats" class="w-full flex items-center justify-between text-left text-md font-semibold text-white mb-2">
                            <span>Статистика загрузки</span>
                            <span id="settings-stats-chevron" class="rotate">${I_Chev('w-5 h-5 text-gray-400')}</span>
                        </button>
                        <div id="settings-stats-panel" class="bg-gray-800/60 border border-gray-700/50 rounded-lg p-3 space-y-2 text-sm collapse-panel">
                            <div class="text-green-400 text-xs mb-2">✓ Все данные загружаются из CSV файлов</div>
                            ${(() => {
                                const stats = getLoadingStats();
                                const lastUpdate = stats.lastApiUpdate ? new Date(stats.lastApiUpdate).toLocaleString('ru-RU') : 'Никогда';
                                const apiOpen = localStorage.getItem('apiStatsOpen') === 'true';
                                return `
                                    <div class="space-y-1">
                                        <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                                            <div class="flex items-center text-gray-300 text-xs">
                                                <div class="w-2 h-2 rounded-full bg-red-500 mr-2"></div>
                                                Цвета:
                                            </div>
                                            <div class="text-white font-semibold text-xs">${stats.colors}</div>
                                        </div>
                                        <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                                            <div class="flex items-center text-gray-300 text-xs">
                                                <div class="w-2 h-2 rounded-full bg-blue-500 mr-2"></div>
                                                Категории:
                                            </div>
                                            <div class="text-white font-semibold text-xs">${stats.categories}</div>
                                        </div>
                                        <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                                            <div class="flex items-center text-gray-300 text-xs">
                                                <div class="w-2 h-2 rounded-full bg-green-500 mr-2"></div>
                                                Темы:
                                            </div>
                                            <div class="text-white font-semibold text-xs">${stats.themes}</div>
                                        </div>
                                        <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                                            <div class="flex items-center text-gray-300 text-xs">
                                                <div class="w-2 h-2 rounded-full bg-yellow-500 mr-2"></div>
                                                Детали:
                                            </div>
                                            <div class="text-white font-semibold text-xs">${stats.parts}</div>
                                        </div>
                                        <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                                            <div class="flex items-center text-gray-300 text-xs">
                                                <div class="w-2 h-2 rounded-full bg-purple-500 mr-2"></div>
                                                Наборы:
                                            </div>
                                            <div class="text-white font-semibold text-xs">${stats.sets}</div>
                                        </div>
                                        <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                                            <div class="flex items-center text-gray-300 text-xs">
                                                <div class="w-2 h-2 rounded-full bg-pink-500 mr-2"></div>
                                                Минифигурки:
                                            </div>
                                            <div class="text-white font-semibold text-xs">${stats.minifigs}</div>
                                        </div>
                                    </div>
                                    <button data-action="toggle-api-stats" class="w-full flex items-center justify-between text-left text-xs font-semibold text-yellow-300 mt-3 pt-2 border-t border-gray-700/50">
                                        <span>Данные через API</span>
                                        <span id="api-stats-chevron" class="${apiOpen ? 'rotate-180' : ''}">${I_Chev('w-4 h-4 text-yellow-300')}</span>
                                    </button>
                                    <div id="api-stats-panel" class="${apiOpen ? 'open ' : ''}collapse-panel">
                                        <div class="space-y-1 mt-1">
                                            <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                                                <div class="flex items-center text-gray-300 text-xs">
                                                    <div class="w-2 h-2 rounded-full bg-red-500 mr-2"></div>
                                                    Цвета:
                                                </div>
                                                <div class="text-white font-semibold text-xs">${stats.apiColors}</div>
                                            </div>
                                            <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                                                <div class="flex items-center text-gray-300 text-xs">
                                                    <div class="w-2 h-2 rounded-full bg-yellow-500 mr-2"></div>
                                                    Детали:
                                                </div>
                                                <div class="text-white font-semibold text-xs">${stats.apiParts}</div>
                                            </div>
                                            <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                                                <div class="flex items-center text-gray-300 text-xs">
                                                    <div class="w-2 h-2 rounded-full bg-purple-500 mr-2"></div>
                                                    Наборы:
                                                </div>
                                                <div class="text-white font-semibold text-xs">${stats.apiSets}</div>
                                            </div>
                                            <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                                                <div class="flex items-center text-gray-300 text-xs">
                                                    <div class="w-2 h-2 rounded-full bg-pink-500 mr-2"></div>
                                                    Минифигурки:
                                                </div>
                                                <div class="text-white font-semibold text-xs">${stats.apiMinifigs}</div>
                                            </div>
                                            <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                                                <div class="flex items-center text-gray-300 text-xs">
                                                    <div class="w-2 h-2 rounded-full bg-blue-500 mr-2"></div>
                                                    Изображения:
                                                </div>
                                                <div class="text-white font-semibold text-xs">${stats.apiImages}</div>
                                            </div>
                                        </div>
                                        <div class="text-blue-400 text-xs mt-2">
                                            Последнее обновление API: ${lastUpdate}
                                        </div>
                                    </div>
                                `;
                            })()}
                        </div>
                    </div>
                    <div>
                        <h3 class="text-md font-semibold text-gray-300 mb-2">О сайте</h3>
                        <div class="bg-gray-900/50 rounded-lg p-3 space-y-3 text-sm text-gray-400">
                           <p>
                               Одностраничное веб‑приложение для локального просмотра и ведения собственной коллекции LEGO
                           </p>
                           <ul class="list-disc list-outside pl-5 space-y-1">
                               <li>Каталог деталей/наборов/минифигурок</li>
                               <li>Фильтры, сортировки, поиск</li>
                               <li>Коллекция пользователя (детали, наборы, минифигурки)</li>
                               <li>Полноэкранный просмотр изображений</li>
                               <li>Модальные карточки: изображения, цвета, количество в коллекции</li>
                               <li>Инвентари наборов и минифигурок (клики по элементам открывают карточки)</li>
                               <li>Связанные наборы с минифигуркой</li>
                               <li>Папка для детали в коллекции если добавлено более трёх цветов</li>
                               <li>Панель мультивыбора (удаление в коллекции, добавление в каталоге)</li>
                               <li>Импорт/экспорт коллекции в CSV и «Поделиться» CSV в соцсети</li>
                           </ul>
                           <div class="pt-3 border-t border-gray-700/50 flex flex-col items-center justify-center gap-3 text-center">
                               <a href="https://github.com/Zeka3535/LEGO-Part-Catalog" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-2 px-3 py-2 rounded-md bg-gray-700 hover:bg-gray-600 text-white transition-colors duration-150 shadow-lg hover:shadow-gray-500/25">
                                   <svg class="w-5 h-5" viewBox="0 0 24 24" aria-hidden="true" fill="currentColor"><path d="M12 .5C5.73.5.98 5.24.98 11.5c0 4.85 3.15 8.96 7.52 10.41.55.1.75-.24.75-.53 0-.26-.01-1.13-.02-2.05-3.06.66-3.71-1.3-3.71-1.3-.5-1.26-1.22-1.6-1.22-1.6-1-.69.08-.68.08-.68 1.1.08 1.68 1.13 1.68 1.13.98 1.68 2.58 1.2 3.2.92.1-.71.38-1.2.69-1.48-2.44-.28-5-1.22-5-5.43 0-1.2.43-2.19 1.13-2.96-.11-.28-.49-1.41.11-2.94 0 0 .92-.29 3.02 1.13.88-.24 1.82-.36 2.76-.36.94 0 1.88.12 2.76.36 2.1-1.42 3.02-1.13 3.02-1.13.6 1.53.22 2.66.11 2.94.7.77 1.13 1.76 1.13 2.96 0 4.22-2.56 5.15-5 5.43.4.34.73 1.01.73 2.04 0 1.47-.01 2.65-.01 3.01 0 .29.2.64.75.53 4.37-1.45 7.52-5.56 7.52-10.41C23.02 5.24 18.27.5 12 .5z"/></svg>
                                   <span class="font-semibold">GitHub проекта</span>
                               </a>
                               <p class="text-gray-400 text-xs">
                               Этот сайт использует <a href="https://rebrickable.com/api/" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:underline">Rebrickable API</a> и его базу данных CSV
                               </p>
                           </div>
                        </div>
                    </div>
                </div>
            </div>
        `
    // Восстанавливаем позицию прокрутки при повторном рендере
    if (!isFirstOpen) {
        const scrollEl = document.getElementById('settings-modal-scroll');
        if (scrollEl) scrollEl.scrollTop = prevScrollTop;
    }
    // Обновляем информацию об использовании хранилища/кэша (в МБ)
    ;(async () => {
        try {
            if (navigator.storage && navigator.storage.estimate) {
                const est = await navigator.storage.estimate();
                const used = typeof est.usage === 'number' ? est.usage : 0;
                const quota = typeof est.quota === 'number' ? est.quota : 0;
                const usedMb = (used / (1024 * 1024)).toFixed(2);
                const quotaMb = quota ? (quota / (1024 * 1024)).toFixed(0) : '—';
                let cacheFiles = 0;
                try {
                    const cacheInfo = await window.getCacheInfo();
                    cacheFiles = Object.values(cacheInfo).reduce((sum, v) => sum + (typeof v === 'number' ? v : 0), 0);
                } catch {}
                const el = document.getElementById('cache-usage');
                if (el) el.textContent = `Использование хранилища: ${usedMb} МБ${quota ? ` из ~${quotaMb} МБ` : ''}${cacheFiles ? `, файлов в кэше: ${cacheFiles}` : ''}`;
            }
        } catch {}
    })();
}

function updateFilterModalUI() {
    if (!S.filterOpen || !filterModalEl.innerHTML) return;
    
    // Обновляем опции сортировки
    filterModalEl.querySelectorAll('input[name="sort"]').forEach(e => {
        const input = e;
        input.checked = tempFilters.sortBy === input.value;
    });
    
    // Обновляем фильтры деталей
    if ("parts" === S.subView) {
        const e = filterModalEl.querySelector('input[data-action="modal-toggle-collection"]');
        e && (e.checked = tempFilters.filters.inCollectionOnly);
        const t = filterModalEl.querySelector('button[data-color-id="null"]');
        t && (t.className = `w-full mb-3 py-2 text-sm rounded-md transition-colors ${0===tempFilters.filters.colorIds.length?"bg-blue-600 text-white font-semibold":"bg-gray-600 hover:bg-gray-500 text-gray-200"}`);
        filterModalEl.querySelectorAll('button[data-action="modal-set-color"]').forEach(el => {
            const e = el;
            const t = e.dataset.colorId;
            if (t && "null" !== t) {
                const o = tempFilters.filters.colorIds.includes(t),
                    l = COLOR_MAP[t];
                l && (e.className = `flex items-center gap-3 p-2 rounded-md border ${o?"border-blue-500 bg-blue-900/30":"border-gray-700 hover:border-gray-500"}`)
            }
        })
    }
    
    // Обновляем фильтры наборов
    if ("sets" === S.subView) {
        const minYearInput = filterModalEl.querySelector('input[id="min-year"]');
        const maxYearInput = filterModalEl.querySelector('input[id="max-year"]');
        const minPartsInput = filterModalEl.querySelector('input[id="min-parts"]');
        const maxPartsInput = filterModalEl.querySelector('input[id="max-parts"]');
        
        if (minYearInput) minYearInput.value = tempFilters.setFilters.minYear || "";
        if (maxYearInput) maxYearInput.value = tempFilters.setFilters.maxYear || "";
        if (minPartsInput) minPartsInput.value = tempFilters.setFilters.minParts || "";
        if (maxPartsInput) maxPartsInput.value = tempFilters.setFilters.maxParts || "";
        
        // Обновляем сортировку
        filterModalEl.querySelectorAll('input[name="sort"]').forEach(input => {
            input.checked = tempFilters.sortBy === input.value;
        });
        
        console.log('Updated set filters UI:', tempFilters.setFilters);
        console.log('Updated sort UI:', tempFilters.sortBy);
    }
}

function updateModalPartially(e) {
    if (!S.selPartId) return;
    if (e.image) {
        const e = document.getElementById("modal-image-container");
        if (e) {
            const {
                imgUrl: t,
                loadingImg: o
            } = S.partModal;
            const l = PART_MAP[S.selPartId];
            e.dataset.imageUrl = t || "";
            e.innerHTML = `
                    ${o?`<div class="absolute inset-0 bg-gray-900/80 flex items-center justify-center z-10"><div class="loader !w-10 !h-10"></div></div>`:""}
                    <img ${getPartImageUrl(t)} alt="${l.name}" class="max-w-full max-h-full object-contain">
                     <div class="absolute inset-0 bg-black/40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                       ${I_Search("w-10 h-10 text-white")}
                    </div>
                `
        }
    }
    if (e.colors) {
        const e = document.getElementById("color-selector-container");
        e && (e.innerHTML = renderColorSelector());
    }
    if (e.controls) {
        const e = document.getElementById("modal-controls-container");
        e && (e.innerHTML = renderModalControls())
    }
}
function updateModalControlsState() {
    if (!S.selPartId || !S.partModal.selColorId) return;
    const e = S.coll[S.selPartId]?.[S.partModal.selColorId] || 0,
        t = document.getElementById("modal-in-collection-qty");
    t && (t.textContent = String(e));
    const o = document.getElementById("modal-update-collection-btn");
    o && (o.textContent = e > 0 ? "Обновить" : "Добавить");
    const l = document.getElementById("modal-delete-container");
    if (l) {
        const t = '<button data-action="delete-from-collection-modal" class="mt-1 text-sm bg-red-600 hover:bg-red-700 text-white rounded-md py-1.5 px-3 transition-colors duration-150 shadow-lg hover:shadow-red-500/25">Удалить из коллекции</button>';
        e > 0 ? l.innerHTML.trim() || (l.innerHTML = t) : l.innerHTML = ""
    }
    const a = document.getElementById("modal-quantity-input");
    a && (a.value = String(S.partModal.qty))
}

function renderMinifigModal(e = !1) {
    if (!S.selFigNum) return void closeMinifigModal();
    const t = MINIFIG_MAP[S.selFigNum];
    if (!t) return void closeMinifigModal();
    const o = e ? "modal-content-enter" : "",
        l = "inventory" === S.minifigModal.view;
    e && (document.body.classList.add("overflow-hidden"), minifigModalEl.classList.remove("modal-hidden"), minifigModalEl.style.zIndex = '50', requestAnimationFrame(() => minifigModalEl.classList.add("visible"))), minifigModalEl.innerHTML = `
        <div id="minifig-modal-content" class="bg-gray-800 rounded-lg shadow-xl w-[calc(100%-2rem)] ${l?"max-w-2xl":"max-w-4xl"} flex flex-col ${l?"h-[calc(100vh-4rem)]":"max-h-[calc(100vh-2rem)]"} ${o} transition-all duration-300">
            <div class="flex-shrink-0 p-4 border-b border-gray-700 flex justify-between items-center gap-4">
                 <h2 class="text-xl lg:text-2xl font-bold text-white truncate pr-4">${t.name}</h2>
                 <div class="flex items-center gap-2 flex-shrink-0">
                    ${renderMinifigModalToggleButton()}
                    <button data-action="share-minifig" class="text-gray-300 hover:text-white transition-colors" title="Поделиться минифигуркой через изображение и CSV файл">${I_Share("w-6 h-6")}</button>
                    <button id="minifig-modal-close" class="modal-close-btn" title="Закрыть модальное окно минифигурки">${I_X("w-4 h-4")}</button>
                 </div>
            </div>
            <div id="minifig-scroll-progress"><div class="bar"></div></div>
            <div id="minifig-modal-view-container" class="flex-grow overflow-y-auto no-scrollbar" style="min-height: 0;">
            </div>
        </div>
        `, updateMinifigModalView()
}

function updateMinifigModalView() {
    if (!S.selFigNum) return;
    const e = document.getElementById("minifig-modal-view-container");
    e && ("details" === S.minifigModal.view ? e.innerHTML = renderMinifigModalDetailsView() : e.innerHTML = renderMinifigModalInventoryView())
}

function renderMinifigModalToggleButton() {
    const e = MINIFIG_MAP[S.selFigNum];
    return e ? "details" === S.minifigModal.view ? `<button data-action="toggle-minifig-modal-view" class="flex items-center gap-2 px-3 py-1.5 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-600 hover:bg-gray-500 text-white shadow-lg hover:shadow-gray-500/25">
                ${I_Brick("w-5 h-5")}
                <span>Инвентарь</span>
                <span class="text-xs bg-gray-700 text-gray-200 px-1.5 py-0.5 rounded-full">${e.num_parts}</span>
            </button>` : `<button data-action="toggle-minifig-modal-view" class="flex items-center gap-2 px-3 py-1.5 text-sm font-semibold rounded-md transition-colors duration-150 bg-blue-600 hover:bg-blue-700 text-white shadow-lg hover:shadow-blue-500/25">
                ${I_Cat("w-5 h-5")}
                <span>Детали минифигурки</span>
            </button>` : ""
}

// Функция для получения связанных наборов минифигурки
function getRelatedSetsForMinifig(figNum) {
    if (!window.INVENTORY_DATA || !window.INVENTORY_DATA.minifigs) {
        return [];
    }
    
    const relatedSets = [];
    const inventoryMinifigs = window.INVENTORY_DATA.minifigs;
    
    // Проходим по всем инвентарям, где есть эта минифигурка
    Object.keys(inventoryMinifigs).forEach(inventoryId => {
        const minifigs = inventoryMinifigs[inventoryId];
        const hasMinifig = minifigs.some(m => m.fig_num === figNum);
        
        if (hasMinifig) {
            // Находим соответствующий набор для этого инвентаря
            if (window.INVENTORY_DATA.sets && window.INVENTORY_DATA.sets[inventoryId]) {
                const sets = window.INVENTORY_DATA.sets[inventoryId];
                sets.forEach(set => {
                    if (SET_MAP[set.set_num]) {
                        // Возвращаем полный объект набора для корректного отображения
                        relatedSets.push(SET_MAP[set.set_num]);
                    }
                });
            }
        }
    });
    
    // Убираем дубликаты и сортируем по году
    const uniqueSets = relatedSets.filter((set, index, self) => 
        index === self.findIndex(s => s.set_num === set.set_num)
    ).sort((a, b) => (b.year || 0) - (a.year || 0));
    
    return uniqueSets;
}

// Функция для отображения модального окна связанных наборов
function showRelatedSetsModal(relatedSets, minifigName) {
    if (!relatedSets || relatedSets.length === 0) return;
    
    // Скрываем указатель при открытии модального окна связанных наборов (всегда, так как это основное взаимодействие)
    hideSidebarHint();
    
    modalManager.openModal('related-sets-modal-container', relatedSetsModalEl);
    
    const setsList = relatedSets.map(set => `
        <div class="flex items-center bg-gray-700/50 p-3 rounded-md gap-3 hover:bg-gray-700/70 transition-colors cursor-pointer"
             data-action="open-set-from-related"
             data-set-num="${set.set_num}">
            <div class="w-16 h-16 bg-white rounded-md flex items-center justify-center flex-shrink-0">
                <img ${getPartImageUrl(SET_MAP[set.set_num]?.set_img_url || '')} alt="${set.name}" class="w-full h-full object-contain p-1">
            </div>
            <div class="flex-grow min-w-0">
                <p class="text-white font-semibold truncate">${set.name}</p>
                <p class="text-gray-400 text-sm">${set.set_num}</p>
                <div class="flex items-center gap-2 text-xs text-gray-500">
                    ${set.year ? `<span>${set.year}</span>` : ''}
                    ${set.theme_name ? `<span>• ${set.theme_name}</span>` : ''}
                </div>
            </div>
        </div>
    `).join('');
    
    relatedSetsModalEl.innerHTML = `
        <div class="bg-gray-800 rounded-lg shadow-xl w-[calc(100%-2rem)] max-w-2xl flex flex-col max-h-[calc(100vh-2rem)] modal-content-enter relative">
            <div id="related-sets-scroll-progress"><div class="bar"></div></div>
            <div class="flex-shrink-0 p-4 border-b border-gray-700 flex justify-between items-center">
                <h2 class="text-xl font-bold text-white">Наборы с минифигуркой "${minifigName}"</h2>
                <button id="related-sets-modal-close" class="modal-close-btn" title="Закрыть модальное окно связанных наборов">${I_X("w-4 h-4")}</button>
            </div>
            <div class="flex-grow p-4 overflow-y-auto no-scrollbar space-y-3">
                ${setsList}
            </div>
        </div>
    `;
    
    // Настраиваем скролл-прогресс для модального окна связанных наборов
    setupRelatedSetsScrollProgress();
}

// Функция для настройки скролл-прогресса в модальном окне связанных наборов
function setupRelatedSetsScrollProgress() {
    const track = document.getElementById('related-sets-scroll-progress');
    const content = relatedSetsModalEl.querySelector('.bg-gray-800');
    if (track && content) {
        const header = content.querySelector('.border-b');
        const headerH = header?.offsetHeight || 0;
        const top = Math.max(12, headerH + 8);
        track.style.top = top + 'px';
        track.style.bottom = '12px';
    }
    
    const scrollArea = content?.querySelector('.overflow-y-auto');
    const bar = track?.querySelector('.bar');
    
    const update = () => {
        if (!track || !bar || !scrollArea) return;
        const max = scrollArea.scrollHeight - scrollArea.clientHeight;
        const percent = max <= 0 ? 100 : Math.min(100, Math.max(0, (scrollArea.scrollTop / max) * 100));
        const containerH = track.clientHeight || 0;
        const barH = bar.clientHeight || 24;
        const maxOffset = Math.max(0, containerH - barH);
        const translatePx = (percent / 100) * maxOffset;
        bar.style.transform = `translateY(${translatePx}px)`;
    };
    
    update();
    
    let to;
    const onScroll = () => {
        track?.classList.add('visible');
        update();
        clearTimeout(to);
        to = setTimeout(() => track?.classList.remove('visible'), 200);
    };
    
    scrollArea?.addEventListener('scroll', onScroll, { passive: true });
    
    const obs = new MutationObserver(update);
    scrollArea && obs.observe(scrollArea, { childList: true, subtree: true });
    
    window.addEventListener('resize', () => { update(); }, { passive: true });
}

function renderMinifigModalDetailsView() {
    if (!S.selFigNum) return "";
    const e = MINIFIG_MAP[S.selFigNum];
    const {
        qty: t
    } = S.minifigModal;
    const o = S.minifigColl[S.selFigNum]?.qty || 0;
    const l = `
        <div class="bg-gray-700/50 rounded-lg p-4">
            <div class="space-y-4">
                <div class="flex justify-between items-center">
                    <h3 class="text-white font-semibold">Коллекция минифигурок</h3>
                    <p class="text-sm text-gray-400 text-right">В коллекции: <span class="font-bold text-white">${o}</span></p>
                </div>
                
                <div class="flex justify-between items-center gap-4">
                    <div class="flex items-center gap-2">
                        <button data-action="decrease-minifig-qty" class="p-2 rounded-full ${t > 0 ? 'bg-gray-600 hover:bg-gray-500 shadow-lg hover:shadow-gray-500/25' : 'bg-gray-700 cursor-not-allowed'} text-white transition-colors duration-150" ${t <= 0 ? 'disabled' : ''}" title="Уменьшить количество">${I_Minus("w-5 h-5")}</button>
                        <input type="number" value="${t}" readonly class="w-12 text-center bg-gray-900 text-white font-bold rounded-md py-1"/>
                        <button data-action="increase-minifig-qty" class="p-2 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors duration-150 shadow-lg hover:shadow-gray-500/25" title="Увеличить количество">${I_Plus("w-5 h-5")}</button>
                    </div>
                    <button data-action="update-minifig-collection" class="flex-grow bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors duration-150 shadow-lg hover:shadow-blue-500/25">
                        ${o>0?"Обновить":"Добавить"}
                    </button>
                </div>
                ${o>0?`
                    <div class="flex justify-center">
                        <button data-action="delete-from-minifig-collection-modal" class="mt-1 text-sm bg-red-600 hover:bg-red-700 text-white rounded-md py-1.5 px-3 transition-colors duration-150 shadow-lg hover:shadow-red-500/25">Удалить из коллекции</button>
                    </div>
                `:"<div></div>"}
            </div>
        </div>`;
    return `
        <div class="flex flex-col lg:flex-row">
            <div class="lg:w-1/2 p-4 sm:p-6 bg-gray-900/30 flex items-center justify-center flex-shrink-0 border-b lg:border-b-0 lg:border-r border-gray-700">
                 <div data-action="view-image-fullscreen" data-image-url="${e.minifig_img_url||e.set_img_url||""}" class="w-48 h-48 sm:w-64 sm:w-64 bg-white rounded-lg flex items-center justify-center overflow-hidden shadow-lg relative cursor-pointer group">
                    <img ${getPartImageUrl(e.minifig_img_url || e.set_img_url)} alt="${e.name}" class="max-w-full max-h-full object-contain">
                     <div class="absolute inset-0 bg-black/40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                       ${I_Search("w-10 h-10 text-white")}
                    </div>
                 </div>
                 ${(!e.minifig_img_url && !e.set_img_url) ? `
                 <div class="mt-3 text-center">
                     <button data-action="refresh-minifig-image" class="text-xs px-3 py-1.5 bg-blue-600 hover:bg-blue-700 text-white rounded-md transition-colors">
                         ${I_Refresh("w-4 h-4 inline mr-1")} Обновить изображение
                     </button>
                 </div>
                 ` : ''}
            </div>
            <div class="lg:w-1/2 p-4 sm:p-6 flex flex-col">
                <div class="space-y-6">
                    <div>
                        <h3 class="text-md font-semibold text-gray-300 mb-3">Информация</h3>
                        <div class="space-y-1 text-sm text-gray-400">
                            <p><span class="font-semibold text-gray-300">Название:</span> ${e.name}</p>
                            <p>ID: ${e.set_num}</p>
                            <p>Кол-во деталей: ${e.num_parts}</p>
                            ${(() => {
                                const relatedSets = getRelatedSetsForMinifig(S.selFigNum);
                                console.log('Related sets for', S.selFigNum, ':', relatedSets);
                                if (relatedSets.length > 0) {
                                    return `<div class="mt-2">
                                        <button data-action="show-related-sets" class="flex items-center gap-2 px-2 py-1 text-xs font-semibold rounded-md bg-blue-600 hover:bg-blue-700 text-white transition-colors duration-150 shadow-lg hover:shadow-blue-500/25">
                                            ${I_Set("w-3 h-3")}
                                            ${relatedSets.length === 1 ? 'Связанный набор: 1' : `Связанных наборов: ${relatedSets.length}`}
                                        </button>
                                    </div>`;
                                }
                                return '';
                            })()}
                        </div>
                    </div>
                    ${l}
                </div>
            </div>
        </div>`
}
function renderMinifigModalInventoryView() {
    const {
        inv: e,
        loadingInv: t,
        invError: o,
        bulkUpdate: l,
        status: a,
        statusType: i
    } = S.minifigModal;
    const n = MINIFIG_MAP[S.selFigNum];
    let r = "";
    if (t) {
        r = `<div class="flex items-center justify-center h-full p-4"><div class="loader"></div></div>`;
    } else if (o) {
        r = `<div class="text-center p-4">
                <p class="text-red-400 mb-3">Не удалось загрузить инвентарь.</p>
                <button data-action="retry-load-minifig-inv" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700">Попробовать снова</button>
            </div>`;
    } else if (e) {
        if (e.length === 0) {
            r = `<p class="text-gray-400 text-center p-4">Инвентарь для этой минифигурки не найден.</p>`;
        } else {
            const t = e.map(e => `
                <div class="flex items-center bg-gray-700/50 p-2 rounded-md gap-3 text-sm cursor-pointer hover:bg-gray-700/70"
                     data-action="open-part-from-inventory"
                     data-part-id="${e.part.part_num}"
                     data-color-id="${e.color.id}"
                     data-quantity="${e.quantity}">
                    <div class="w-12 h-12 bg-white rounded-md flex items-center justify-center flex-shrink-0">
                        <img ${getPartImageUrl(e.part.part_img_url)} alt="${e.part.name}" class="w-full h-full object-contain p-1">
                    </div>
                    <div class="flex-grow truncate">
                        <p class="text-white font-semibold truncate">${e.part.name}</p>
                        <p class="text-gray-400 truncate">${e.part.part_num}</p>
                    </div>
                    <div class="flex items-center gap-2 flex-shrink-0">
                        <span class="w-5 h-5 rounded-full border border-gray-500 ${e.color.isTransparent?"checkerboard":""}" style="background-color: ${e.color.hex};" title="${e.color.name}"></span>
                        <span class="text-gray-300 w-8 text-right">${e.quantity}x</span>
                    </div>
                </div>`).join("");
            r = `<div class="space-y-2">${t}</div>`;
        }
    }
    return `
        <div class="p-4 space-y-4">
            <div class="flex justify-between items-center bg-gray-700/50 p-3 rounded-lg">
                <h3 class="text-lg font-semibold text-white">Инвентарь деталей</h3>
                ${l?`<div class="flex items-center gap-2 text-sm text-gray-300">
                        <div class="loader !w-4 !h-4 !border-2"></div>
                        <span>Добавление...</span>
                    </div>`: (e && e.length > 0) ? `
                    <button data-action="add-minifig-parts-modal" class="flex items-center gap-2 text-sm px-3 py-1.5 rounded-md bg-blue-600 hover:bg-blue-700 text-white transition-colors duration-150 shadow-lg hover:shadow-blue-500/25 disabled:opacity-50" ${l?"disabled":""}>
                        ${I_Plus("w-4 h-4")}
                        <span>Добавить все детали в коллекцию</span>
                    </button>`: ""}
            </div>
            ${a?`<div class="p-2 text-sm rounded-md ${"error"===i?"bg-red-900/50 text-red-300":"bg-green-900/50 text-green-300"}">${a}</div>`:""}
            ${r}
        </div>`;
}
function updateUI() {
    // Проверяем глобальный флаг блокировки
    if (window.UI_BLOCKED) {
        console.log('🚫 updateUI blocked by global flag');
        return;
    }
    
    console.log('🔄 updateUI called, view:', S.view, 'subView:', S.subView, 'loading:', S.loading);
    
    // Проверяем, продолжается ли загрузка
    const loadingContainer = document.getElementById('loading-container');
    if (loadingContainer && !loadingContainer.classList.contains('hidden')) {
        console.log('📱 Loading container visible, rendering sidebar and header');
        // Все еще загружается, но рендерим боковую панель и заголовок для возможности навигации
        renderSidebar();
        renderHeader();
        
        // Настраиваем управление боковой панелью даже во время загрузки
        setupSidebarDuringLoading();
        return;
    }
    
    // Проверяем, что данные загружены
    if (Object.keys(PART_MAP).length === 0 || Object.keys(SET_MAP).length === 0 || Object.keys(MINIFIG_MAP).length === 0) {
        console.warn('⚠️ Data not loaded yet, waiting...');
        console.log('📊 PART_MAP size:', Object.keys(PART_MAP).length);
        console.log('📦 SET_MAP size:', Object.keys(SET_MAP).length);
        console.log('👤 MINIFIG_MAP size:', Object.keys(MINIFIG_MAP).length);
        
        // Рендерим боковую панель и заголовок даже во время загрузки данных
        renderSidebar();
        renderHeader();
        setupSidebarDuringLoading();
        
        console.log('⏰ Scheduling updateUI retry in 100ms');
        setTimeout(updateUI, 100);
        return;
    }
    
    console.log('Data loaded, proceeding with UI update');
    console.log('PART_MAP size:', Object.keys(PART_MAP).length);
    console.log('Sample parts with images:', Object.values(PART_MAP).slice(0, 3).map(p => ({
        id: p.id,
        name: p.name,
        hasImage: !!(p.part_img_url || p.rebrickable_img_url)
    })));
    
    // Проверяем и применяем глобальную сортировку, если она еще не была применена
    if (!window.globalSortingApplied) {
        console.log('📅 Applying global sorting in updateUI...');
        
        // Сортируем все наборы по году (новые первыми)
        if (Object.keys(SET_MAP).length > 0) {
            console.log('📦 Sorting all sets by year in updateUI...');
            const allSets = Object.values(SET_MAP);
            allSets.sort((a, b) => {
                const yearA = parseInt(a.year) || 0;
                const yearB = parseInt(b.year) || 0;
                return yearB - yearA; // Новые первыми
            });
            console.log('✅ All sets sorted by year in updateUI');
        }
        
        // Сортируем все минифигурки по году (новые первыми)
        if (Object.keys(MINIFIG_MAP).length > 0) {
            console.log('👤 Sorting all minifigs by year in updateUI...');
            const allMinifigs = Object.values(MINIFIG_MAP);
            allMinifigs.sort((a, b) => {
                const yearA = parseInt(a.year) || 0;
                const yearB = parseInt(b.year) || 0;
                return yearB - yearA; // Новые первыми
            });
            console.log('✅ All minifigs sorted by year in updateUI');
        }
        
        // Сортируем все детали по популярности (часто используемые первыми)
        if (Object.keys(PART_MAP).length > 0) {
            console.log('🔧 Sorting all parts by popularity in updateUI...');
            const allParts = Object.values(PART_MAP);
            allParts.sort((a, b) => {
                const popularityA = parseInt(a.num_sets) || 0;
                const popularityB = parseInt(b.num_sets) || 0;
                return popularityB - popularityA; // Популярные первыми
            });
            console.log('✅ All parts sorted by popularity in updateUI');
        }
        
        window.globalSortingApplied = true;
        console.log('🎯 Global sorting applied in updateUI!');
    }
    
    renderSidebar(), renderHeader(), renderMainContent();
    
    // Обновляем статистику кнопки "Мне повезёт"
    console.log('📊 Calling updateFeelingLuckyStats from updateUI');
    updateFeelingLuckyStats();
    
    // Настраиваем слушатель событий для поискового ввода (только для обновления S.q, не для автопоиска)
    const searchInput = document.getElementById('search-input');
    if (searchInput && !searchInput.hasAttribute('data-search-listener')) {
        searchInput.setAttribute('data-search-listener', 'true');
        searchInput.addEventListener('input', (e) => {
            S.q = e.target.value;
            // Сбрасываем случайное изображение минифигурки при изменении поискового запроса
            resetRandomMinifigImage();
        });
    }
    
    // Настраиваем управление боковой панелью
    setupSidebarManagement();
    
    // Оптимизация: отключаем анимации при быстрой прокрутке
    if (!S.scrollThrottle) {
        S.scrollThrottle = true;
        let scrollTimeout;
        
        const progressEl = document.getElementById('scroll-progress');
        const progressBar = progressEl?.querySelector('.bar');
        const updateScrollTrackBounds = () => {
            const track = document.getElementById('scroll-progress');
            const header = document.getElementById('header-container');
            if (track) {
                const headerHeight = header?.offsetHeight || 0;
                const top = Math.max(12, headerHeight + 8);
                track.style.top = top + 'px';
                track.style.bottom = '12px';
            }
        };
        const getPercentForEl = (el) => {
            // Если известно общее число карточек в текущей категории — используем его
            if (typeof S?.totalItems === 'number' && S.totalItems > 0) {
                const shown = Math.min(S.loadedItems || 0, S.totalItems);
                const coverage = Math.max(0, Math.min(1, shown / S.totalItems));
                // Прогресс внутри уже загруженного участка
                const max = el.scrollHeight - el.clientHeight;
                const inner = max > 0 ? Math.min(1, Math.max(0, el.scrollTop / max)) : 1;
                const percent = coverage * 100 * inner;
                return Math.max(0, Math.min(100, percent));
            }
            // Фолбэк: только позиция прокрутки
            const max = el.scrollHeight - el.clientHeight;
            if (max <= 0) return 100;
            const scrollFraction = Math.min(1, Math.max(0, el.scrollTop / max));
            return scrollFraction * 100;
        };
        const updateScrollProgress = () => {
            let percent = 0;
            const main = document.getElementById('main-content');
            if (main) {
                // Всегда считаем от основного контейнера, если он есть
                percent = getPercentForEl(main);
            } else {
                // Фолбэк по документу, если по какой-то причине контейнер недоступен
                const doc = document.documentElement;
                const max = doc.scrollHeight - doc.clientHeight;
                if (max <= 0) {
                    percent = 100;
                } else {
                    const top = window.pageYOffset || doc.scrollTop || document.body.scrollTop || 0;
                    const scrollFraction = Math.min(1, Math.max(0, top / max));
                    percent = scrollFraction * 100;
                }
            }
            if (progressEl && progressBar) {
                const containerHeight = progressEl.clientHeight || 0;
                const barHeight = progressBar.clientHeight || 24;
                const maxOffset = Math.max(0, containerHeight - barHeight);
                const translatePx = (percent / 100) * maxOffset;
                progressBar.style.transform = `translateY(${translatePx}px)`;
            }
        };
        updateScrollTrackBounds();
        updateScrollProgress();

        // Делаем доступным для ручного обновления после перерендера контента
        window.refreshScrollProgress = updateScrollProgress;

        const onAnyScroll = () => {
            if (!document.body.classList.contains('scrolling')) {
                document.body.classList.add('scrolling');
            }
            if (progressEl) progressEl.classList.add('visible');
            updateScrollProgress();
            
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                document.body.classList.remove('scrolling');
                if (progressEl) progressEl.classList.remove('visible');
            }, 200);
        };
        window.addEventListener('scroll', onAnyScroll, { passive: true });
        const main = document.getElementById('main-content');
        if (main) main.addEventListener('scroll', onAnyScroll, { passive: true });
        // Также обновляем прогресс при изменении количества показанных карточек
        const observer = new MutationObserver(() => {
            if (typeof window.refreshScrollProgress === 'function') {
                try { window.refreshScrollProgress(); } catch {}
            }
        });
        if (main) observer.observe(main, { childList: true, subtree: true });
        window.addEventListener('resize', updateScrollTrackBounds, { passive: true });
        window.addEventListener('resize', updateScrollProgress, { passive: true });
    }
    
    // Оптимизация: отключаем анимации при изменении размера окна
    if (!S.resizeThrottle) {
        S.resizeThrottle = true;
        let resizeTimeout;
        
        window.addEventListener('resize', () => {
            if (!document.body.classList.contains('resizing')) {
                document.body.classList.add('resizing');
            }
            
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                document.body.classList.remove('resizing');
            }, 300);
        }, { passive: true });
    }
    
    // Оптимизация: отключаем анимации при быстром переключении вкладок
    if (!S.tabSwitchThrottle) {
        S.tabSwitchThrottle = true;
        let tabSwitchTimeout;
        
        const disableAnimationsOnTabSwitch = () => {
            if (!document.body.classList.contains('tab-switching')) {
                document.body.classList.add('tab-switching');
            }
            
            clearTimeout(tabSwitchTimeout);
            tabSwitchTimeout = setTimeout(() => {
                document.body.classList.remove('tab-switching');
            }, 500);
        };
        
        // Применяем оптимизацию при каждом вызове updateUI
        disableAnimationsOnTabSwitch();
    }
    
    // Оптимизация: отключаем анимации при быстром поиске
    if (S.q && S.q.length > 0) {
        document.body.classList.add('searching');
        setTimeout(() => {
            document.body.classList.remove('searching');
        }, 600);
    }
    if (S.q && S.q.length > 2) {
        document.body.classList.add('searching');
    } else {
        document.body.classList.remove('searching');
    }
    
    // Оптимизация: отключаем анимации при активной фильтрации
    if (S.filters.colorIds && S.filters.colorIds.length > 0) {
        document.body.classList.add('filtering');
    } else {
        document.body.classList.remove('filtering');
    }
    
    // Дополнительная оптимизация: отключаем анимации при фильтрации наборов
    if (S.setFilters && (S.setFilters.minYear || S.setFilters.maxYear || S.setFilters.minParts || S.setFilters.maxParts)) {
        document.body.classList.add('filtering');
    }
    
    // Оптимизация: отключаем анимации при быстрой сортировке
    if (S.sortBy && S.sortBy !== 'popularity') {
        document.body.classList.add('sorting');
    } else {
        document.body.classList.remove('sorting');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по темам
    if (S.selThemeId || S.selCollThemeId) {
        document.body.classList.add('theme-navigation');
    } else {
        document.body.classList.remove('theme-navigation');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по категориям
    if (S.selCatId || S.selCollCatId) {
        document.body.classList.add('category-navigation');
    } else {
        document.body.classList.remove('category-navigation');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции
    if (S.view === 'collection') {
        document.body.classList.add('collection-view');
    } else {
        document.body.classList.remove('collection-view');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по каталогу
    if (S.view === 'catalog') {
        document.body.classList.add('catalog-view');
    } else {
        document.body.classList.remove('catalog-view');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по минифигуркам
    if (S.subView === 'minifigs') {
        document.body.classList.add('minifigs-view');
    } else {
        document.body.classList.remove('minifigs-view');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по наборам
    if (S.subView === 'sets') {
        document.body.classList.add('sets-view');
    } else {
        document.body.classList.remove('sets-view');
    }
    // Оптимизация: отключаем анимации при быстрой навигации по деталям
    if (S.subView === 'parts') {
        document.body.classList.add('parts-view');
    } else {
        document.body.classList.remove('parts-view');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей
    if (S.view === 'collection' && S.subView === 'parts') {
        document.body.classList.add('collection-parts-view');
    } else {
        document.body.classList.remove('collection-parts-view');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции наборов
    if (S.view === 'collection' && S.subView === 'sets') {
        document.body.classList.add('collection-sets-view');
    } else {
        document.body.classList.remove('collection-sets-view');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции минифигурок
    if (S.view === 'collection' && S.subView === 'minifigs') {
        document.body.classList.add('collection-minifigs-view');
    } else {
        document.body.classList.remove('collection-minifigs-view');
    }
    // Оптимизация: отключаем анимации при быстрой навигации по каталогу деталей
    if (S.view === 'catalog' && S.subView === 'parts') {
        document.body.classList.add('catalog-parts-view');
    } else {
        document.body.classList.remove('catalog-parts-view');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по каталогу наборов
    if (S.view === 'catalog' && S.subView === 'sets') {
        document.body.classList.add('catalog-sets-view');
    } else {
        document.body.classList.remove('catalog-sets-view');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по каталогу минифигурок
    if (S.view === 'catalog' && S.subView === 'minifigs') {
        document.body.classList.add('catalog-minifigs-view');
    } else {
        document.body.classList.remove('catalog-minifigs-view');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей с фильтрацией по цветам
    if (S.view === 'collection' && S.subView === 'parts' && S.filters.colorIds && S.filters.colorIds.length > 0) {
        document.body.classList.add('collection-parts-color-filtered');
    } else {
        document.body.classList.remove('collection-parts-color-filtered');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей с фильтрацией по категориям
    if (S.view === 'collection' && S.subView === 'parts' && S.selCollCatId) {
        document.body.classList.add('collection-parts-category-filtered');
    } else {
        document.body.classList.remove('collection-parts-category-filtered');
    }
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей с фильтрацией по поиску
    if (S.view === 'collection' && S.subView === 'parts' && S.q && S.q.length > 0) {
        document.body.classList.add('collection-parts-search-filtered');
    } else {
        document.body.classList.remove('collection-parts-search-filtered');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей с фильтрацией по сортировке
    if (S.view === 'collection' && S.subView === 'parts' && S.sortBy && S.sortBy !== 'popularity') {
        document.body.classList.add('collection-parts-sort-filtered');
    } else {
        document.body.classList.remove('collection-parts-sort-filtered');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей с фильтрацией по популярности
    if (S.view === 'collection' && S.subView === 'parts' && S.sortBy && S.sortBy === 'popularity') {
        document.body.classList.add('collection-parts-popularity-filtered');
    } else {
        document.body.classList.remove('collection-parts-popularity-filtered');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей с фильтрацией по алфавиту
    if (S.view === 'collection' && S.subView === 'parts' && S.sortBy && (S.sortBy === 'alpha_asc' || S.sortBy === 'alpha_desc')) {
        document.body.classList.add('collection-parts-alpha-filtered');
    } else {
        document.body.classList.remove('collection-parts-alpha-filtered');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей с фильтрацией по релевантности
    if (S.view === 'collection' && S.subView === 'parts' && S.sortBy && S.sortBy === 'relevance') {
        document.body.classList.add('collection-parts-relevance-filtered');
    } else {
        document.body.classList.remove('collection-parts-relevance-filtered');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей с фильтрацией по всем параметрам
    if (S.view === 'collection' && S.subView === 'parts' && (S.filters.colorIds?.length > 0 || S.selCollCatId || S.q?.length > 0 || (S.sortBy && S.sortBy !== 'popularity'))) {
        document.body.classList.add('collection-parts-multi-filtered');
    } else {
        document.body.classList.remove('collection-parts-multi-filtered');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей с фильтрацией по всем параметрам и большим количеством элементов
    if (S.view === 'collection' && S.subView === 'parts' && Object.keys(S.coll).length > 200 && (S.filters.colorIds?.length > 0 || S.selCollCatId || S.q?.length > 0 || (S.sortBy && S.sortBy !== 'popularity'))) {
        document.body.classList.add('collection-parts-heavy-filtered');
    } else {
        document.body.classList.remove('collection-parts-heavy-filtered');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей с фильтрацией по всем параметрам и очень большим количеством элементов
    if (S.view === 'collection' && S.subView === 'parts' && Object.keys(S.coll).length > 500 && (S.filters.colorIds?.length > 0 || S.selCollCatId || S.q?.length > 0 || (S.sortBy && S.sortBy !== 'popularity'))) {
        document.body.classList.add('collection-parts-very-heavy-filtered');
    } else {
        document.body.classList.remove('collection-parts-very-heavy-filtered');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей с фильтрацией по всем параметрам и критически большим количеством элементов
    if (S.view === 'collection' && S.subView === 'parts' && Object.keys(S.coll).length > 1000 && (S.filters.colorIds?.length > 0 || S.selCollCatId || S.q?.length > 0 || (S.sortBy && S.sortBy !== 'popularity'))) {
        document.body.classList.add('collection-parts-critical-filtered');
    } else {
        document.body.classList.remove('collection-parts-critical-filtered');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей с фильтрацией по всем параметрам и критически большим количеством элементов и открытой боковой панелью
    if (S.view === 'collection' && S.subView === 'parts' && Object.keys(S.coll).length > 1000 && S.sidebarOpen && (S.filters.colorIds?.length > 0 || S.selCollCatId || S.q?.length > 0 || (S.sortBy && S.sortBy !== 'popularity'))) {
        document.body.classList.add('collection-parts-critical-sidebar-filtered');
    } else {
        document.body.classList.remove('collection-parts-critical-sidebar-filtered');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей с фильтрацией по всем параметрам и критически большим количеством элементов и открытой боковой панелью и быстрой прокруткой
    if (S.view === 'collection' && S.subView === 'parts' && Object.keys(S.coll).length > 1000 && S.sidebarOpen && document.body.classList.contains('scrolling') && (S.filters.colorIds?.length > 0 || S.selCollCatId || S.q?.length > 0 || (S.sortBy && S.sortBy !== 'popularity'))) {
        document.body.classList.add('collection-parts-critical-sidebar-scroll-filtered');
    } else {
        document.body.classList.remove('collection-parts-critical-sidebar-scroll-filtered');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей с фильтрацией по всем параметрам и критически большим количеством элементов и открытой боковой панелью и быстрой прокруткой и изменением размера окна
    if (S.view === 'collection' && S.subView === 'parts' && Object.keys(S.coll).length > 1000 && S.sidebarOpen && (document.body.classList.contains('scrolling') || document.body.classList.contains('resizing')) && (S.filters.colorIds?.length > 0 || S.selCollCatId || S.q?.length > 0 || (S.sortBy && S.sortBy !== 'popularity'))) {
        document.body.classList.add('collection-parts-critical-sidebar-scroll-resize-filtered');
    } else {
        document.body.classList.remove('collection-parts-critical-sidebar-scroll-resize-filtered');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей с фильтрацией по всем параметрам и критически большим количеством элементов и открытой боковой панелью и быстрой прокруткой и изменением размера окна и переключением вкладок
    if (S.view === 'collection' && S.subView === 'parts' && Object.keys(S.coll).length > 1000 && S.sidebarOpen && (document.body.classList.contains('scrolling') || document.body.classList.contains('resizing') || document.body.classList.contains('tab-switching')) && (S.filters.colorIds?.length > 0 || S.selCollCatId || S.q?.length > 0 || (S.sortBy && S.sortBy !== 'popularity'))) {
        document.body.classList.add('collection-parts-critical-sidebar-scroll-resize-tab-filtered');
    } else {
        document.body.classList.remove('collection-parts-critical-sidebar-scroll-resize-tab-filtered');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей с фильтрацией по всем параметрам и критически большим количеством элементов и открытой боковой панелью и быстрой прокруткой и изменением размера окна и переключением вкладок и поиском
    if (S.view === 'collection' && S.subView === 'parts' && Object.keys(S.coll).length > 1000 && S.sidebarOpen && (document.body.classList.contains('scrolling') || document.body.classList.contains('resizing') || document.body.classList.contains('tab-switching') || document.body.classList.contains('searching')) && (S.filters.colorIds?.length > 0 || S.selCollCatId || S.q?.length > 0 || (S.sortBy && S.sortBy !== 'popularity'))) {
        document.body.classList.add('collection-parts-critical-sidebar-scroll-resize-tab-search-filtered');
    } else {
        document.body.classList.remove('collection-parts-critical-sidebar-scroll-resize-tab-search-filtered');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей с фильтрацией по всем параметрам и критически большим количеством элементов и открытой боковой панелью и быстрой прокруткой и изменением размера окна и переключением вкладок и поиском и фильтрацией
    if (S.view === 'collection' && S.subView === 'parts' && Object.keys(S.coll).length > 1000 && S.sidebarOpen && (document.body.classList.contains('scrolling') || document.body.classList.contains('resizing') || document.body.classList.contains('tab-switching') || document.body.classList.contains('searching') || document.body.classList.contains('filtering')) && (S.filters.colorIds?.length > 0 || S.selCollCatId || S.q?.length > 0 || (S.sortBy && S.sortBy !== 'popularity'))) {
        document.body.classList.add('collection-parts-critical-sidebar-scroll-resize-tab-search-filter-filtered');
    } else {
        document.body.classList.remove('collection-parts-critical-sidebar-scroll-resize-tab-search-filter-filtered');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей с фильтрацией по всем параметрам и критически большим количеством элементов и открытой боковой панелью и быстрой прокруткой и изменением размера окна и переключением вкладок и поиском и фильтрацией и сортировкой
    if (S.view === 'collection' && S.subView === 'parts' && Object.keys(S.coll).length > 1000 && S.sidebarOpen && (document.body.classList.contains('scrolling') || document.body.classList.contains('resizing') || document.body.classList.contains('tab-switching') || document.body.classList.contains('searching') || document.body.classList.contains('filtering') || document.body.classList.contains('sorting')) && (S.filters.colorIds?.length > 0 || S.selCollCatId || S.q?.length > 0 || (S.sortBy && S.sortBy !== 'popularity'))) {
        document.body.classList.add('collection-parts-critical-sidebar-scroll-resize-tab-search-filter-sort-filtered');
    } else {
        document.body.classList.remove('collection-parts-critical-sidebar-scroll-resize-tab-search-filter-sort-filtered');
    }
    
    // Оптимизация: отключаем анимации при быстрой навигации по коллекции деталей с фильтрацией по всем параметрам и критически большим количеством элементов и открытой боковой панелью и быстрой прокруткой и изменением размера окна и переключением вкладок и поиском и фильтрацией и сортировкой и навигацией по темам
    if (S.view === 'collection' && S.subView === 'parts' && Object.keys(S.coll).length > 1000 && S.sidebarOpen && (document.body.classList.contains('scrolling') || document.body.classList.contains('resizing') || document.body.classList.contains('tab-switching') || document.body.classList.contains('searching') || document.body.classList.contains('filtering') || document.body.classList.contains('sorting') || document.body.classList.contains('theme-navigation')) && (S.filters.colorIds?.length > 0 || S.selCollCatId || S.q?.length > 0 || (S.sortBy && S.sortBy !== 'popularity'))) {
        document.body.classList.add('collection-parts-critical-sidebar-scroll-resize-tab-search-filter-sort-theme-filtered');
    } else {
        document.body.classList.remove('collection-parts-critical-sidebar-scroll-resize-tab-search-filter-sort-theme-filtered');
    }
    
    // Настраиваем обработчик клика по фону
    if (backdropEl && !backdropEl.hasAttribute('data-backdrop-listener')) {
        backdropEl.setAttribute('data-backdrop-listener', 'true');
        backdropEl.addEventListener('click', () => {
            S.sidebarOpen = false;
            updateUI();
        });
    }
    
    // Настраиваем обработчики долгого нажатия для кнопок бокового меню
    setupLongPressHandlers();
}
function generateCsvData() {
    const t = (t) => {
        if (null == t) return "";
        const o = String(t);
        return o.includes(",") || o.includes('"') || o.includes("\n") ? `"${o.replace(/"/g,'""')}"` : o
    };
    const e = [
        "type", "id", "quantity", "name",
        "part_cat_id", "part_cat_name",
        "color_id", "color_name",
        "set_theme_id", "set_theme_name", "set_year", "set_num_parts",
        "minifig_num_parts"
    ];
    let o = e.join(",") + "\n";
    for (const [partNum, colors] of Object.entries(S.coll)) {
        for (const [colorId, quantity] of Object.entries(colors)) {
            const part = PART_MAP[partNum];
            const color = COLOR_MAP[colorId];
            const category = part ? flatCategories.find(cat => cat.id === part.categoryId) : null;
            o += [
                t("part"), t(partNum), t(quantity), t(part?.name),
                t(part?.categoryId), t(category?.name),
                t(colorId), t(color?.name),
                "", "", "", "", ""
            ].join(",") + "\n";
        }
    }
    for (const [setNum, collectionInfo] of Object.entries(S.setColl)) {
        const set = SET_MAP[setNum];
        const theme = set ? THEME_MAP[set.theme_id] : null;
        o += [
            t("set"), t(setNum), t(collectionInfo.qty), t(set?.name),
            "", "", "", "",
            t(set?.theme_id), t(theme?.name), t(set?.year), t(set?.num_parts), ""
        ].join(",") + "\n";
    }
    for (const [figNum, collectionInfo] of Object.entries(S.minifigColl)) {
        const minifig = MINIFIG_MAP[figNum];
        o += [
            t("minifig"), t(figNum), t(collectionInfo.qty), t(minifig?.name),
            "", "", "", "", "", "", "", "",
            t(minifig?.num_parts)
        ].join(",") + "\n";
    }
    return o;
}
// Генерация CSV только для выбранных элементов (мультивыбор)
function generateCsvDataForSelection(selection) {
    const quote = (val) => {
        if (val == null) return "";
        const s = String(val);
        return s.includes(",") || s.includes('"') || s.includes("\n") ? `"${s.replace(/"/g,'""')}"` : s;
    };
    const headers = [
        "type", "id", "quantity", "name",
        "part_cat_id", "part_cat_name",
        "color_id", "color_name",
        "set_theme_id", "set_theme_name", "set_year", "set_num_parts",
        "minifig_num_parts"
    ];
    let csv = headers.join(",") + "\n";
    const fromCollection = (S.view === 'collection');
    
    // Детали (цветоспецифично)
    for (const { id: partNum, colorId } of selection.parts || []) {
        const part = PART_MAP[partNum];
        const color = COLOR_MAP[colorId];
        const category = part ? flatCategories.find(cat => cat.id === part.categoryId) : null;
        const qty = fromCollection ? ((S.coll?.[partNum]?.[colorId]) || 0) : 1;
        csv += [
            quote("part"), quote(partNum), quote(qty), quote(part?.name),
            quote(part?.categoryId), quote(category?.name),
            quote(colorId), quote(color?.name),
            "", "", "", "", ""
        ].join(",") + "\n";
    }
    
    // Папки (все детали в папке)
    for (const folderPartId of selection.folders || []) {
        const part = PART_MAP[folderPartId];
        const category = part ? flatCategories.find(cat => cat.id === part.categoryId) : null;
        
        if (fromCollection) {
            // Для коллекции: добавляем все цвета детали из коллекции
            const collectionColors = S.coll?.[folderPartId] || {};
            console.log(`Processing folder ${folderPartId}, collection colors:`, collectionColors);
            
            if (Object.keys(collectionColors).length > 0) {
                // Есть цвета в коллекции - добавляем их все
                for (const [colorId, qty] of Object.entries(collectionColors)) {
                    if (qty > 0) {
                        const color = COLOR_MAP[colorId];
                        csv += [
                            quote("part"), quote(folderPartId), quote(qty), quote(part?.name),
                            quote(part?.categoryId), quote(category?.name),
                            quote(colorId), quote(color?.name),
                            "", "", "", "", ""
                        ].join(",") + "\n";
                    }
                }
            } else {
                // Нет цветов в коллекции - добавляем деталь с нулевым количеством
                console.log(`Folder ${folderPartId} has no colors in collection`);
                csv += [
                    quote("part"), quote(folderPartId), quote(0), quote(part?.name),
                    quote(part?.categoryId), quote(category?.name),
                    "", "",
                    "", "", "", "", ""
                ].join(",") + "\n";
            }
        } else {
            // Если не из коллекции, добавляем деталь без цвета
            csv += [
                quote("part"), quote(folderPartId), quote(1), quote(part?.name),
                quote(part?.categoryId), quote(category?.name),
                "", "",
                "", "", "", "", ""
            ].join(",") + "\n";
        }
    }
    
    // Наборы
    for (const setNum of selection.sets || []) {
        const set = SET_MAP[setNum];
        const theme = set ? THEME_MAP[set.theme_id] : null;
        const qty = fromCollection ? ((S.setColl?.[setNum]?.qty) || 0) : 1;
        csv += [
            quote("set"), quote(setNum), quote(qty), quote(set?.name),
            "", "", "", "",
            quote(set?.theme_id), quote(theme?.name), quote(set?.year), quote(set?.num_parts), ""
        ].join(",") + "\n";
    }
    
    // Минифигурки
    for (const figNum of selection.minifigs || []) {
        const minifig = MINIFIG_MAP[figNum];
        const qty = fromCollection ? ((S.minifigColl?.[figNum]?.qty) || 0) : 1;
        csv += [
            quote("minifig"), quote(figNum), quote(qty), quote(minifig?.name),
            "", "", "", "", "", "", "", "",
            quote(minifig?.num_parts)
        ].join(",") + "\n";
    }
    
    return csv;
}
// Композитное превью PNG: слева — изображение карточки, справа — текст
async function createCompositePreviewImage(imageUrl, title, subtitle, options = {}) {
    try {
        if (!imageUrl || !imageUrl.startsWith('http')) return null;
        // Сначала пробуем через CORS-прокси (почти всегда разрешает рисовать на canvas)
        const proxiedUrl = `https://images.weserv.nl/?url=${encodeURIComponent(imageUrl)}&w=800&output=png`;
        const tryLoad = (url) => new Promise((resolve, reject) => {
            const i = new Image();
            i.crossOrigin = 'anonymous';
            i.onload = () => resolve(i);
            i.onerror = reject;
            i.src = url;
        });
        let img = await tryLoad(proxiedUrl).catch(() => null);
        if (!img) img = await tryLoad(imageUrl).catch(() => null);
        if (!img) return null;
        // Рисуем композицию (горизонтальная)
        const width = 1024, height = 576;
        const canvas = document.createElement('canvas');
        canvas.width = width; canvas.height = height;
        const ctx = canvas.getContext('2d');
        // Фон
        ctx.fillStyle = '#111827';
        ctx.fillRect(0, 0, width, height);
        // Левая область под изображение
        const pad = 40;
        const imgArea = { x: pad, y: pad, w: Math.floor(width * 0.5) - Math.floor(pad * 1.2), h: height - pad * 2 };
        // Белая плашка с мягкими углами
        const radius = 16;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(imgArea.x - 8 + radius, imgArea.y - 8);
        ctx.lineTo(imgArea.x - 8 + imgArea.w + 16 - radius, imgArea.y - 8);
        ctx.quadraticCurveTo(imgArea.x - 8 + imgArea.w + 16, imgArea.y - 8, imgArea.x - 8 + imgArea.w + 16, imgArea.y - 8 + radius);
        ctx.lineTo(imgArea.x - 8 + imgArea.w + 16, imgArea.y - 8 + imgArea.h + 16 - radius);
        ctx.quadraticCurveTo(imgArea.x - 8 + imgArea.w + 16, imgArea.y - 8 + imgArea.h + 16, imgArea.x - 8 + imgArea.w + 16 - radius, imgArea.y - 8 + imgArea.h + 16);
        ctx.lineTo(imgArea.x - 8 + radius, imgArea.y - 8 + imgArea.h + 16);
        ctx.quadraticCurveTo(imgArea.x - 8, imgArea.y - 8 + imgArea.h + 16, imgArea.x - 8, imgArea.y - 8 + imgArea.h + 16 - radius);
        ctx.lineTo(imgArea.x - 8, imgArea.y - 8 + radius);
        ctx.quadraticCurveTo(imgArea.x - 8, imgArea.y - 8, imgArea.x - 8 + radius, imgArea.y - 8);
        ctx.closePath();
        ctx.fill();
        // Вписываем картинку с сохранением пропорций
        const src = img;
        const scale = Math.min(imgArea.w / src.width, imgArea.h / src.height);
        const dw = Math.max(1, Math.floor(src.width * scale));
        const dh = Math.max(1, Math.floor(src.height * scale));
        const dx = Math.floor(imgArea.x + (imgArea.w - dw) / 2);
        const dy = Math.floor(imgArea.y + (imgArea.h - dh) / 2);
        ctx.drawImage(src, dx, dy, dw, dh);
        // Текст справа
        const textX = Math.floor(width * 0.5) + pad;
        const textW = width - textX - pad;
        ctx.fillStyle = '#ffffff';
        ctx.textBaseline = 'top';
        const drawText = (text, x, y, maxWidth, font, color = '#ffffff', lh = 0) => {
            ctx.font = font; ctx.fillStyle = color;
            const words = String(text || '').split(' ');
            let line = '', yPos = y, lineHeight = lh || (/700\s+48px/.test(font) ? 56 : 40);
            for (let n = 0; n < words.length; n++) {
                const testLine = line + (line ? ' ' : '') + words[n];
                if (ctx.measureText(testLine).width > maxWidth && n > 0) {
                    ctx.fillText(line, x, yPos);
                    line = words[n];
                    yPos += lineHeight;
                } else {
                    line = testLine;
                }
            }
            if (line) ctx.fillText(line, x, yPos);
            return yPos + lineHeight;
        };
        let nextY = drawText(title || 'LEGO Item', textX, pad, textW, '700 48px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif');
        nextY = drawText(subtitle || 'Включает:', textX, nextY + 10, textW, '400 32px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif', 'rgba(255,255,255,0.9)');
        // Цветная круглая иконка и название цвета (если передан цвет)
        if (options && options.colorHex) {
            const circleY = nextY + 14;
            const circleX = textX + 6 + 14;
            ctx.save();
            ctx.beginPath();
            ctx.arc(circleX, circleY, 14, 0, Math.PI * 2);
            ctx.closePath();
            ctx.clip();
            if (options.isTransparent) {
                // Небольшая шахматка под прозрачные цвета
                const s = 4;
                for (let yy = circleY - 16; yy < circleY + 16; yy += s) {
                    for (let xx = circleX - 16; xx < circleX + 16; xx += s) {
                        const on = ((xx + yy) / s) % 2 === 0;
                        ctx.fillStyle = on ? '#cbd5e1' : '#94a3b8';
                        ctx.fillRect(xx, yy, s, s);
                    }
                }
            }
            ctx.fillStyle = options.colorHex;
            ctx.globalAlpha = 1;
            ctx.beginPath();
            ctx.arc(circleX, circleY, 14, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            // Обводка круга
            ctx.strokeStyle = '#1f2937';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(circleX, circleY, 14, 0, Math.PI * 2);
            ctx.stroke();
            // Подпись цвета
            ctx.font = '400 24px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif';
            ctx.fillStyle = 'rgba(255,255,255,0.95)';
            const colorLabel = options.colorName ? String(options.colorName) : 'Color';
            ctx.fillText(colorLabel, circleX + 22, circleY - 12);
            nextY = Math.max(nextY, circleY + 14);
        }
        // Дополнительная мета-информация (например, количество)
        if (options && options.meta) {
            nextY = drawText(String(options.meta), textX, nextY + 12, textW, '400 24px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif', 'rgba(255,255,255,0.8)');
        }
        // Подпись сайта
        ctx.fillStyle = '#60a5fa';
        ctx.font = '500 24px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif';
        ctx.fillText('zeka3535.github.io/LEGO-Part-Catalog', textX, height - pad - 32);
        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png', 0.95));
        if (!blob) return null;
        const fname = (options && options.fileName) ? options.fileName : 'lego-item.png';
        return new File([blob], fname, { type: 'image/png' });
    } catch (e) {
        console.warn('Failed to build composite image:', e);
        return null;
    }
}
// Растровое превью PNG (текстовая заглушка), если не удалось собрать композит
async function createRasterPreviewImage(title, subtitle, options = {}) {
    try {
        const width = 1024, height = 576;
        const canvas = document.createElement('canvas');
        canvas.width = width; canvas.height = height;
        const ctx = canvas.getContext('2d');
        // Фон
        ctx.fillStyle = '#111827';
        ctx.fillRect(0, 0, width, height);
        // Заголовок
        ctx.fillStyle = '#ffffff';
        ctx.font = '700 56px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif';
        ctx.textBaseline = 'top';
        const padX = 48, padY = 80;
        const maxTitleWidth = width - padX * 2;
        const drawText = (text, x, y, maxWidth, font) => {
            ctx.font = font;
            const words = String(text).split(' ');
            let line = '', yPos = y, lineHeight = /700\s+56px/.test(font) ? 64 : 44;
            for (let n = 0; n < words.length; n++) {
                const testLine = line + (line ? ' ' : '') + words[n];
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && n > 0) {
                    ctx.fillText(line, x, yPos);
                    line = words[n];
                    yPos += lineHeight;
                } else {
                    line = testLine;
                }
            }
            if (line) ctx.fillText(line, x, yPos);
            return yPos + lineHeight;
        };
        let nextY = drawText(title || 'LEGO Item', padX, padY, maxTitleWidth, ctx.font);
        // Подзаголовок
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        nextY = drawText(subtitle || 'Включает:', padX, nextY + 8, maxTitleWidth, '400 36px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif');
        // Нижняя подпись
        ctx.fillStyle = '#60a5fa';
        ctx.font = '500 28px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif';
        ctx.fillText('zeka3535.github.io/LEGO-Part-Catalog', padX, height - 64);

        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png', 0.92));
        if (!blob) return null;
        const fname = (options && options.fileName) ? options.fileName : 'lego-item.png';
        return new File([blob], fname, { type: 'image/png' });
    } catch (e) {
        console.warn('Failed to build raster preview:', e);
        return null;
    }
}
// Функция для экспорта коллекции в CSV
function exportCollectionToCSV() {
    try {
        updateSettingsModalStatus("Подготовка CSV файла...", "info");
        
        const csvData = generateCsvData();
        
        const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = `lego-collection-${new Date().toISOString().slice(0, 10)}.csv`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        
        updateSettingsModalStatus("Экспорт CSV успешно завершен!", "success");
    } catch (e) {
        console.error("CSV Export failed:", e);
        S.settingsModal.status = `Ошибка экспорта CSV: ${e.message}`, S.settingsModal.statusType = "error";
        renderSettingsModal();
    }
}
async function processCsvData(content) {
    const t = (e, t) => {
        updateSettingsModalStatus(e, t);
        "error" !== t && setTimeout(() => {
            if (S.settingsOpen && S.settingsModal.status === e) {
                S.settingsModal.status = "";
                const statusElement = document.getElementById('import-export-status');
                if (statusElement) {
                    statusElement.classList.add('hidden');
                }
            }
        }, 3e3)
    };
    try {
        const l = content.split(/\r?\n/).filter(e => "" !== e.trim());
        if (l.length < 2) throw new Error("CSV файл пуст или содержит только заголовки.");
        const a = parseCsvLine(l[0]).map(e => e.trim().replace(/"/g, "")),
            i = ["type", "id", "quantity"];
        if (!i.every(e => a.includes(e))) throw new Error(`Неверные заголовки в CSV. Обязательные: ${i.join(", ")}.`);
        let n = {
            parts: 0,
            sets: 0,
            minifigs: 0
        };
        for (let e = 1; e < l.length; e++) {
            const csvRow = parseCsvLine(l[e]),
                row = a.reduce((acc, header, index) => {
                    acc[header] = csvRow[index] ? csvRow[index].trim() : "";
                    return acc;
                }, {});
            const {
                type,
                id,
                quantity
            } = row, qty = parseInt(quantity, 10);
            if (!type || !id || isNaN(qty) || qty <= 0) {
                console.warn(`Пропуск некорректной строки ${e+1}:`, l[e]);
                continue
            }
            switch (type) {
                case "part":
                    {
                        const {
                            color_id,
                            name,
                            part_cat_id,
                            color_name
                        } = row;
                        if (!color_id) continue;
                        S.coll[id] || (S.coll[id] = {});
                        S.coll[id][color_id] = (S.coll[id][color_id] || 0) + qty;
                        if (name && !PART_MAP[id]) {
                            PART_MAP[id] = {
                                id: id,
                                part_num: id,
                                name: name,
                                categoryId: part_cat_id ? parseInt(part_cat_id, 10) : null
                            };
                        }
                        if (color_name && !COLOR_MAP[color_id]) {
                            COLOR_MAP[color_id] = {
                                id: color_id,
                                name: color_name
                            };
                        }
                        n.parts++;
                        break;
                    }
                case "set":
                    {
                        const {
                            name,
                            set_theme_id,
                            set_year,
                            set_num_parts
                        } = row;
                        S.setColl[id] = {
                            qty: (S.setColl[id]?.qty || 0) + qty
                        };
                        // Загружаем минимальные детали, чтобы набор отображался немедленно; недостающие поля будут загружены позже
                        SET_MAP[id] = {
                            ...SET_MAP[id],
                            set_num: id,
                            name: name || (SET_MAP[id]?.name || ''),
                            theme_id: set_theme_id ? parseInt(set_theme_id, 10) : (SET_MAP[id]?.theme_id ?? null),
                            year: set_year ? parseInt(set_year, 10) : (SET_MAP[id]?.year ?? null),
                            num_parts: set_num_parts ? parseInt(set_num_parts, 10) : (SET_MAP[id]?.num_parts ?? null),
                            set_img_url: SET_MAP[id]?.set_img_url || ''
                        };
                        n.sets++;
                        break;
                    }
                case "minifig":
                    {
                        const {
                            name,
                            minifig_num_parts
                        } = row;
                        S.minifigColl[id] = {
                            qty: (S.minifigColl[id]?.qty || 0) + qty
                        };
                        // Всегда создаём объект MINIFIG_MAP[id], даже если нет имени
                        if (!MINIFIG_MAP[id]) {
                            MINIFIG_MAP[id] = {
                                set_num: id,
                                name: name || "Без названия",
                                num_parts: minifig_num_parts ? parseInt(minifig_num_parts, 10) : null
                            };
                        }
                        n.minifigs++;
                        break;
                    }
            }
        }
        saveState(), t(`Импорт CSV завершен. Добавлено: ${n.parts} деталей, ${n.sets} наборов, ${n.minifigs} минифигурок.`, "success")
    } catch (e) {
        console.error("CSV Import failed:", e), t(`Ошибка импорта CSV: ${e.message}`, "error");
        throw e;
    }
}

async function handleUpdateCollection(e, t, o) {
    S.coll[e] || (S.coll[e] = {});
    o > 0 ? S.coll[e][t] = o : (delete S.coll[e][t], 0 === Object.keys(S.coll[e]).length && delete S.coll[e]), o > 0 && !PART_MAP[e]?.colorImages && await fetchColorDetailsForPart(e), saveState(), forceSaveState(), S.gridStale = !0, "collection" === S.view ? updateUI() : (renderSidebar(), (function(){
        const card = mainEl.querySelector(`.part-card[data-part-id="${e}"]`);
        if (card && o > 0) {
            card.classList.add('collection-added');
            setTimeout(() => card.classList.remove('collection-added'), 250);
        }
    })(), mainEl.querySelector(`.part-card[data-part-id="${e}"]`)?.prepend(function() {
        const total = Object.values(S.coll[e] || {}).reduce((sum, qty) => sum + qty, 0);
        if (total > 0) {
            let el = document.createElement("div");
            el.className = "absolute top-3 right-3 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md";
            el.textContent = String(total);
            return el;
        }
        return document.createDocumentFragment();
    }()));
    // Кроме модалки: если мы в каталоге и карточка существует — ставим data-атрибут для CSS-анимации
    if (o > 0) {
        const card = mainEl.querySelector(`.part-card[data-part-id="${e}"]`);
        if (card) {
            card.setAttribute('data-collection-change', 'added');
            setTimeout(() => card.removeAttribute('data-collection-change'), 300);
        }
    }
    
    // Если деталь была добавлена и у неё нет изображения, загружаем его автоматически
    if (o > 0 && !PART_MAP[e]?.part_img_url) {
        fetchMissingImagesForCollection().catch(console.error);
    }
    
    if(S.selPartId === e) {
        updateModalControlsState();
        const button = partModalEl.querySelector(`button[data-color-id="${t}"]`);
        if (button) {
            const existingDot = button.querySelector('.w-2.h-2.bg-white.rounded-full');
            if (o > 0 && !existingDot) {
                let dot = document.createElement("div");
                const colorInfo = COLOR_MAP[t];
                const needsBlackBorder = colorInfo && (colorInfo.isTransparent || colorInfo.hex === '#FFFFFF' || colorInfo.hex === '#fff');
                dot.className = `w-2 h-2 bg-white rounded-full ${needsBlackBorder ? 'border border-black' : ''}`;
                button.appendChild(dot);
            } else if (o <= 0 && existingDot) {
                existingDot.remove();
            }
        }
    }

    // Анимация мягкого появления в режиме коллекции (после перерисовки)
    if (S.view === 'collection' && o > 0) {
        setTimeout(() => {
            const card = mainEl.querySelector(`.part-card[data-part-id="${e}"][data-color-id="${t}"]`) ||
                          mainEl.querySelector(`.part-card[data-part-id="${e}"]`);
            if (card) {
                card.classList.add('collection-added');
                card.setAttribute('data-collection-change', 'added');
                setTimeout(() => {
                    card.classList.remove('collection-added');
                    card.removeAttribute('data-collection-change');
                }, 300);
            }
        }, 0);
    }
}

function handleUpdateSetCollection(e, t) {
    const o = (S.setColl[e]?.qty || 0) > 0;
    t > 0 ? (S.setColl[e] = {
        qty: t
        }, o || (fetchAllSetInventory(e).catch(t => console.error(`Failed to proactively fetch inventory for ${e}`, t)), fetchSetMinifigs(e).catch(t => console.error(`Failed to proactively fetch minifigs for ${e}`, t)))) : delete S.setColl[e], saveState(), forceSaveState(), S.gridStale = !0, "collection" === S.view ? updateUI() : (renderSidebar(), mainEl.querySelector(`.set-card[data-set-num="${e}"]`)?.prepend(function() {
        if (t > 0) {
            let o = document.createElement("div");
            return o.className = "absolute top-3 right-3 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md", o.textContent = String(t), o
        }
        return document.createDocumentFragment()
    }())), (function(){
        const card = mainEl.querySelector(`.set-card[data-set-num="${e}"]`);
        if (card && t > 0) {
            card.classList.add('collection-added');
            card.setAttribute('data-collection-change', 'added');
            setTimeout(() => {
                card.classList.remove('collection-added');
                card.removeAttribute('data-collection-change');
            }, 300);
        }
    })(), S.selSetNum === e && updateSetModalControlsState()

    // В режиме коллекции (после updateUI) — гарантируем анимацию на карточке набора
    if (S.view === 'collection' && t > 0) {
        setTimeout(() => {
            const card = mainEl.querySelector(`.set-card[data-set-num="${e}"]`);
            if (card) {
                card.classList.add('collection-added');
                card.setAttribute('data-collection-change', 'added');
                setTimeout(() => {
                    card.classList.remove('collection-added');
                    card.removeAttribute('data-collection-change');
                }, 300);
            }
        }, 0);
    }
    
    // Если набор был добавлен и у него нет изображения, загружаем его автоматически
    if (t > 0 && !SET_MAP[e]?.set_img_url) {
        fetchMissingImagesForCollection().catch(console.error);
    }
}
async function handleUpdateMinifigCollection(e, t, o = !0) {
    const l = S.minifigColl[e]?.qty || 0,
        a = t - l;
    if (0 !== a) try {
        const t = MINIFIG_MAP[e]?.parts || await fetchMinifigParts(e);
        MINIFIG_MAP[e] && !MINIFIG_MAP[e].parts && (MINIFIG_MAP[e].parts = t), (t || []).forEach(t => {
            const o = t.part.part_num,
                l = String(t.color.id),
                i = t.quantity * a;
            S.coll[o] || (S.coll[o] = {});
            const n = S.coll[o][l] || 0,
                r = n + i;
            r > 0 ? S.coll[o][l] = r : (delete S.coll[o][l], 0 === Object.keys(S.coll[o]).length && delete S.coll[o])
        })
    } catch (i) {
        console.error(`Failed to update parts for minifig ${e}:`, i)
    }
    t > 0 ? (S.minifigColl[e] = {
        qty: t
    }, o && !MINIFIG_MAP[e]?.name && await fetchMinifigDetails(e)) : delete S.minifigColl[e], saveState(), forceSaveState(), S.gridStale = !0, "collection" === S.view ? updateUI() : (renderSidebar(), (function(){
        const card = mainEl.querySelector(`.minifig-card[data-fig-num="${e}"]`);
        if (card && t > 0) {
            card.classList.add('collection-added');
            card.setAttribute('data-collection-change', 'added');
            setTimeout(() => {
                card.classList.remove('collection-added');
                card.removeAttribute('data-collection-change');
            }, 300);
        }
    })(), mainEl.querySelector(`.minifig-card[data-fig-num="${e}"]`)?.prepend(function() {
        if (t > 0) {
            let t = document.createElement("div");
            t.className = "absolute top-3 right-3 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md", t.textContent = String(e), t
        }
        return document.createDocumentFragment();
    }()));
    S.selFigNum === e && renderMinifigModal(!1);
    if (S.selSetNum && S.setModal.minifigs.find(t => t.set_num === e)) renderSetModal(!1)
    
    // Если минифигурка была добавлена и у неё нет изображения, загружаем его автоматически
    if (t > 0 && !MINIFIG_MAP[e]?.minifig_img_url) {
        fetchMissingImagesForCollection().catch(console.error);
    }
}
async function handleBulkUpdatePartsFromSet(e, t) {
    if (S.setModal.bulkUpdate) return;
    S.setModal.bulkUpdate = !0, S.setModal.status = "", S.setModal.statusType = "", updateSetModalControlsState();
    try {
        (await fetchAllSetInventory(e) || []).forEach(e => {
            const {
                part: o,
                color: l,
                quantity: a
            } = e;
            S.coll[o.part_num] || (S.coll[o.part_num] = {});
            const i = String(l.id),
                n = S.coll[o.part_num][i] || 0;
            "add" === t ? S.coll[o.part_num][i] = n + a : n - a > 0 ? (S.coll[o.part_num][i] = n - a) : (delete S.coll[o.part_num][i], 0 === Object.keys(S.coll[o.part_num]).length && delete S.coll[o.part_num])
        });
        let o = 0,
            l = 0,
            a = 0,
            i = 0;
        const n = S.setModal.minifigs || await apiFetchPaginated(`/sets/${e}/minifigs/`);
        for (let e = 0; e < n.length; e += 3) {
            const r = n.slice(e, e + 3);
            await Promise.all(r.map(async e => {
                const n = e.set_num,
                    r = e.quantity,
                    s = S.minifigColl[n]?.qty || 0;
                "add" === t ? (S.minifigColl[n] = {
                    qty: s + r
                }, o += r) : (s - r > 0 ? S.minifigColl[n] = {
                    qty: s - r
                } : delete S.minifigColl[n], a += r);
                const fig = S.setModal.minifigs.find(f => f.set_num === n);
                const c = fig?.parts || await fetchMinifigParts(n);
                if (fig) fig.parts = c;
                (c || []).forEach(e => {
                    const o = e.part.part_num,
                        a = String(e.color.id),
                        n = e.quantity * r;
                    S.coll[o] || (S.coll[o] = {});
                    const s = S.coll[o][a] || 0;
                    "add" === t ? S.coll[o][a] = s + n : s - n > 0 ? S.coll[o][a] = s - n : (delete S.coll[o][a], 0 === Object.keys(S.coll[o]).length && delete S.coll[o]), "add" === t ? l += n : i += n
                })
            })), e + 3 < n.length && await new Promise(e => setTimeout(e, 1e3))
        }
        saveState(), forceSaveState(), await Promise.all([fetchMissingCollectionPartDetails(), ensureBasicPartImagesForCollection(), fetchColorDetailsForCollectionParts(), fetchMissingCollectionMinifigDetails()]);
        let r = "";
        "add" === t ? (r = "Детали набора успешно добавлены.", o > 0 && (r += ` ${o} минифигурок и их детали (${l} шт.) также добавлены.`)) : (r = "Детали набора успешно удалены.", a > 0 && (r += ` Также удалены ${a} минифигурок и их детали (${i} шт.).`)), S.setModal.status = r, S.setModal.statusType = "success", setTimeout(() => {
            S.selSetNum && S.setModal.status === r && (S.setModal.status = "", renderSetModal(!1))
        }, 3e3), S.gridStale = !0, updateUI()
    } catch (o) {
        console.error(`Bulk ${t} failed for set ${e}:`, o), S.setModal.status = `Ошибка: не удалось ${"add"===t?"добавить":"удалить"} детали.`, S.setModal.statusType = "error"
    } finally {
        S.setModal.bulkUpdate = !1, S.selSetNum && renderSetModal(!1)
    }
}
async function handleBulkAddMinifigParts(e) {
    const t = S.setModal.minifigs.find(t => t.set_num === e);
    if (!t || S.setModal.bulkUpdate) return;
    S.setModal.bulkUpdate = !0, S.setModal.status = `Добавление деталей из "${t.name}"...`, S.setModal.statusType = "info", renderSetModal(!1);
    try {
        let o = t.parts;
        o || (o = await fetchMinifigParts(e));
        t.parts = o;
        if (!o || 0 === o.length) throw new Error("Детали минифигурки не найдены.");
        const l = t.quantity;
        (o || []).forEach(e => {
            const t = e.part.part_num,
                o = String(e.color.id),
                l = e.quantity * l;
            S.coll[t] || (S.coll[t] = {}), S.coll[t][o] = (S.coll[t][o] || 0) + l
        }), saveState(), forceSaveState(), await Promise.all([fetchMissingCollectionPartDetails(), ensureBasicPartImagesForCollection(), fetchColorDetailsForCollectionParts()]);
        const a = `Детали из "${t.name}" (${o.length} видов) добавлены.`;
        S.setModal.status = a, S.setModal.statusType = "success", setTimeout(() => {
            S.selSetNum && S.setModal.status === a && (S.setModal.status = "", renderSetModal(!1))
        }, 3e3)
    } catch (o) {
        console.error("Error adding minifig parts:", o), S.setModal.status = "Ошибка при добавлении деталей.", S.setModal.statusType = "error"
    } finally {
        S.setModal.bulkUpdate = !1, S.selSetNum && renderSetModal(!1), "collection" === S.view && "parts" === S.subView ? (S.gridStale = !0, updateUI()) : renderSidebar()
    }
}
async function handleBulkAddMinifigPartsFromModal(e) {
    const t = MINIFIG_MAP[e];
    if (!t || S.minifigModal.bulkUpdate) return;
    S.minifigModal.bulkUpdate = !0, S.minifigModal.status = `Добавление деталей из "${t.name}"...`, S.minifigModal.statusType = "info", renderMinifigModal(!1);
    try {
        const o = S.minifigModal.inv || await fetchMinifigParts(e);
        S.minifigModal.inv = o;
        if (!o || 0 === o.length) throw new Error("Детали минифигурки не найдены.");
        (o || []).forEach(e => {
            const t = e.part.part_num,
                o = String(e.color.id),
                l = e.quantity;
            S.coll[t] || (S.coll[t] = {}), S.coll[t][o] = (S.coll[t][o] || 0) + l
        }), saveState(), forceSaveState(), await Promise.all([fetchMissingCollectionPartDetails(), ensureBasicPartImagesForCollection(), fetchColorDetailsForCollectionParts()]);
        const l = `Детали из "${t.name}" (${o.length} видов) добавлены.`;
        S.minifigModal.status = l, S.minifigModal.statusType = "success", setTimeout(() => {
            S.selFigNum && S.minifigModal.status === l && (S.minifigModal.status = "", renderMinifigModal(!1))
        }, 3e3)
    } catch (o) {
        console.error("Ошибка добавления деталей минифигурки:", o), S.minifigModal.status = "Ошибка при добавлении деталей.", S.minifigModal.statusType = "error"
    } finally {
        S.minifigModal.bulkUpdate = !1, S.selFigNum && renderMinifigModal(!1), "collection" === S.view && "parts" === S.subView ? (S.gridStale = !0, updateUI()) : renderSidebar()
    }
}
function triggerSearch(e = !1) {
    console.log('triggerSearch called with:', { e, S_q: S.q, S_subView: S.subView, S_view: S.view });
    
    // Сбрасываем случайное изображение минифигурки при поиске
    resetRandomMinifigImage();
    
    // Показываем индикатор загрузки для поиска
    if (S.q && S.q.trim().length > 0) {
        updateLoadingStatus("Поиск...", 70, `Поиск по запросу: "${S.q}"`);
    }
    
    if (!e) {
        if ("sets" === S.subView) {
            S.sortBy = S.q ? "relevance" : "year_desc";
            S.setFilters = {
                minYear: "",
                maxYear: "",
                minParts: "",
                maxParts: ""
            };
        } else if ("minifigs" === S.subView) {
            S.sortBy = S.q ? "relevance" : "name_asc";
        } else {
            S.sortBy = S.q ? "relevance" : "popularity";
            S.filters.colorIds = [];
            S.filters.inCollectionOnly = !1;
        }
    }
    // Отключаем анимации при поиске для улучшения производительности
    document.body.classList.add('searching');
    setTimeout(() => {
        document.body.classList.remove('searching');
    }, 800);
    
    S.gridStale = !0;
    if ("collection" === S.view) {
        S.selCollCatId = null;
        S.selCollThemeId = null;
        updateUI();
    } else if ("sets" === S.subView) {
        S.selThemeId = null;
        S.selFigNum = null;
        S.showRelatedSets = false;
        fetchSets();
    } else if ("minifigs" === S.subView) {
        S.selFigNum = null;
        S.showRelatedSets = false;
        fetchMinifigs();
    } else {
        S.selCatId = null;
        S.selFigNum = null;
        S.showRelatedSets = false;
        console.log('Calling searchRebrickableParts with:', S.q.trim());
        searchRebrickableParts(S.q.trim());
    }
}
function openImageViewer(e) {
    if (!e || e.includes("data:image/svg+xml")) return;
    
    // Скрываем указатель при открытии image viewer (всегда, так как это основное взаимодействие)
    hideSidebarHint();
    
    // Отменяем возможный отложенный таймер закрытия
    if (viewerEl && viewerEl._closeTimer) {
        clearTimeout(viewerEl._closeTimer);
        viewerEl._closeTimer = null;
    }

    // Устанавливаем изображение
    viewerImg.setAttribute("src", e);
    viewerEl.classList.remove("zoomed");
    viewerImg.classList.remove("zoomed");
    
    // Убираем класс viewer-hidden перед открытием
    viewerEl.classList.remove("viewer-hidden");
    
    // Открываем через modalManager
    modalManager.openModal('image-viewer-container', viewerEl);
    
    // Убираем масштабирование по клику
    viewerImg.onclick = null;
    
    // Убеждаемся, что кнопка закрытия работает
    const closeBtn = document.getElementById('image-viewer-close');
    if (closeBtn) {
        closeBtn.onclick = closeImageViewer;
        
        // Анимация появления кнопки закрытия
        closeBtn.style.opacity = '0';
        closeBtn.style.transform = 'scale(0.8) rotate(-10deg)';
        
        setTimeout(() => {
            closeBtn.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
            closeBtn.style.opacity = '1';
            closeBtn.style.transform = 'scale(1) rotate(0deg)';
        }, 200);
    }
}
function closeImageViewer() {
    // Сбрасываем изображение
    viewerImg.setAttribute("src", "");
    
    // Закрываем через modalManager
    modalManager.closeModal('image-viewer-container');
    
        // Дополнительно убеждаемся, что image viewer скрыт
    if (viewerEl) {
        viewerEl.classList.add('viewer-hidden');
        viewerEl.classList.remove('visible');
    }
}

// Функция для восстановления состояния модальных окон (упрощенная)
function restoreModalStates() {
    // Теперь modalManager сам управляет z-index
}

// Функция для восстановления обработчиков image viewer (упрощенная)
function restoreImageViewerHandlers() {
    if (!viewerEl) return;
    
    // Простое восстановление состояния
    viewerEl.classList.remove('visible', 'zoomed');
    viewerEl.classList.add('viewer-hidden');
    viewerEl.style.zIndex = '-1';
    
    // Очищаем изображение
    if (viewerImg) {
        viewerImg.src = '';
        viewerImg.classList.remove('zoomed');
    }
}

// Функция для полного сброса состояния image viewer (упрощенная)
function resetImageViewer() {
    if (!viewerEl) return;
    
    // Простое сброс состояния
    viewerEl.classList.remove('visible', 'zoomed');
    viewerEl.classList.add('viewer-hidden');
    viewerEl.style.zIndex = '-1';
    
    // Очищаем изображение
    if (viewerImg) {
        viewerImg.src = '';
        viewerImg.classList.remove('zoomed');
    }
    
    // Убираем overflow-hidden
    document.body.classList.remove('overflow-hidden');
}

// Функция для проверки и исправления состояния image viewer (упрощенная)
function checkImageViewerState() {
    if (!viewerEl) return;
    
    // Простая проверка состояния
    const isHidden = viewerEl.classList.contains('viewer-hidden');
    const isVisible = viewerEl.classList.contains('visible');
    
    // Если есть несоответствия, сбрасываем состояние
    if (isHidden && isVisible) {
        resetImageViewer();
        return true;
    }
    
    return false;
}

// Функция для принудительного восстановления всех модальных окон
function forceRestoreAllModals() {
    // Теперь используем modalManager для восстановления
    if (modalManager.getOpenModalsCount() > 0) {
        // modalManager сам управляет состоянием
    }
    
    // Убеждаемся, что image viewer не блокирует
    if (viewerEl && viewerEl.classList.contains('viewer-hidden')) {
        viewerEl.style.zIndex = '-1';
        viewerEl.style.pointerEvents = 'none';
    }
    
    // Восстанавливаем overflow-hidden для body
    document.body.classList.add('overflow-hidden');
}

function closeModal() {
    // Сбрасываем состояние
    S.selPartId = null;
    S.partModal = {
        groupId: null,
        variants: [],
        selColorId: null,
        qty: 1,
        loadingColors: !1,
        loadingImg: !1,
        imgUrl: null
    };
    
    // Закрываем модальное окно через modalManager
    modalManager.closeModal('modal-container');
}

function closeSetModal() {
    // Сбрасываем состояние
    S.selSetNum = null;
    S.setModal = {
        loading: !1,
        inv: [],
        invPage: 1,
        hasNextInv: !1,
        qty: 1,
        bulkUpdate: !1,
        status: "",
        statusType: "",
        view: "details",
        minifigs: [],
        loadingMinifigs: !1
    };
    
    // Закрываем модальное окно через modalManager
    modalManager.closeModal('set-modal-container');
}

function closeMinifigModal() {
    // Сбрасываем состояние модального окна, но НЕ сбрасываем selFigNum
    // если мы хотим показать связанные наборы
    S.minifigModal = {
        loading: !1,
        qty: 1,
        view: 'details',
        inv: null,
        loadingInv: !1,
        invError: !1,
        bulkUpdate: !1,
        status: '',
        statusType: ''
    };
    
    // Закрываем модальное окно через modalManager
    modalManager.closeModal('minifig-modal-container');
}

function closeFilterModal() {
    // Сбрасываем состояние
    S.filterOpen = false;
    
    // Сбрасываем связанные наборы при закрытии фильтров
    S.selFigNum = null;
    S.showRelatedSets = false;
    
    // Закрываем модальное окно через modalManager
    modalManager.closeModal('filter-modal-container');
}

function closeRelatedSetsModal() {
    console.log('closeRelatedSetsModal called');
    
    // Закрываем модальное окно через modalManager
    modalManager.closeModal('related-sets-modal-container');
}

function closeSettingsModal() {
    // Сбрасываем состояние
    S.settingsOpen = false;
    S.settingsModal.delConfirm = null;
    S.settingsModal.status = '';
    
    // Закрываем модальное окно через modalManager
    modalManager.closeModal('settings-modal-container');
}
function openModalForPart(e, t, o) {
    const l = PART_MAP[e];
    if (l) {
        // Скрываем указатель при открытии модального окна детали (всегда, так как это основное взаимодействие)
        hideSidebarHint();
        
        // Если открыт экран папки цветов — закрываем его при открытии модалки детали
        try { if (colorsModalEl && !colorsModalEl.classList.contains('modal-hidden')) { modalManager.closeModal('colors-modal-container'); } } catch {}
        // Если уже открыто модальное окно детали, закрываем его
        if (S.selPartId && S.selPartId !== e) {
            console.log('openModalForPart: Closing previous part modal for:', S.selPartId);
            modalManager.closeModal('modal-container');
        }
        
        // Удаляем дубликаты вариаций и гарантируем кликабельность
        let variants = Array.isArray(o) ? o : [];
        const seen = new Set();
        variants = variants.filter(v => {
            const id = v?.id || v?.part_num;
            if (!id || seen.has(id)) return false;
            seen.add(id);
            return true;
        });
        // Если текущая деталь отсутствует среди вариаций, добавим её в начало
        const currId = l.id || l.part_num;
        if (currId && !seen.has(currId)) variants.unshift(l);
        S.selPartId = e;
        S.partModal = {
            groupId: t,
            variants,
            selColorId: null,
            qty: 0,
            loadingColors: !1,
            loadingImg: !1,
            imgUrl: l.rebrickable_img_url || null
        };
        
        // Открываем модальное окно через modalManager
        modalManager.openModal('modal-container', partModalEl);
        renderModal();
        
        // Убеждаемся, что у детали есть изображение, загружаем если отсутствует
        fetchImagesForViewedItems().catch(console.error);
        
        if (l.availableColorIds) {
            if (l.availableColorIds.length > 0) {
                S.partModal.selColorId = sortColorIds(l.availableColorIds, l.id)[0];
                S.partModal.qty = S.coll[e]?.[S.partNum]?.[S.partModal.selColorId] || 0;
                updateModalPartially({
                    controls: !0
                });
                fetchPartColorSpecifics(l.id, S.partModal.selColorId);
            } else {
                fetchPartColors(l.id);
            }
        } else {
            fetchPartColors(l.id);
        }
    }
}

function setupColorsScrollProgress() {
    const track = document.getElementById('colors-scroll-progress');
    const scrollArea = document.getElementById('colors-modal-scroll');
    if (!track || !scrollArea) return;
    const update = () => {
        if (!track || !scrollArea) return;
        // Выровнять трек относительно видимой области с учётом sticky-заголовка
        const header = document.getElementById('colors-modal-header');
        const headerH = header?.offsetHeight || 0;
        const top = Math.max(12, headerH + 8);
        track.style.top = top + 'px';
        track.style.bottom = '12px';
        const max = (scrollArea.scrollHeight - scrollArea.clientHeight);
        const percent = max <= 0 ? 100 : Math.min(100, Math.max(0, (scrollArea.scrollTop / max) * 100));
        const containerH = track.clientHeight || 0;
        const bar = track.querySelector('.bar');
        const barH = bar?.clientHeight || 24;
        const maxOffset = Math.max(0, containerH - barH);
        const translatePx = (percent / 100) * maxOffset;
        if (bar) bar.style.transform = `translateY(${translatePx}px)`;
    };
    update();
    let to;
    const onScroll = () => {
        track?.classList.add('visible');
        update();
        clearTimeout(to);
        to = setTimeout(() => track?.classList.remove('visible'), 200);
    };
    scrollArea.addEventListener('scroll', onScroll, { passive: true });
    window.addEventListener('resize', () => update(), { passive: true });
}

// Специальное модальное окно: все доступные цвета выбранной детали в виде карточек
function openColorsModalForPart(partId) {
    const part = PART_MAP[partId];
    if (!part) return;
    
    // Скрываем указатель при открытии модального окна цветов (всегда, так как это основное взаимодействие)
    hideSidebarHint();
    
    const colorIds = Object.keys(S.coll[partId] || {});
    if (colorIds.length === 0 && part.availableColorIds && part.availableColorIds.length > 0) {
        // если в коллекции нет, но есть известные доступные — покажем их
        colorIds.push(...part.availableColorIds);
    }
    const unique = Array.from(new Set(colorIds));
    const entries = unique.map(cid => ({ part, color: COLOR_MAP[cid], quantity: (S.coll?.[partId]?.[cid] || 0) }));
    modalManager.openModal('colors-modal-container', colorsModalEl);
    const selCount = S.multiSelect.items?.size || 0;
    const showMultiselectBarInModal = S.multiSelect.active && S.collectionMultiSelectEnabled;
    const colorsSelBar = showMultiselectBarInModal ? `
        <div id="multiselect-bar" class="mt-3 bg-gray-800/80 border border-gray-700 rounded-lg p-2 flex items-center justify-between gap-2 flex-nowrap overflow-x-auto no-scrollbar" style="${S.multiSelect.justActivated ? 'animation: msSlideFadeIn .36s cubic-bezier(.22,.61,.36,1) both;' : ''}">
            <div class="flex items-center gap-3 flex-shrink-0">
                <button data-action="cancel-multiselect" class="text-gray-300 hover:text-white" title="Отменить мультивыбор">${I_X('w-5 h-5')}</button>
                <span class="text-sm text-gray-300">Выбрано: <strong>${selCount}</strong></span>
            </div>
            <div class="flex items-center gap-2 flex-nowrap flex-shrink-0">
                <button data-action="share-multiselect" class="flex items-center gap-2 bg-gray-700 hover:bg-gray-600 text-white text-sm font-semibold px-3 py-2 rounded-md transition-colors duration-150 shadow-lg hover:shadow-gray-500/25" title="Поделиться выбранными элементами через CSV файл и изображение">${I_Share('w-5 h-5')} <span class="hidden sm:inline">Поделиться</span></button>
                <button data-action="delete-multiselect" class="flex items-center gap-2 bg-red-600 hover:bg-red-700 text-white text-sm font-semibold px-3 py-2 rounded-md transition-colors duration-150 shadow-lg hover:shadow-red-500/25" title="Удалить выбранные элементы из коллекции">${I_Trash('w-5 h-5')} <span class="hidden sm:inline">Удалить</span></button>
            </div>
        </div>
    ` : '';
    const cards = entries.map((entry, idx) => renderPartCard(entry.part, entry.color, entry.quantity, true, idx)).join("");
    colorsModalEl.innerHTML = `
        <div class="bg-gray-900 rounded-lg shadow-xl w-[calc(100%-2rem)] max-w-5xl flex flex-col max-h-[calc(100vh-2rem)] overflow-hidden modal-content-enter">
            <div class="relative flex-grow overflow-y-auto no-scrollbar bg-gray-900" id="colors-modal-scroll">
                <div id="colors-scroll-progress"><div class="bar"></div></div>
                <div id="colors-modal-header" class="sticky top-0 z-10 bg-gray-900 p-4 border-b border-gray-700 flex flex-col gap-3">
                    <div class="flex justify-between items-center">
                        <h2 class="text-xl lg:text-2xl font-bold text-white truncate pr-4">${part.name} — ${getColorWord(unique.length)} (${unique.length})</h2>
                        <button id="colors-modal-close" class="modal-close-btn" title="Закрыть">${I_X('w-4 h-4')}</button>
                    </div>
                    ${colorsSelBar}
                </div>
                <div class="p-4">
                    <div class="bg-gray-800/60 rounded-lg p-3">
                        <div class="folder-grid">${cards}</div>
                    </div>
                </div>
            </div>
        </div>`;
    setupColorsScrollProgress();
}

function openModalForSet(e) {
    if (SET_MAP[e]) {
        // Скрываем указатель при открытии модального окна набора (всегда, так как это основное взаимодействие)
        hideSidebarHint();
        
        // Если уже открыто модальное окно набора, закрываем его
        if (S.selSetNum && S.selSetNum !== e) {
            console.log('openModalForSet: Closing previous set modal for:', S.selSetNum);
            modalManager.closeModal('set-modal-container');
        }
        
        S.selSetNum = e;
        S.setModal = {
            loading: !1,
            inv: [],
            invPage: 1,
            hasNextInv: !1,
            qty: S.setColl[e]?.qty || 0,
            bulkUpdate: !1,
            status: "",
            statusType: "",
            view: "details",
            minifigs: [],
            loadingMinifigs: !1
        };
        
        // Открываем модальное окно через modalManager
        console.log('openModalForSet: Before modalManager.openModal - current z-indexes:');
        modalManager.debugZIndexes();
        modalManager.openModal('set-modal-container', setModalEl);
        console.log('openModalForSet: After modalManager.openModal - current z-indexes:');
        modalManager.debugZIndexes();
        renderSetModal(!0);
        
        // Убеждаемся, что у набора есть изображение, загружаем если отсутствует
        fetchImagesForViewedItems().catch(console.error);
        // Автоматически загружаем весь инвентарь набора
        loadAllSetInventoryIntoModal(e);
        fetchSetMinifigs(e);
    }
}
function openModalForMinifig(e) {
    if (MINIFIG_MAP[e]) {
        // Скрываем указатель при открытии модального окна минифигурки (всегда, так как это основное взаимодействие)
        hideSidebarHint();
        
        // Если уже открыто модальное окно минифигурки, закрываем его
        if (S.selFigNum && S.selFigNum !== e) {
            console.log('openModalForMinifig: Closing previous minifig modal for:', S.selFigNum);
            modalManager.closeModal('minifig-modal-container');
        }
        
        S.selFigNum = e;
        S.minifigModal = {
            loading: !1,
            qty: S.minifigColl[e]?.qty || 0,
            view: 'details',
            inv: null,
            loadingInv: !1,
            invError: !1,
            bulkUpdate: !1,
            status: '',
            statusType: ''
        };
        
        // Открываем модальное окно через modalManager
        modalManager.openModal('minifig-modal-container', minifigModalEl);
        renderMinifigModal(!0);
        
        // Убеждаемся, что у минифигурки есть изображение, загружаем если отсутствует
        fetchImagesForViewedItems().catch(console.error);
    }
}

function refreshWithNewFilters() {
    // Отключаем анимации при изменении фильтров для улучшения производительности
    document.body.classList.add('filtering');
    setTimeout(() => {
        document.body.classList.remove('filtering');
    }, 800);
    
    S.toDisplay = S.increment, S.gridStale = !0;
    
    // Применяем фильтры и обновляем данные
    if ("collection" === S.view) {
        updateUI();
    } else if ("sets" === S.subView) {
        // Всегда перезагружаем наборы при изменении фильтров
        fetchSets();
    } else if ("minifigs" === S.subView) {
        // Всегда перезагружаем минифигурки при изменении фильтров
        fetchMinifigs();
    } else if (S.q) {
        searchRebrickableParts(S.q.trim());
    } else if (S.selCatId) {
        loadPartsForCategory(S.selCatId);
    } else {
        updateUI();
    }
}

// Обработчик события input для полей ввода в модальном окне фильтров
document.addEventListener("input", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via input event:', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});

// Обработчик события change для полей ввода в модальном окне фильтров
document.addEventListener("change", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via change event:', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});

// Обработчик события blur для полей ввода в модальном окне фильтров
document.addEventListener("blur", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via blur event:', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
}, true); // Используем capture для обработки события на фазе захвата

// Обработчик события keyup для полей ввода в модальном окне фильтров
document.addEventListener("keyup", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение при нажатии Enter или при потере фокуса
            if (e.key === 'Enter' || e.key === 'Escape') {
                tempFilters.setFilters[filterKey] = t.value;
                console.log('Filter updated via keyup event:', filterKey, '=', t.value);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
                
                // При нажатии Enter применяем фильтры
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const applyButton = filterModalEl.querySelector('[data-action="modal-apply-filters"]');
                    if (applyButton) {
                        applyButton.click();
                    }
                }
            }
        }
    }
});

// Обработчик события paste для полей ввода в модальном окне фильтров
document.addEventListener("paste", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение после вставки
            setTimeout(() => {
                tempFilters.setFilters[filterKey] = t.value;
                console.log('Filter updated via paste event:', filterKey, '=', t.value);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
            }, 0);
        }
    }
});

// Обработчик события drop для полей ввода в модальном окне фильтров
document.addEventListener("drop", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение после перетаскивания
            setTimeout(() => {
                tempFilters.setFilters[filterKey] = t.value;
                console.log('Filter updated via drop event:', filterKey, '=', t.value);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
            }, 0);
        }
    }
});
// Обработчик события compositionend для полей ввода в модальном окне фильтров
document.addEventListener("compositionend", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение после завершения композиции
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via compositionend event:', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});
// Обработчик события beforeinput для полей ввода в модальном окне фильтров
document.addEventListener("beforeinput", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Предварительно обновляем значение
            const newValue = e.data || '';
            if (newValue !== '') {
                tempFilters.setFilters[filterKey] = newValue;
                console.log('Filter updated via beforeinput event:', filterKey, '=', newValue);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
            }
        }
    }
});
// Обработчик события input для всех типов полей ввода в модальном окне фильтров
document.addEventListener("input", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via input event (all types):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});

// Обработчик события change для всех типов полей ввода в модальном окне фильтров
document.addEventListener("change", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via change event (all types):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});

// Обработчик события blur для всех типов полей ввода в модальном окне фильтров
document.addEventListener("blur", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via blur event (all types):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
}, true); // Используем capture для обработки события на фазе захвата

// Обработчик события keyup для всех типов полей ввода в модальном окне фильтров
document.addEventListener("keyup", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            if (e.key === 'Enter' || e.key === 'Escape') {
                tempFilters.setFilters[filterKey] = t.value;
                console.log('Filter updated via keyup event (all types):', filterKey, '=', t.value);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
                
                // При нажатии Enter применяем фильтры
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const applyButton = filterModalEl.querySelector('[data-action="modal-apply-filters"]');
                    if (applyButton) {
                        applyButton.click();
                    }
                }
            }
        }
    }
});
// Обработчик события paste для всех типов полей ввода в модальном окне фильтров
document.addEventListener("paste", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение после вставки для всех типов полей ввода
            setTimeout(() => {
                tempFilters.setFilters[filterKey] = t.value;
                console.log('Filter updated via paste event (all types):', filterKey, '=', t.value);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
            }, 0);
        }
    }
});

// Обработчик события drop для всех типов полей ввода в модальном окне фильтров
document.addEventListener("drop", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение после перетаскивания для всех типов полей ввода
            setTimeout(() => {
                tempFilters.setFilters[filterKey] = t.value;
                console.log('Filter updated via drop event (all types):', filterKey, '=', t.value);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
            }, 0);
        }
    }
});

// Обработчик события compositionend для всех типов полей ввода в модальном окне фильтров
document.addEventListener("compositionend", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение после завершения композиции для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via compositionend event (all types):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});
// Обработчик события beforeinput для всех типов полей ввода в модальном окне фильтров
document.addEventListener("beforeinput", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Предварительно обновляем значение для всех типов полей ввода
            const newValue = e.data || '';
            if (newValue !== '') {
                tempFilters.setFilters[filterKey] = newValue;
                console.log('Filter updated via beforeinput event (all types):', filterKey, '=', newValue);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
            }
        }
    }
});

// Обработчик события input для всех типов полей ввода в модальном окне фильтров (финальный)
document.addEventListener("input", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via input event (final):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});

// Обработчик события change для всех типов полей ввода в модальном окне фильтров (финальный)
document.addEventListener("change", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via change event (final):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});

// Обработчик события blur для всех типов полей ввода в модальном окне фильтров (финальный)
document.addEventListener("blur", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via blur event (final):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
}, true); // Используем capture для обработки события на фазе захвата

// Обработчик события keyup для всех типов полей ввода в модальном окне фильтров (финальный)
document.addEventListener("keyup", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            if (e.key === 'Enter' || e.key === 'Escape') {
                tempFilters.setFilters[filterKey] = t.value;
                console.log('Filter updated via keyup event (final):', filterKey, '=', t.value);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
                
                // При нажатии Enter применяем фильтры
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const applyButton = filterModalEl.querySelector('[data-action="modal-apply-filters"]');
                    if (applyButton) {
                        applyButton.click();
                    }
                }
            }
        }
    }
});

// Обработчик события paste для всех типов полей ввода в модальном окне фильтров (финальный)
document.addEventListener("paste", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение после вставки для всех типов полей ввода
            setTimeout(() => {
                tempFilters.setFilters[filterKey] = t.value;
                console.log('Filter updated via paste event (final):', filterKey, '=', t.value);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
            }, 0);
        }
    }
});

// Обработчик события drop для всех типов полей ввода в модальном окне фильтров (финальный)
document.addEventListener("drop", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение после перетаскивания для всех типов полей ввода
            setTimeout(() => {
                tempFilters.setFilters[filterKey] = t.value;
                console.log('Filter updated via drop event (final):', filterKey, '=', t.value);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
            }, 0);
        }
    }
});

// Обработчик события compositionend для всех типов полей ввода в модальном окне фильтров (финальный)
document.addEventListener("compositionend", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение после завершения композиции для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via compositionend event (final):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});
// Обработчик события beforeinput для всех типов полей ввода в модальном окне фильтров (финальный)
document.addEventListener("beforeinput", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Предварительно обновляем значение для всех типов полей ввода
            const newValue = e.data || '';
            if (newValue !== '') {
                tempFilters.setFilters[filterKey] = newValue;
                console.log('Filter updated via beforeinput event (final):', filterKey, '=', newValue);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
            }
        }
    }
});

// Обработчик события input для всех типов полей ввода в модальном окне фильтров (финальный - последний)
document.addEventListener("input", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via input event (final - last):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});

// Обработчик события compositionend для полей ввода в модальном окне фильтров (поддержка языков с композицией)
document.addEventListener("compositionend", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT' && t.type === 'number') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение после завершения композиции
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via compositionend event:', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});

// Обработчик события beforeinput для полей ввода в модальном окне фильтров
document.addEventListener("beforeinput", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT' && t.type === 'number') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Предварительно обновляем значение
            const newValue = e.data || '';
            if (newValue !== '') {
                tempFilters.setFilters[filterKey] = newValue;
                console.log('Filter updated via beforeinput event:', filterKey, '=', newValue);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
            }
        }
    }
});

// Обработчик события input для всех полей ввода в модальном окне фильтров
document.addEventListener("input", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via input event (all types):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});

// Обработчик события change для всех полей ввода в модальном окне фильтров
document.addEventListener("change", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via change event (all types):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});

// Обработчик события blur для всех полей ввода в модальном окне фильтров
document.addEventListener("blur", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via blur event (all types):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
}, true); // Используем capture для обработки события на фазе захвата
// Обработчик события keyup для всех полей ввода в модальном окне фильтров
document.addEventListener("keyup", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            if (e.key === 'Enter' || e.key === 'Escape') {
                tempFilters.setFilters[filterKey] = t.value;
                console.log('Filter updated via keyup event (all types):', filterKey, '=', t.value);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
                
                // При нажатии Enter применяем фильтры
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const applyButton = filterModalEl.querySelector('[data-action="modal-apply-filters"]');
                    if (applyButton) {
                        applyButton.click();
                    }
                }
            }
        }
    }
});

// Обработчик события paste для всех полей ввода в модальном окне фильтров
document.addEventListener("paste", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение после вставки для всех типов полей ввода
            setTimeout(() => {
                tempFilters.setFilters[filterKey] = t.value;
                console.log('Filter updated via paste event (all types):', filterKey, '=', t.value);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
            }, 0);
        }
    }
});
// Обработчик события drop для всех полей ввода в модальном окне фильтров
document.addEventListener("drop", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение после перетаскивания для всех типов полей ввода
            setTimeout(() => {
                tempFilters.setFilters[filterKey] = t.value;
                console.log('Filter updated via drop event (all types):', filterKey, '=', t.value);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
            }, 0);
        }
    }
});
// Обработчик события compositionend для всех полей ввода в модальном окне фильтров (поддержка языков с композицией)
document.addEventListener("compositionend", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение после завершения композиции для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via compositionend event (all types):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});
// Обработчик события beforeinput для всех полей ввода в модальном окне фильтров
document.addEventListener("beforeinput", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Предварительно обновляем значение для всех типов полей ввода
            const newValue = e.data || '';
            if (newValue !== '') {
                tempFilters.setFilters[filterKey] = newValue;
                console.log('Filter updated via beforeinput event (all types):', filterKey, '=', newValue);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
            }
        }
    }
});

// Обработчик события input для всех полей ввода в модальном окне фильтров (основной)
document.addEventListener("input", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via input event (main):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});

// Обработчик события change для всех полей ввода в модальном окне фильтров (основной)
document.addEventListener("change", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via change event (main):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});

// Обработчик события blur для всех полей ввода в модальном окне фильтров (основной)
document.addEventListener("blur", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via blur event (main):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
}, true); // Используем capture для обработки события на фазе захвата

// Обработчик события keyup для всех полей ввода в модальном окне фильтров (основной)
document.addEventListener("keyup", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            if (e.key === 'Enter' || e.key === 'Escape') {
                tempFilters.setFilters[filterKey] = t.value;
                console.log('Filter updated via keyup event (main):', filterKey, '=', t.value);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
                
                // При нажатии Enter применяем фильтры
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const applyButton = filterModalEl.querySelector('[data-action="modal-apply-filters"]');
                    if (applyButton) {
                        applyButton.click();
                    }
                }
            }
        }
    }
});

// Обработчик события paste для всех полей ввода в модальном окне фильтров (основной)
document.addEventListener("paste", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение после вставки для всех типов полей ввода
            setTimeout(() => {
                tempFilters.setFilters[filterKey] = t.value;
                console.log('Filter updated via paste event (main):', filterKey, '=', t.value);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
            }, 0);
        }
    }
});

// Обработчик события drop для всех полей ввода в модальном окне фильтров (основной)
document.addEventListener("drop", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение после перетаскивания для всех типов полей ввода
            setTimeout(() => {
                tempFilters.setFilters[filterKey] = t.value;
                console.log('Filter updated via drop event (main):', filterKey, '=', t.value);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
            }, 0);
        }
    }
});

// Обработчик события compositionend для всех полей ввода в модальном окне фильтров (основной)
document.addEventListener("compositionend", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение после завершения композиции для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via compositionend event (main):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});

// Обработчик события beforeinput для всех полей ввода в модальном окне фильтров (основной)
document.addEventListener("beforeinput", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Предварительно обновляем значение для всех типов полей ввода
            const newValue = e.data || '';
            if (newValue !== '') {
                tempFilters.setFilters[filterKey] = newValue;
                console.log('Filter updated via beforeinput event (main):', filterKey, '=', newValue);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
            }
        }
    }
});

// Обработчик события input для всех полей ввода в модальном окне фильтров (основной - все типы)
document.addEventListener("input", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via input event (main - all types):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});

// Обработчик события change для всех полей ввода в модальном окне фильтров (основной - все типы)
document.addEventListener("change", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via change event (main - all types):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});

// Обработчик события blur для всех полей ввода в модальном окне фильтров (основной - все типы)
document.addEventListener("blur", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via blur event (main - all types):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
}, true); // Используем capture для обработки события на фазе захвата

// Обработчик события keyup для всех полей ввода в модальном окне фильтров (основной - все типы)
document.addEventListener("keyup", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение для всех типов полей ввода
            if (e.key === 'Enter' || e.key === 'Escape') {
                tempFilters.setFilters[filterKey] = t.value;
                console.log('Filter updated via keyup event (main - all types):', filterKey, '=', t.value);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
                
                // При нажатии Enter применяем фильтры
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const applyButton = filterModalEl.querySelector('[data-action="modal-apply-filters"]');
                    if (applyButton) {
                        applyButton.click();
                    }
                }
            }
        }
    }
});

// Обработчик события paste для всех полей ввода в модальном окне фильтров (основной - все типы)
document.addEventListener("paste", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение после вставки для всех типов полей ввода
            setTimeout(() => {
                tempFilters.setFilters[filterKey] = t.value;
                console.log('Filter updated via paste event (main - all types):', filterKey, '=', t.value);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
            }, 0);
        }
    }
});
// Обработчик события drop для всех полей ввода в модальном окне фильтров (основной - все типы)
document.addEventListener("drop", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение после перетаскивания для всех типов полей ввода
            setTimeout(() => {
                tempFilters.setFilters[filterKey] = t.value;
                console.log('Filter updated via drop event (main - all types):', filterKey, '=', t.value);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
            }, 0);
        }
    }
});
// Обработчик события compositionend для всех полей ввода в модальном окне фильтров (основной - все типы)
document.addEventListener("compositionend", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Обновляем значение после завершения композиции для всех типов полей ввода
            tempFilters.setFilters[filterKey] = t.value;
            console.log('Filter updated via compositionend event (main - all types):', filterKey, '=', t.value);
            console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        }
    }
});

// Обработчик события beforeinput для всех полей ввода в модальном окне фильтров (основной - все типы)
document.addEventListener("beforeinput", e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Проверяем, находится ли поле ввода в модальном окне фильтров
    if (filterModalEl?.contains(t) && t.tagName === 'INPUT') {
        const filterKey = t.dataset.filterKey;
        if (filterKey && tempFilters && tempFilters.setFilters) {
            // Предварительно обновляем значение для всех типов полей ввода
            const newValue = e.data || '';
            if (newValue !== '') {
                tempFilters.setFilters[filterKey] = newValue;
                console.log('Filter updated via beforeinput event (main - all types):', filterKey, '=', newValue);
                console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
            }
        }
    }
});
document.addEventListener("click", async e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    
    // Логируем все клики для отладки
    console.log('🖱️ Click detected on:', t.tagName, t.className, t.dataset);
    // Мультивыбор: переключение
    const selBtn = t.closest('[data-action="toggle-select"]');
    if (selBtn) {
        const type = selBtn.dataset.itemType;
        const id = selBtn.dataset.itemId;
        const colorId = selBtn.dataset.colorId || '';
        if (!type || !id) return;
        if (!S.multiSelect.active) { S.multiSelect.active = !0; S.multiSelect.justActivated = !0; }
        const key =
            type === 'part' ? `parts:${id}:${colorId}` :
            (type === 'part-folder' ? `parts-folder:${id}` :
            (type === 'set' ? `sets:${id}` : `minifigs:${id}`));
        if (S.multiSelect.items.has(key)) S.multiSelect.items.delete(key); else S.multiSelect.items.add(key);
        if (S.multiSelect.items.size === 0) { S.multiSelect.active = !1; S.multiSelect.justActivated = !1; }
        renderHeader();
        // Сбрасываем флаг первой анимации после рендера, чтобы не анимировать при добавлении второй и далее
        queueMicrotask(() => { S.multiSelect.justActivated = !1; });
        updateUI();
        return;
    }
    if (t.closest('#toggle-catalog-multiselect')) {
        S.catalogMultiSelectEnabled = !S.catalogMultiSelectEnabled;
        localStorage.setItem('catalogMultiSelectEnabled', String(S.catalogMultiSelectEnabled));
        // При выключении скрываем панель мультивыбора и сбрасываем выбранные элементы
        if (!S.catalogMultiSelectEnabled) { S.multiSelect.active = false; S.multiSelect.items = new Set(); }
        renderHeader();
        updateUI();
        return;
    }
    if (t.closest('#toggle-collection-multiselect')) {
        S.collectionMultiSelectEnabled = !S.collectionMultiSelectEnabled;
        localStorage.setItem('collectionMultiSelectEnabled', String(S.collectionMultiSelectEnabled));
        if (!S.collectionMultiSelectEnabled) { S.multiSelect.active = false; S.multiSelect.items = new Set(); }
        renderHeader();
        updateUI();
        return;
    }
    
    // Проверяем, не заблокирован ли клик image viewer
    if (viewerEl && !viewerEl.classList.contains("viewer-hidden") && !t.closest("#image-viewer-container")) {
        // Если image viewer открыт и клик не по нему, игнорируем
        return;
    }
    
    // Проверяем, не заблокированы ли модальные окна
    if (viewerEl && viewerEl.classList.contains("viewer-hidden")) {
        // Если image viewer закрыт, но модальные окна не работают, восстанавливаем их
        const activeModals = [
            { el: partModalEl, sel: S.selPartId },
            { el: setModalEl, sel: S.selSetNum },
            { el: minifigModalEl, sel: S.selFigNum },
            { el: filterModalEl, sel: S.filterOpen },
            { el: settingsModalEl, sel: S.settingsOpen },
            { el: relatedSetsModalEl, sel: !relatedSetsModalEl.classList.contains("modal-hidden") }
        ];
        
        const hasActiveModal = activeModals.some(modal => modal.sel);
        if (hasActiveModal) {
            restoreModalStates();
        }
    }
    
    const o = t.closest('[data-action="view-image-fullscreen"]');
    if (o?.dataset.imageUrl) return openImageViewer(o.dataset.imageUrl);
    
    // Кнопка "Мне повезёт!"
    if (t.closest('#feeling-lucky-button')) {
        e.preventDefault();
        e.stopPropagation();
        return handleFeelingLucky();
    }
    
    // Открытие модалки детали из инвентаря набора/минифигурки
    const invPartEl = t.closest('[data-action="open-part-from-inventory"]');
    const clickedActionEl = t.closest('[data-action]');
    const clickedAction = clickedActionEl?.dataset.action;
    if (invPartEl && (!clickedAction || clickedAction === 'open-part-from-inventory')) {
        const pid = invPartEl.getAttribute('data-part-id');
        const cid = invPartEl.getAttribute('data-color-id');
        const qty = parseInt(invPartEl.getAttribute('data-quantity') || '0');
        if (pid && cid) {
            const part = PART_MAP[pid] || PART_MAP[String(pid)];
            if (part) {
                const groupId = getGroupId(part.part_num || pid);
                openModalForPart(part.id || part.part_num || pid, groupId, [part]);
                
                // Временно поднимаем модальное окно детали на самый верх
                setTimeout(() => {
                    modalManager.bringToFront('modal-container');
                }, 100);
                
                S.partModal.selColorId = String(cid);
                S.partModal.qty = S.coll[part.id]?.[S.partModal.selColorId] || 0;
                updateModalPartially({ controls: !0, image: !0 });
                fetchPartColorSpecifics(part.id, S.partModal.selColorId);
            }
        }
        return;
    }
    
    // Открытие модалки минифигурки из инвентаря набора
    const invFigEl = t.closest('[data-action="open-minifig-from-inventory"]');
    if (invFigEl && (!clickedAction || clickedAction === 'open-minifig-from-inventory')) {
        const figNum = invFigEl.getAttribute('data-fig-num');
        if (figNum) {
            openModalForMinifig(figNum);
            
            // Временно поднимаем модальное окно минифигурки на самый верх
            setTimeout(() => {
                modalManager.bringToFront('minifig-modal-container');
            }, 100);
        }
        return;
    }
    
    // Открытие модалки минифигурки из превью в заголовке связанных наборов
    const minifigPreviewEl = t.closest('[data-action="open-minifig-preview"]');
    if (minifigPreviewEl && (!clickedAction || clickedAction === 'open-minifig-preview')) {
        const figNum = minifigPreviewEl.getAttribute('data-fig-num');
        if (figNum) {
            openModalForMinifig(figNum);
            
            // Временно поднимаем модальное окно минифигурки на самый верх
            setTimeout(() => {
                modalManager.bringToFront('minifig-modal-container');
            }, 100);
        }
        return;
    }
    
    // Обработка кнопки закрытия image viewer (всегда работает)
    if (t.closest("#image-viewer-close")) {
        animateCloseButtonClick(t.closest("#image-viewer-close"));
        return closeImageViewer();
    }
    
    if ("image-viewer-container" === t.id) return closeImageViewer();
    const l = t.closest('[data-action="toggle-favorite-category"]');
    if (l?.dataset.categoryId) {
        e.stopPropagation();
        const t = parseInt(l.dataset.categoryId, 10);
        return S.favCatIds.has(t) ? S.favCatIds.delete(t) : S.favCatIds.add(t), saveState(), void renderSidebar()
    }
    const a = t.closest('[data-action="toggle-favorite-theme"]');
    if (a?.dataset.themeId) {
        e.stopPropagation();
        const t = parseInt(a.dataset.themeId, 10);
        return S.favThemeIds.has(t) ? S.favThemeIds.delete(t) : S.favThemeIds.add(t), saveState(), void renderSidebar()
    }
    if (t.closest("#scroll-to-top-btn")) return mainEl.scrollTo({
        top: 0,
        behavior: "smooth"
    });
    if (t.closest("#sidebar-toggle")) {
        if (window.innerWidth >= 1024) {
            // На больших экранах кнопка не работает - панель всегда открыта
            return;
        }
        
        // Анимация кнопки при клике
        const sidebarToggleBtn = t.closest("#sidebar-toggle");
        if (sidebarToggleBtn) {
            sidebarToggleBtn.style.transform = 'scale(0.9) rotate(-2deg)';
            setTimeout(() => {
                sidebarToggleBtn.style.transform = 'scale(1) rotate(0deg)';
            }, 150);
        }
        
        // Разрешаем открытие боковой панели даже во время загрузки данных
        S.sidebarOpen = !S.sidebarOpen;
        
        // Скрываем указатель при открытии боковой панели
        if (S.sidebarOpen) {
            hideSidebarHint();
        }
        
        updateUI();
    }
    if (t.closest("#sidebar-close")) {
        if (window.innerWidth >= 1024) {
            // На больших экранах кнопка не работает - панель всегда открыта
            return;
        }
        
        // Анимация кнопки при клике
        const sidebarCloseBtn = t.closest("#sidebar-close");
        if (sidebarCloseBtn) {
            sidebarCloseBtn.style.transform = 'scale(0.9) rotate(2deg)';
            setTimeout(() => {
                sidebarCloseBtn.style.transform = 'scale(1) rotate(0deg)';
            }, 150);
        }
        
        // Разрешаем закрытие боковой панели даже во время загрузки данных
        S.sidebarOpen = false;
        updateUI();
        
        // Скрываем указатель при закрытии боковой панели
        hideSidebarHint();
    }
    if ("sidebar-backdrop" === t.id) {
        if (window.innerWidth >= 1024) {
            // На больших экранах backdrop не работает - панель всегда открыта
            return;
        }
        // Разрешаем закрытие боковой панели через backdrop даже во время загрузки данных
        S.sidebarOpen = false;
        updateUI();
        
        // Скрываем указатель при закрытии боковой панели
        hideSidebarHint();
    }
    
    // Кнопки "Показать еще" удалены — обработчик не нужен
    const i = t.closest("[data-view]");
    if (i?.dataset.view) {
        const e = i.dataset.view;
        if (S.view === e) return;
        
        // Показываем индикатор загрузки при переключении представлений
        if (e === 'collection' && Object.keys(S.coll).length > 0) {
            updateLoadingStatus("Переключение на коллекцию...", 50, "Загрузка данных коллекции");
        } else if (e === 'catalog') {
            updateLoadingStatus("Переключение на каталог...", 50, "Загрузка каталога");
        }
        
        // Отключаем анимации при переключении вкладок для улучшения производительности
        document.body.classList.add('tab-switching');
        setTimeout(() => {
            document.body.classList.remove('tab-switching');
        }, 1000);
        
        // Сбрасываем мультивыбор только при переключении Каталог/Коллекция
        S.multiSelect.active = false; S.multiSelect.items = new Set();
        
        // Скрываем указатель при переключении представлений (только если нет активных модальных окон)
        const activeModal = document.querySelector('[id$="-modal-container"]:not(.modal-hidden)');
        if (!activeModal) {
            hideSidebarHint();
        }
        
        // Сохраняем selFigNum только если переключаемся на каталог и вкладку "Наборы"
        const shouldKeepSelFigNum = (e === 'catalog' && S.subView === 'sets' && S.selFigNum);
        const newSelFigNum = shouldKeepSelFigNum ? S.selFigNum : null;
        
        // Если переключаемся на каталог, принудительно закрываем все модальные окна
        if (e === 'catalog') {
            console.log('Switching to catalog, force closing all modals');
            modalManager.closeAllModals();
            
            // Скрываем указатель при переключении на каталог (всегда, так как закрываем все модальные окна)
            hideSidebarHint();
            
            // Дополнительно принудительно закрываем все модальные окна
            const allModals = [
                'modal-container',
                'set-modal-container', 
                'minifig-modal-container',
                'filter-modal-container',
                'settings-modal-container',
                'related-sets-modal-container'
            ];
            
            allModals.forEach(modalId => {
                const modalEl = document.getElementById(modalId);
                if (modalEl && !modalEl.classList.contains('modal-hidden')) {
                    console.log(`Force closing modal: ${modalId}`);
                    modalEl.classList.add('modal-hidden');
                    modalEl.classList.remove('visible');
                    modalEl.innerHTML = '';
                }
            });
            
            // Убираем overflow-hidden
            document.body.classList.remove('overflow-hidden');
        }
        
        // Сбрасываем случайное изображение минифигурки при переключении представлений
        resetRandomMinifigImage();
        
        // Останавливаем автоматическую смену подсказок при переключении представлений
        if (window.stopTipRotation) {
            window.stopTipRotation();
        }
        
        return S.view = e, S.q = "", S.err = null, S.gridStale = !0, S.selCatId = null, S.selCollCatId = null, S.selThemeId = null, S.selCollThemeId = null, S.selFigNum = newSelFigNum, void("catalog" === S.view && "minifigs" === S.subView && !S.minifigRes ? fetchMinifigs() : (updateUI(), setupScrollListener(), setTimeout(() => {
            // НЕ перезапускаем ротацию подсказок - это создает бесконечный цикл!
            console.log('⚠️ Skipping tip rotation restart to prevent infinite loop');
        }, 1000)))
    }
    const n = t.closest("[data-sub-view]");
    if (n?.dataset.subView) {
        // Проверяем, не было ли долгого нажатия на эту кнопку
        if (n.hasAttribute('data-long-press-triggered') || S.longPressTriggered) {
            console.log('🚫 Blocking click after long press on:', n.dataset.subView);
            console.log('🚫 Flags:', { 
                hasAttribute: n.hasAttribute('data-long-press-triggered'), 
                globalFlag: S.longPressTriggered 
            });
            n.removeAttribute('data-long-press-triggered');
            S.longPressTriggered = false; // Сбрасываем глобальный флаг
            return;
        }
        
        const e = n.dataset.subView;
        if (S.subView === e) return;
        
        // Показываем индикатор загрузки при переключении подпредставлений
        if (e === 'minifigs') {
            updateLoadingStatus("Переключение на минифигурки...", 60, "Загрузка данных минифигурок");
            // Сбрасываем случайное изображение минифигурки при переключении на вкладку минифигурок
            resetRandomMinifigImage();
        } else if (e === 'sets') {
            updateLoadingStatus("Переключение на наборы...", 60, "Загрузка данных наборов");
        } else if (e === 'parts') {
            updateLoadingStatus("Переключение на детали...", 60, "Загрузка данных деталей");
        }
        
        // Отключаем анимации при переключении подвкладок для улучшения производительности
        document.body.classList.add('tab-switching');
        setTimeout(() => {
            document.body.classList.remove('tab-switching');
        }, 1000);
        
        // Скрываем указатель при переключении подпредставлений (только если нет активных модальных окон)
        const activeModal = document.querySelector('[id$="-modal-container"]:not(.modal-hidden)');
        if (!activeModal) {
            hideSidebarHint();
        }
        
        S.subView = e;
        
        // Останавливаем автоматическую смену подсказок при переключении вкладок
        if (window.stopTipRotation) {
            window.stopTipRotation();
        }
        
        // Сбрасываем выбранную минифигурку при переключении на другие вкладки
        if (e !== 'sets') {
            S.selFigNum = null;
            S.showRelatedSets = false;
        }
        S.q = "";
        S.err = null;
        S.increment = "minifigs" === e ? 36 : 48;
        S.toDisplay = S.increment;
        S.gridStale = !0;
        S.filters = { colorIds: [], inCollectionOnly: !1 };
        S.setFilters = { minYear: "", maxYear: "", minParts: "", maxParts: "" };
        S.selCatId = null;
        S.selCollCatId = null;
        S.selThemeId = null;
        S.selCollThemeId = null;
        S.searchGroups = null;
        S.catGroups = null;
        S.setRes = null;
        S.searchSetRes = null;
        S.minifigRes = null;
        S.searchMinifigRes = null;
        
        if ("sets" === e) {
            S.sortBy = "year_desc";
        } else if ("minifigs" === e) {
            S.sortBy = "name_asc";
        } else {
            S.sortBy = "popularity";
        }
        
        if ("catalog" === S.view && "minifigs" === e && !S.minifigRes) {
            fetchMinifigs();
            
            // Восстанавливаем состояние кнопки "Мне повезёт" после загрузки данных в каталоге
            setTimeout(() => {
                const button = document.getElementById('feeling-lucky-button');
                const icon = document.getElementById('feeling-lucky-icon');
                const text = document.getElementById('feeling-lucky-text');
                
                if (button && icon && text) {
                    button.disabled = false;
                    button.classList.remove('opacity-75', 'cursor-not-allowed');
                    icon.innerHTML = I_Dice("w-6 h-6");
                    text.textContent = 'Мне повезёт!';
                }
            }, 500);
        } else if ("minifigs" === e && S.view === "collection" && Object.keys(S.minifigColl).length > 0) {
            fetchMissingCollectionMinifigDetails().then(() => { 
                S.gridStale = true; 
                updateUI(); 
                // Обновляем статистику после загрузки данных
                setTimeout(() => updateFeelingLuckyStats(), 300);
                
                // Восстанавливаем состояние кнопки "Мне повезёт" после загрузки данных
                setTimeout(() => {
                    const button = document.getElementById('feeling-lucky-button');
                    const icon = document.getElementById('feeling-lucky-icon');
                    const text = document.getElementById('feeling-lucky-text');
                    
                    if (button && icon && text) {
                        button.disabled = false;
                        button.classList.remove('opacity-75', 'cursor-not-allowed');
                        icon.innerHTML = I_Dice("w-6 h-6");
                        text.textContent = 'Мне повезёт!';
                    }
                }, 400);
            }).catch(console.error);
        } else {
            updateUI();
        }
        
        // Если мы в каталоге и переключаемся между вкладками, вызываем функцию открытия каталога
        if (S.view === "catalog") {
            // Делаем то же самое, что и кнопка "Каталог"
            console.log('Switching tabs in catalog, refreshing catalog state');
            
            // Сбрасываем мультивыбор
            S.multiSelect.active = false; 
            S.multiSelect.items = new Set();
            
            // Сбрасываем случайное изображение минифигурки
            resetRandomMinifigImage();
            
            // Обновляем UI
            updateUI();
            
            // Настраиваем слушатель прокрутки
            setupScrollListener();
            
            // Восстанавливаем состояние кнопки "Мне повезёт" при переключении вкладок в каталоге
            setTimeout(() => {
                const button = document.getElementById('feeling-lucky-button');
                const icon = document.getElementById('feeling-lucky-icon');
                const text = document.getElementById('feeling-lucky-text');
                
                if (button && icon && text) {
                    button.disabled = false;
                    button.classList.remove('opacity-75', 'cursor-not-allowed');
                    icon.innerHTML = I_Dice("w-6 h-6");
                    text.textContent = 'Мне повезёт!';
                }
            }, 300);
        }
        
        // Обновляем статистику кнопки "Мне повезёт" после смены представления
        setTimeout(() => {
            console.log('📊 Updating feeling lucky stats after view change');
            updateFeelingLuckyStats();
            // НЕ перезапускаем ротацию подсказок - это создает бесконечный цикл!
        }, 200);
        
        // Настраиваем слушатель прокрутки для автоматической загрузки изображений
        setupScrollListener();
        return;
    }
    // Обработка сворачивания/разворачивания сводки коллекции
    if (t.closest('#collection-summary-toggle')) {
        S.collectionSummaryExpanded = !S.collectionSummaryExpanded;
        // Сохраняем состояние в localStorage
        localStorage.setItem('collectionSummaryExpanded', String(S.collectionSummaryExpanded));
        // Перерисовываем боковую панель для обновления UI
        renderSidebar();
        return;
    }
    
    if (t.closest('[data-action="show-all-collection-items"]') || t.closest('[data-action="show-all-items-parts"]')) {
        // Сброс фильтров "все детали" и перерисовка
        // Сбрасываем случайное изображение минифигурки при показе всех деталей
        resetRandomMinifigImage();
        
        if (S.view === 'collection') {
            document.body.classList.add('collection-view');
            setTimeout(() => document.body.classList.remove('collection-view'), 800);
            if (S.subView === 'parts') S.selCollCatId = null;
            if (S.subView === 'sets') S.selCollThemeId = null;
            S.gridStale = true;
            updateUI();
        } else {
            document.body.classList.add('catalog-view');
            setTimeout(() => document.body.classList.remove('catalog-view'), 800);
            // Показать все детали в каталоге
            S.view = 'catalog';
            S.subView = 'parts';
            S.selCatId = null;
            S.selFigNum = null;
            S.showRelatedSets = false;
            S.q = '';
            try {
                const allParts = Object.values(PART_MAP).filter(Boolean);
                S.searchGroups = groupParts(allParts);
                // Инициализируем общее количество всех деталей в каталоге
                S.totalPartsInCatalog = allParts.length;
            } catch (err) {
                console.warn('Failed to build all parts groups, falling back to UI update only', err);
                S.searchGroups = {};
                S.totalPartsInCatalog = 0;
            }
            S.gridStale = true;
            updateUI();
            // Обновляем статистику после смены на каталог деталей
            setTimeout(() => updateFeelingLuckyStats(), 300);
        }
        return;
    }
    if (t.closest('[data-action="show-all-items-sets"]')) {
        // В каталоге: показать все наборы
        // Сбрасываем случайное изображение минифигурки при показе всех наборов
        resetRandomMinifigImage();
        
        S.view = 'catalog';
        S.subView = 'sets';
        S.selThemeId = null;
        S.selFigNum = null;
        S.showRelatedSets = false;
        S.q = '';
        S.gridStale = true;
        fetchSets();
        return;
    }
    const r = t.closest("[data-theme-id]");
    if (r?.dataset.themeId) {
        const e = parseInt(r.dataset.themeId, 10),
            t = THEME_MAP[e],
            o = t && Array.isArray(t.children) && t.children.length > 0;
        if (o) {
            S.expThemes.has(e) ? S.expThemes.delete(e) : S.expThemes.add(e)
        }
        if ("collection" === S.view) {
            // Отключаем анимации при навигации по коллекции тем для улучшения производительности
            document.body.classList.add('collection-view');
            setTimeout(() => {
                document.body.classList.remove('collection-view');
            }, 800);
            
            S.selCollThemeId !== e && (S.selCollThemeId = e, S.gridStale = !0, updateUI());
        }
        else if (S.selThemeId !== e) {
            // Отключаем анимации при навигации по темам для улучшения производительности
            document.body.classList.add('theme-navigation');
            setTimeout(() => {
                document.body.classList.remove('theme-navigation');
            }, 800);
            
            // Сбрасываем случайное изображение минифигурки при навигации по темам
            resetRandomMinifigImage();
            
            S.selThemeId = e, S.selFigNum = null, S.showRelatedSets = false, S.q = "", S.sortBy = "year_desc", S.setFilters = {
                minYear: "",
                maxYear: "",
                minParts: "",
                maxParts: ""
            };
            fetchSets()
        }
        return void(o && renderSidebar())
    }
    const s = t.closest("[data-parent-category]");
    if (s?.dataset.parentCategory) {
        const e = s.dataset.parentCategory,
            t = S.expCats.has(e);
        return t ? S.expCats.delete(e) : S.expCats.add(e), void renderSidebar()
    }
    const c = t.closest("[data-category-id]");
    if (c?.dataset.categoryId) {
        const e = parseInt(c.dataset.categoryId, 10);
        // Отключаем анимации при навигации по категориям для улучшения производительности
        document.body.classList.add('category-navigation');
        setTimeout(() => {
            document.body.classList.remove('category-navigation');
        }, 800);
        
        return S.q = "", S.selFigNum = null, S.showRelatedSets = false, "collection" === S.view ? (() => {
            // Отключаем анимации при навигании по коллекции категорий для улучшения производительности
            document.body.classList.add('collection-view');
            setTimeout(() => {
                document.body.classList.remove('collection-view');
            }, 800);
            
            S.selCollCatId !== e && (S.selCollCatId = e, S.gridStale = !0, updateUI());
        })() : (() => {
            // Сбрасываем случайное изображение минифигурки при навигации по категориям
            resetRandomMinifigImage();
            
            S.selCatId !== e && (S.selCatId = e, S.filters = {
                colorIds: [],
                inCollectionOnly: !1
            }, S.sortBy = "popularity", loadPartsForCategory(e));
            return void 0;
        })();
    }
    
    const d = t.closest('[data-action="delete-from-collection"]');
    if (d?.dataset.partId && d.dataset.colorId) return await handleUpdateCollection(d.dataset.partId, d.dataset.colorId, 0);
    const delFolderBtn = t.closest('[data-action="delete-folder-from-collection"]');
    if (delFolderBtn) {
        const pid = delFolderBtn.getAttribute('data-part-id');
        if (pid && S.coll[pid]) {
            const colors = Object.keys(S.coll[pid]);
            for (const cid of colors) {
                await handleUpdateCollection(pid, cid, 0);
            }
        }
        return;
    }
    
    // Обработка кнопки закрытия папки
    const closeFolderBtn = t.closest('[data-action="close-folder"]');
    if (closeFolderBtn) {
        const pid = closeFolderBtn.getAttribute('data-part-id');
        if (pid) {
            // Закрываем папку, удаляя её из expandedFolders
            if (!S.expandedFolders) S.expandedFolders = new Set();
            S.expandedFolders.delete(String(pid));
            S.gridStale = true;
            updateUI();
        }
        return;
    }
    const u = t.closest(".minifig-card");
    if (u?.dataset.figNum) {
        const delFigBtn = t.closest('[data-action="delete-minifig-from-collection"]');
        if (delFigBtn) {
            const num = delFigBtn.dataset.figNum;
            if (num) handleUpdateMinifigCollection(num, 0, false);
            return;
        }
        const selFigBtn = t.closest('[data-action="toggle-select"]');
        if (selFigBtn) return; // обработано выше
        
        // Открываем модальное окно минифигурки (и в каталоге, и в коллекции)
        openModalForMinifig(u.dataset.figNum);
        
        // Временно поднимаем модальное окно минифигурки на самый верх
        setTimeout(() => {
            modalManager.bringToFront('minifig-modal-container');
        }, 100);
        return;
    }
    const g = t.closest(".set-card");
    if (g?.dataset.setNum) {
        const delSetBtn = t.closest('[data-action="delete-set-from-collection"]');
        if (delSetBtn) {
            const num = delSetBtn.dataset.setNum;
            if (num) handleUpdateSetCollection(num, 0);
            return;
        }
        const selSetBtn = t.closest('[data-action="toggle-select"]');
        if (selSetBtn) return; // обработано выше
        openModalForSet(g.dataset.setNum);
        
        // Временно поднимаем модальное окно набора на самый верх
        setTimeout(() => {
            modalManager.bringToFront('set-modal-container');
        }, 100);
        return;
    }
    const m = t.closest(".part-card");
    if (m?.dataset.groupId && m.dataset.partId) {
        const partId = m.dataset.partId,
            groupId = m.dataset.groupId,
            part = PART_MAP[partId];
        if (!part) return;
        let groupPartsArr = [part];
        if ("catalog" === S.view) {
            const groups = S.searchGroups || S.catGroups;
            groupPartsArr = groups && groups[groupId] ? groups[groupId] : [part]
        } else {
            const isFolder = m.hasAttribute('data-folder');
            const isColorsModalOpen = colorsModalEl && !colorsModalEl.classList.contains('modal-hidden');
            const cardColorId = m.getAttribute('data-color-id');
            // Если клик по карточке цвета (не папке) — всегда открываем модалку детали
            if (!isFolder && cardColorId) {
                openModalForPart(partId, groupId, [part]);
                S.partModal.selColorId = String(cardColorId);
                S.partModal.qty = S.coll[partId]?.[S.partModal.selColorId] || 0;
                updateModalPartially({ controls: !0, image: !0 });
                fetchPartColorSpecifics(partId, S.partModal.selColorId);
                return;
            }
            // Если это папка — открываем окно цветов только если в коллекции >3 цветов
            if (isFolder) {
                // Проверяем, не кликнули ли по кнопке закрытия
                const closeBtn = t.closest('[data-action="close-folder"]');
                if (closeBtn) {
                    // Кнопка закрытия обрабатывается выше
                    return;
                }
                
                // Тоглим локальное раскрытие папки — карточки появятся рядом
                if (!S.expandedFolders) S.expandedFolders = new Set();
                const key = String(partId);
                if (S.expandedFolders.has(key)) S.expandedFolders.delete(key); else S.expandedFolders.add(key);
                S.gridStale = true;
                updateUI();
                return;
            }
            // Если открыт экран папки и кликнули по карточке внутри него — закрываем папку и открываем деталь
            if (isColorsModalOpen) {
                modalManager.closeModal('colors-modal-container');
                openModalForPart(partId, groupId, [part]);
                setTimeout(() => modalManager.bringToFront('modal-container'), 50);
                if (cardColorId) {
                    S.partModal.selColorId = String(cardColorId);
                    S.partModal.qty = S.coll[partId]?.[S.partModal.selColorId] || 0;
                    updateModalPartially({ controls: !0, image: !0 });
                    fetchPartColorSpecifics(partId, S.partModal.selColorId);
                }
                return;
            }
            // Фолбэк: обычная модалка
            openModalForPart(partId, groupId, [part]);
            return;
        }
        const selPartBtn = t.closest('[data-action="toggle-select"]');
        if (selPartBtn) return; // обработано выше
        openModalForPart(partId, groupId, groupPartsArr);
        
        // Временно поднимаем модальное окно детали на самый верх
        setTimeout(() => {
            modalManager.bringToFront('modal-container');
        }, 100);
        if ("collection" === S.view && m.dataset.colorId) {
            S.partModal.selColorId = m.dataset.colorId;
            S.partModal.qty = S.coll[partId]?.[S.partModal.selColorId] || 0;
            updateModalPartially({
                controls: !0
            });
            fetchPartColorSpecifics(partId, S.partModal.selColorId);
        }
        return;
    }
    // Закрытие модального окна цветов
    if (t.id === 'colors-modal-close' || t.closest('#colors-modal-close') || t.id === 'colors-modal-container') {
        if (t.closest('#colors-modal-close')) {
            animateCloseButtonClick(t.closest('#colors-modal-close'));
        }
        modalManager.closeModal('colors-modal-container');
        return;
    }
    // Папки теперь кликаются как обычные карточки (открывают модалку), отдельный тогглер не нужен
    if ("modal-container" === t.id || t.closest("#modal-close")) {
        if (t.closest("#modal-close")) {
            animateCloseButtonClick(t.closest("#modal-close"));
        }
        return closeModal();
    }
    if ("set-modal-container" === t.id || t.closest("#set-modal-close")) {
        if (t.closest("#set-modal-close")) {
            animateCloseButtonClick(t.closest("#set-modal-close"));
        }
        return closeSetModal();
    }
    if ("minifig-modal-container" === t.id || t.closest("#minifig-modal-close")) {
        if (t.closest("#minifig-modal-close")) {
            animateCloseButtonClick(t.closest("#minifig-modal-close"));
        }
        return closeMinifigModal();
    }
    if ("filter-modal-container" === t.id || t.closest("#filter-modal-close")) {
        if (t.closest("#filter-modal-close")) {
            animateCloseButtonClick(t.closest("#filter-modal-close"));
        }
        return closeFilterModal();
    }
    if ("settings-modal-container" === t.id || t.closest("#settings-modal-close")) {
        if (t.closest("#settings-modal-close")) {
            animateCloseButtonClick(t.closest("#settings-modal-close"));
        }
        return closeSettingsModal();
    }
    if ("related-sets-modal-container" === t.id || t.closest("#related-sets-modal-close")) {
        if (t.closest("#related-sets-modal-close")) {
            animateCloseButtonClick(t.closest("#related-sets-modal-close"));
        }
        return closeRelatedSetsModal();
    }
    if (t.closest("#search-button")) return triggerSearch();
    if (t.closest("#clear-search")) {
        S.q = "";
        S.selFigNum = null;
        S.showRelatedSets = false;
        // Сбрасываем случайное изображение минифигурки при очистке поиска
        resetRandomMinifigImage();
        document.getElementById("search-input")?.focus();
        return void triggerSearch()
    }
    // Панель мультивыбора
    if (t.closest('[data-action="cancel-multiselect"]')) {
        const bar = document.getElementById('multiselect-bar');
        if (bar) {
            bar.style.animation = 'msSlideFadeOut .28s ease-in both';
            setTimeout(() => { S.multiSelect.active = !1; S.multiSelect.items = new Set; renderHeader(); updateUI(); }, 260);
        } else {
            S.multiSelect.active = !1; S.multiSelect.items = new Set; renderHeader(); updateUI();
        }
        return;
    }
    if (t.closest('[data-action="delete-multiselect"]')) {
        if (!S.multiSelect.active || S.multiSelect.items.size === 0) return;
        const keys = Array.from(S.multiSelect.items);
        for (const key of keys) {
            if (key.startsWith('sets:')) {
                const id = key.split(':')[1];
                handleUpdateSetCollection(id, 0);
            } else if (key.startsWith('minifigs:')) {
                const id = key.split(':')[1];
                await handleUpdateMinifigCollection(id, 0, false);
            } else if (key.startsWith('parts:')) {
                const [, id, colorId] = key.split(':');
                await handleUpdateCollection(id, colorId, 0);
            } else if (key.startsWith('parts-folder:')) {
                const id = key.split(':')[1];
                const colors = Object.keys(S.coll[id] || {});
                for (const colorId of colors) {
                    await handleUpdateCollection(id, colorId, 0);
                }
            }
        }
        S.multiSelect.active = !1; S.multiSelect.items = new Set;
        renderHeader(); updateUI();
        return;
    }

    if (t.closest('[data-action="add-multiselect-to-collection"]')) {
        if (!S.multiSelect.active || S.multiSelect.items.size === 0) return;
        const keys = Array.from(S.multiSelect.items);
        for (const key of keys) {
            if (key.startsWith('sets:')) {
                const id = key.split(':')[1];
                // Добавляем набор и весь его инвентарь
                handleUpdateSetCollection(id, (S.setColl[id]?.qty || 0) + 1);
                handleBulkUpdatePartsFromSet(id, 'add');
            } else if (key.startsWith('minifigs:')) {
                const id = key.split(':')[1];
                S.minifigColl[id] = { qty: (S.minifigColl[id]?.qty || 0) + 1 };
                await handleBulkAddMinifigParts(id);
            } else if (key.startsWith('parts:')) {
                const [, id, colorId] = key.split(':');
                const qty = (S.coll[id]?.[colorId] || 0) + 1;
                await handleUpdateCollection(id, colorId, qty);
            } else if (key.startsWith('parts-folder:')) {
                const id = key.split(':')[1];
                // Для папки: увеличить количество по всем цветам в коллекции (или добавить 1 для первого известного цвета)
                const colors = Object.keys(S.coll[id] || {});
                if (colors.length > 0) {
                    for (const colorId of colors) {
                        const qty = (S.coll[id]?.[colorId] || 0) + 1;
                        await handleUpdateCollection(id, colorId, qty);
                    }
                } else {
                    // Если в коллекции нет ни одного цвета, добавим по первому доступному цвету
                    const available = PART_MAP[id]?.availableColorIds;
                    const colorId = Array.isArray(available) && available.length ? String(available[0]) : null;
                    if (colorId) await handleUpdateCollection(id, colorId, 1);
                }
            }
        }
        saveState(); forceSaveState();
        S.multiSelect.active = !1; S.multiSelect.items = new Set;
        renderHeader(); updateUI();
        return;
    }
    if (t.closest('[data-action="share-multiselect"]')) {
        if (!S.multiSelect.active || S.multiSelect.items.size === 0) return;
        const keys = Array.from(S.multiSelect.items);
        const parts = [];
        const sets = [];
        const minifigs = [];
        const folders = [];
        for (const key of keys) {
            if (key.startsWith('sets:')) {
                const id = key.split(':')[1];
                sets.push(id);
            } else if (key.startsWith('minifigs:')) {
                const id = key.split(':')[1];
                minifigs.push(id);
            } else if (key.startsWith('parts:')) {
                const [, id, colorId] = key.split(':');
                parts.push({ id, colorId });
            } else if (key.startsWith('parts-folder:')) {
                const id = key.split(':')[1];
                folders.push(id);
            }
        }
        const selection = { parts, sets, minifigs, folders };
        console.log('Share multiselect selection:', selection);
        console.log('S.coll:', S.coll);
        console.log('S.view:', S.view);
        try {
            const csvData = generateCsvDataForSelection(selection);
            const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
            let fileName = `lego-selection-${new Date().toISOString().slice(0,10)}.csv`;
            const siteUrl = 'https://zeka3535.github.io/LEGO-Part-Catalog/';
            const totalSelected = parts.length + sets.length + minifigs.length + folders.length;
            let prettyText = '';
            let files = [];
            let csvFile = null;
            // Подготовка красивого текста и, при единственном выборе, попытка приложить изображение
            if (totalSelected === 1) {
                // Определяем единственный элемент и заполняем подробности
                let titleLine = 'Выбранный элемент из LEGO Part Catalog';
                let detailsLine = '';
                const countsLine = (() => {
                    // Если один элемент, показываем его количество из коллекции (если есть)
                    if (sets.length === 1) {
                        const sId = sets[0];
                        const qty = (S.view === 'collection') ? (S.setColl?.[sId]?.qty || 1) : 1;
                        return `— наборов: 1 (qty ${qty})`;
                    }
                    if (minifigs.length === 1) {
                        const mId = minifigs[0];
                        const qty = (S.view === 'collection') ? (S.minifigColl?.[mId]?.qty || 1) : 1;
                        return `— минифигурок: 1 (qty ${qty})`;
                    }
                    if (parts.length === 1) {
                        const { id: pId, colorId } = parts[0];
                        const qty = (S.view === 'collection') ? (S.coll?.[pId]?.[colorId] || 1) : 1;
                        const colorName = (COLOR_MAP[colorId]?.name || '');
                        return `— деталей: 1 (qty ${qty})${colorName ? `, цвет: ${colorName}` : ''}`;
                    }
                    if (folders.length === 1) {
                        const folderId = folders[0];
                        const part = PART_MAP[folderId];
                        const totalQty = (S.view === 'collection' && S.coll?.[folderId]) ? 
                            Object.values(S.coll[folderId]).reduce((a, b) => a + b, 0) : 0;
                        const colorsCount = (S.view === 'collection' && S.coll?.[folderId]) ? 
                            Object.keys(S.coll[folderId]).length : 0;
                        
                        // Для папки показываем перечисление всех цветов
                        if (S.view === 'collection' && S.coll?.[folderId]) {
                            const colorDetails = [];
                            for (const [colorId, qty] of Object.entries(S.coll[folderId])) {
                                if (qty > 0) {
                                    const color = COLOR_MAP[colorId];
                                    const colorName = color?.name || colorId;
                                    colorDetails.push(`${colorName}: ${qty}`);
                                }
                            }
                            return `— папка: ${part?.name || folderId} • ${colorDetails.join(', ')}`;
                        } else {
                            return `— папка: ${part?.name || folderId} (${colorsCount} цветов, всего: ${totalQty})`;
                        }
                    }
                    return `— деталей: ${parts.length}, папок: ${folders.length}, наборов: ${sets.length}, минифигурок: ${minifigs.length}`;
                })();
                let imageUrl = '';
                let selectedName = '';
                if (sets.length === 1) {
                    const sId = sets[0];
                    const s = SET_MAP[sId] || {};
                    const pcs = (s?.num_parts ? `${s.num_parts} pcs` : '');
                    const year = (s?.year ? `${s.year}` : '');
                    detailsLine = `${s?.name || 'Набор'} (#${sId})${pcs ? ' • ' + pcs : ''}${year ? ' • ' + year : ''}`;
                    imageUrl = (s?.set_img_url && s.set_img_url.startsWith('http')) ? s.set_img_url : '';
                    selectedName = s?.name || `set-${sId}`;
                } else if (minifigs.length === 1) {
                    const mId = minifigs[0];
                    const m = MINIFIG_MAP[mId] || {};
                    const pcs = (m?.num_parts ? `${m.num_parts} pcs` : '');
                    detailsLine = `${m?.name || 'Минифигурка'} (${mId})${pcs ? ' • ' + pcs : ''}`;
                    imageUrl = (m?.minifig_img_url && m.minifig_img_url.startsWith('http')) ? m.minifig_img_url : (m?.set_img_url || '');
                    selectedName = m?.name || `minifig-${mId}`;
                } else if (parts.length === 1) {
                    const { id: pId, colorId } = parts[0];
                    const p = PART_MAP[pId] || {};
                    const colorName = (COLOR_MAP[colorId]?.name || '');
                    detailsLine = `${p?.name || 'Деталь'} (${pId})${colorName ? ' • ' + colorName : ''}`;
                    // Предпочтительно берём цветоспецифичную картинку
                    const colorImg = (p?.colorImages && p.colorImages[colorId]) ? p.colorImages[colorId] : '';
                    imageUrl = (colorImg && colorImg.startsWith('http')) ? colorImg : (p?.part_img_url || p?.rebrickable_img_url || '');
                    selectedName = p?.name || `part-${pId}`;
                } else if (folders.length === 1) {
                    const folderId = folders[0];
                    const p = PART_MAP[folderId] || {};
                    const totalQty = (S.view === 'collection' && S.coll?.[folderId]) ? 
                        Object.values(S.coll[folderId]).reduce((a, b) => a + b, 0) : 0;
                    const colorsCount = (S.view === 'collection' && S.coll?.[folderId]) ? 
                        Object.keys(S.coll[folderId]).length : 0;
                    
                    // Для папки показываем перечисление всех цветов
                    if (S.view === 'collection' && S.coll?.[folderId]) {
                        const colorDetails = [];
                        for (const [colorId, qty] of Object.entries(S.coll[folderId])) {
                            if (qty > 0) {
                                const color = COLOR_MAP[colorId];
                                const colorName = color?.name || colorId;
                                colorDetails.push(`${colorName}: ${qty}`);
                            }
                        }
                        detailsLine = `${p?.name || 'Папка деталей'} (${folderId}) • ${colorDetails.join(', ')}`;
                    } else {
                        detailsLine = `${p?.name || 'Папка деталей'} (${folderId}) • ${colorsCount} цветов • всего: ${totalQty}`;
                    }
                    imageUrl = (p?.part_img_url || p?.rebrickable_img_url || '');
                    selectedName = p?.name || `folder-${folderId}`;
                }
                prettyText = [titleLine, detailsLine, countsLine, '', `Сайт: ${siteUrl}`].join('\n');
                // Пытаемся собрать композит с реальным изображением; затем фолбэки SVG/PNG
                let imageFile = null;
                if (imageUrl && imageUrl.startsWith('http')) {
                    const opts = {};
                    if (folders.length === 1) {
                        // Для папки используем основной цвет детали или первый доступный цвет
                        const folderId = folders[0];
                        const p = PART_MAP[folderId];
                        if (p?.colorImages && Object.keys(p.colorImages).length > 0) {
                            const firstColorId = Object.keys(p.colorImages)[0];
                            const c = COLOR_MAP[firstColorId];
                            if (c) {
                                opts.colorHex = c.hex || '#000000';
                                opts.colorName = c.name || '';
                                opts.isTransparent = !!c.isTransparent;
                            }
                        }
                    } else if (parts.length === 1) {
                        const { colorId } = parts[0];
                        const c = COLOR_MAP[colorId];
                        if (c) {
                            opts.colorHex = c.hex || '#000000';
                            opts.colorName = c.name || '';
                            opts.isTransparent = !!c.isTransparent;
                        }
                    }
                    // Добавим строку метаданных (кол-во, год, детали и т.д.)
                    let metaExtra = '';
                    if (folders.length === 1) {
                        const folderId = folders[0];
                        const p = PART_MAP[folderId] || {};
                        const totalQty = (S.view === 'collection' && S.coll?.[folderId]) ? 
                            Object.values(S.coll[folderId]).reduce((a, b) => a + b, 0) : 0;
                        const colorsCount = (S.view === 'collection' && S.coll?.[folderId]) ? 
                            Object.keys(S.coll[folderId]).length : 0;
                        
                        // Для папки показываем перечисление всех цветов
                        if (S.view === 'collection' && S.coll?.[folderId]) {
                            const colorDetails = [];
                            for (const [colorId, qty] of Object.entries(S.coll[folderId])) {
                                if (qty > 0) {
                                    const color = COLOR_MAP[colorId];
                                    const colorName = color?.name || colorId;
                                    colorDetails.push(`${colorName}: ${qty}`);
                                }
                            }
                            metaExtra = `папка: ${colorDetails.join(', ')}`;
                        } else {
                            metaExtra = `папка: ${colorsCount} цветов, всего: ${totalQty}`;
                        }
                    } else if (sets.length === 1) {
                        const s = SET_MAP[sets[0]] || {};
                        const piecesInfo = s?.num_parts ? `деталей в наборе: ${s.num_parts}` : '';
                        const yearInfo = s?.year ? `год: ${s.year}` : '';
                        metaExtra = [piecesInfo, yearInfo].filter(Boolean).join(', ');
                    } else if (minifigs.length === 1) {
                        const m = MINIFIG_MAP[minifigs[0]] || {};
                        const piecesInfo = m?.num_parts ? `деталей в инвентаре: ${m.num_parts}` : '';
                        metaExtra = [piecesInfo].filter(Boolean).join(', ');
                    }
                    const baseMeta = countsLine.replace(/^—\s?/, '');
                    opts.meta = [baseMeta, metaExtra].filter(Boolean).join(' • ');
                    // Имя файла изображения по выбранному элементу
                    const safe = String(selectedName || 'item').replace(/[\\/:*?"<>|]+/g, '').trim().replace(/\s+/g, '-').slice(0, 80);
                    opts.fileName = `lego-${safe}.png`;
                    imageFile = await createCompositePreviewImage(
                        imageUrl,
                        detailsLine.split(' • ')[0] || 'LEGO Item',
                        'CSV включает:',
                        opts
                    );
                }
                if (!imageFile) {
                    const fallbackTitle = detailsLine.split(' • ')[0] || 'LEGO Item';
                    const fallbackSub = 'CSV включает:';
                    const safe = String(selectedName || 'item').replace(/[\\/:*?"<>|]+/g, '').trim().replace(/\s+/g, '-').slice(0, 80);
                    imageFile = await createRasterPreviewImage(fallbackTitle, fallbackSub, { fileName: `lego-${safe}.png` });
                }
                if (selectedName) {
                    const safeCsv = String(selectedName).replace(/[\\/:*?"<>|]+/g, '').trim().replace(/\s+/g, '-').slice(0, 80);
                    fileName = `lego-selection-${safeCsv}.csv`;
                }
                // Создаём CSV-файл с актуальным именем
                csvFile = new File([blob], fileName, { type: 'text/csv' });
                files = imageFile ? [csvFile, imageFile] : [csvFile];
            } else {
                // Для множественного выбора показываем детальную информацию о папках
                let folderDetails = '';
                if (folders.length > 0) {
                    const folderInfo = [];
                    for (const folderId of folders) {
                        const part = PART_MAP[folderId];
                        if (S.view === 'collection' && S.coll?.[folderId]) {
                            const colorDetails = [];
                            for (const [colorId, qty] of Object.entries(S.coll[folderId])) {
                                if (qty > 0) {
                                    const color = COLOR_MAP[colorId];
                                    const colorName = color?.name || colorId;
                                    colorDetails.push(`${colorName}: ${qty}`);
                                }
                            }
                            folderInfo.push(`${part?.name || folderId} (${colorDetails.join(', ')})`);
                        } else {
                            folderInfo.push(`${part?.name || folderId}`);
                        }
                    }
                    folderDetails = folderInfo.join('\n');
                }
                
                prettyText = [
                    'Мой подбор из LEGO Part Catalog',
                    `— деталей: ${parts.length}, папок: ${folders.length}, наборов: ${sets.length}, минифигурок: ${minifigs.length}`,
                    ...(folderDetails ? ['', 'Содержимое папок:', folderDetails] : []),
                    `Сайт: ${siteUrl}`
                ].join('\n');
                
                // Для множественного выбора используем дефолтное имя, создаём CSV сейчас
                csvFile = new File([blob], fileName, { type: 'text/csv' });
                files = [csvFile];
            }
            if (navigator.share) {
                let shared = false;
                if (navigator.canShare) {
                    // Пробуем оба файла (CSV + изображение)
                    if (!shared && files.length === 2 && navigator.canShare({ files })) {
                        await navigator.share({ files, title: 'Подбор LEGO', text: prettyText });
                        shared = true;
                    }
                    // Если нельзя оба файла — пробуем только изображение
                    const imageOnly = files.find(f => f.type && f.type.startsWith('image/'));
                    if (!shared && imageOnly && navigator.canShare({ files: [imageOnly] })) {
                        await navigator.share({ files: [imageOnly], title: 'Подбор LEGO', text: prettyText });
                        shared = true;
                    }
                    // Если нельзя изображение — пробуем только CSV
                    if (!shared && navigator.canShare({ files: [csvFile] })) {
                        await navigator.share({ files: [csvFile], title: 'Подбор LEGO (CSV)', text: prettyText });
                        shared = true;
                    }
                }
                if (!shared) {
                    // Файлы не поддерживаются — делимся текстом + CSV в тексте
                    await navigator.share({ title: 'Подбор LEGO', text: prettyText + (csvData ? '\n\n' + csvData : ''), url: siteUrl });
                }
            } else {
                // Фолбэк: скачиваем CSV и открываем сайт; изображение не прикладываем
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = fileName; document.body.appendChild(a); a.click(); a.remove();
                setTimeout(() => URL.revokeObjectURL(url), 5000);
                window.open(siteUrl, '_blank');
            }
        } catch (err) {
            console.error('Share selection failed:', err);
        }
        return;
    }
    // Share buttons in modals
    if (t.closest('[data-action="share-part"]')) {
        (async () => {
            try {
                const siteUrl = 'https://zeka3535.github.io/LEGO-Part-Catalog/';
                const partId = S.selPartId;
                if (!partId) return;
                const colorId = S.partModal?.selColorId || '';
                const qty = S.partModal?.qty || 0;
                const includeCsv = (qty > 0) && !!colorId;
                const p = PART_MAP[partId] || {};
                const color = COLOR_MAP[colorId];
                const title = `${p?.name || 'Деталь'} (${partId})`;
                const subtitle = includeCsv ? 'CSV включает:' : '';
                const colorImg = (p?.colorImages && colorId && p.colorImages[colorId]) ? p.colorImages[colorId] : '';
                const imageUrl = (colorImg && colorImg.startsWith('http')) ? colorImg : (p?.part_img_url || p?.rebrickable_img_url || S.partModal?.imgUrl || '');
                const opts = {};
                if (color) {
                    opts.colorHex = color.hex || '#000000';
                    opts.colorName = color.name || '';
                    opts.isTransparent = !!color.isTransparent;
                }
                if (qty > 0) {
                    opts.meta = `количество: ${qty}`;
                }
                const safeBase = String(p?.name || `part-${partId}`).replace(/[\\/:*?"<>|]+/g, '').trim().replace(/\s+/g, '-').slice(0, 80);
                opts.fileName = `lego-${safeBase}.png`;
                let imageFile = await createCompositePreviewImage(imageUrl, title, subtitle, opts);
                if (!imageFile) {
                    const fallbackSub = qty > 0 ? `количество: ${qty}` : '';
                    imageFile = await createRasterPreviewImage(title, fallbackSub, { fileName: `lego-${safeBase}.png` });
                }
                let files = [imageFile];
                let csvData = '';
                let csvFile = null;
                if (includeCsv) {
                    csvData = generateCsvDataForSelection({ parts: [{ id: partId, colorId }] });
                    const csvBlob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
                    const csvName = `lego-selection-${partId}${colorId?'-'+colorId:''}.csv`;
                    csvFile = new File([csvBlob], csvName, { type: 'text/csv' });
                    files = [csvFile, imageFile];
                }
                if (navigator.share) {
                    let shared = false;
                    if (navigator.canShare) {
                        if (!shared && files.length === 2 && navigator.canShare({ files })) { await navigator.share({ files, title, text: `Сайт: ${siteUrl}` }); shared = true; }
                        if (!shared && navigator.canShare({ files: [imageFile] })) { await navigator.share({ files: [imageFile], title, text: `Сайт: ${siteUrl}` }); shared = true; }
                        if (!shared && csvFile && navigator.canShare({ files: [csvFile] })) { await navigator.share({ files: [csvFile], title: title + ' (CSV)', text: `Сайт: ${siteUrl}` }); shared = true; }
                    }
                    if (!shared) {
                        await navigator.share({ title, text: `Сайт: ${siteUrl}` + (includeCsv ? ('\n\n' + csvData) : '') , url: siteUrl });
                    }
                } else {
                    // Fallback: download files
                    const urlImg = URL.createObjectURL(imageFile); const a1 = document.createElement('a'); a1.href = urlImg; a1.download = imageFile.name || 'lego-part.png'; document.body.appendChild(a1); a1.click(); a1.remove(); setTimeout(() => URL.revokeObjectURL(urlImg), 5000);
                    if (csvFile) { const urlCsv = URL.createObjectURL(csvFile); const a2 = document.createElement('a'); a2.href = urlCsv; a2.download = csvFile.name; document.body.appendChild(a2); a2.click(); a2.remove(); setTimeout(() => URL.revokeObjectURL(urlCsv), 5000); }
                    window.open(siteUrl, '_blank');
                }
            } catch (err) { console.error('Share part failed:', err); }
        })();
        return;
    }
    if (t.closest('[data-action="share-set"]')) {
        (async () => {
            try {
                const siteUrl = 'https://zeka3535.github.io/LEGO-Part-Catalog/';
                const setNum = S.selSetNum; if (!setNum) return;
                const s = SET_MAP[setNum] || {};
                const qty = S.setModal?.qty || 0;
                const title = `${s?.name || 'Набор'}`;
                const subtitle = 'CSV включает:';
                const imageUrl = (s?.set_img_url && String(s.set_img_url).startsWith('http')) ? s.set_img_url : '';
                const opts = { fileName: `lego-set-${setNum}.png` };
                const theme = s?.theme_id ? THEME_MAP[s.theme_id] : null;
                const piecesInfo = s?.num_parts ? `деталей: ${s.num_parts}` : '';
                const yearInfo = s?.year ? `год: ${s.year}` : '';
                const idInfo = `ID: ${setNum}`;
                const extras = [piecesInfo, yearInfo, idInfo].filter(Boolean).join(' • ');
                if (extras) opts.meta = extras;
                let imageFile = await createCompositePreviewImage(imageUrl, title, subtitle, opts);
                if (!imageFile) imageFile = await createRasterPreviewImage(title, qty>0?`количество: ${qty}`:'' , { fileName: `lego-set-${setNum}.png` });
                const csvData = generateCsvDataForSelection({ sets: [setNum] });
                const csvBlob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
                const csvFile = new File([csvBlob], `lego-selection-set-${setNum}.csv`, { type: 'text/csv' });
                if (navigator.share) {
                    let shared = false;
                    const files = [csvFile, imageFile];
                    if (navigator.canShare) {
                        if (!shared && navigator.canShare({ files })) { await navigator.share({ files, title, text: `Сайт: ${siteUrl}` }); shared = true; }
                        if (!shared && navigator.canShare({ files: [imageFile] })) { await navigator.share({ files: [imageFile], title, text: `Сайт: ${siteUrl}` }); shared = true; }
                        if (!shared && navigator.canShare({ files: [csvFile] })) { await navigator.share({ files: [csvFile], title: title + ' (CSV)', text: `Сайт: ${siteUrl}` }); shared = true; }
                    }
                    if (!shared) { await navigator.share({ title, text: `Сайт: ${siteUrl}\n\n` + csvData, url: siteUrl }); }
                } else {
                    const urlImg = URL.createObjectURL(imageFile); const a1 = document.createElement('a'); a1.href = urlImg; a1.download = imageFile.name || 'lego-set.png'; document.body.appendChild(a1); a1.click(); a1.remove(); setTimeout(() => URL.revokeObjectURL(urlImg), 5000);
                    const urlCsv = URL.createObjectURL(csvBlob); const a2 = document.createElement('a'); a2.href = urlCsv; a2.download = csvFile.name; document.body.appendChild(a2); a2.click(); a2.remove(); setTimeout(() => URL.revokeObjectURL(urlCsv), 5000);
                    window.open(siteUrl, '_blank');
                }
            } catch (err) { console.error('Share set failed:', err); }
        })();
        return;
    }
    if (t.closest('[data-action="share-minifig"]')) {
        (async () => {
            try {
                const siteUrl = 'https://zeka3535.github.io/LEGO-Part-Catalog/';
                const figNum = S.selFigNum; if (!figNum) return;
                const m = MINIFIG_MAP[figNum] || {};
                const qty = S.minifigModal?.qty || 0;
                const title = `${m?.name || 'Минифигурка'}`;
                const subtitle = 'CSV включает:';
                const imageUrl = (m?.minifig_img_url && String(m.minifig_img_url).startsWith('http')) ? m.minifig_img_url : (m?.set_img_url || '');
                const opts = { fileName: `lego-minifig-${figNum}.png` };
                const piecesInfo = m?.num_parts ? `деталей: ${m.num_parts}` : '';
                const idInfo = `ID: ${figNum}`;
                const extras = [piecesInfo, idInfo].filter(Boolean).join(' • ');
                if (extras) opts.meta = extras;
                let imageFile = await createCompositePreviewImage(imageUrl, title, subtitle, opts);
                if (!imageFile) imageFile = await createRasterPreviewImage(title, qty>0?`количество: ${qty}`:'' , { fileName: `lego-minifig-${figNum}.png` });
                const csvData = generateCsvDataForSelection({ minifigs: [figNum] });
                const csvBlob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
                const csvFile = new File([csvBlob], `lego-selection-minifig-${figNum}.csv`, { type: 'text/csv' });
                if (navigator.share) {
                    let shared = false;
                    const files = [csvFile, imageFile];
                    if (navigator.canShare) {
                        if (!shared && navigator.canShare({ files })) { await navigator.share({ files, title, text: `Сайт: ${siteUrl}` }); shared = true; }
                        if (!shared && navigator.canShare({ files: [imageFile] })) { await navigator.share({ files: [imageFile], title, text: `Сайт: ${siteUrl}` }); shared = true; }
                        if (!shared && navigator.canShare({ files: [csvFile] })) { await navigator.share({ files: [csvFile], title: title + ' (CSV)', text: `Сайт: ${siteUrl}` }); shared = true; }
                    }
                    if (!shared) { await navigator.share({ title, text: `Сайт: ${siteUrl}\n\n` + csvData, url: siteUrl }); }
                } else {
                    const urlImg = URL.createObjectURL(imageFile); const a1 = document.createElement('a'); a1.href = urlImg; a1.download = imageFile.name || 'lego-minifig.png'; document.body.appendChild(a1); a1.click(); a1.remove(); setTimeout(() => URL.revokeObjectURL(urlImg), 5000);
                    const urlCsv = URL.createObjectURL(csvBlob); const a2 = document.createElement('a'); a2.href = urlCsv; a2.download = csvFile.name; document.body.appendChild(a2); a2.click(); a2.remove(); setTimeout(() => URL.revokeObjectURL(urlCsv), 5000);
                    window.open(siteUrl, '_blank');
                }
            } catch (err) { console.error('Share minifig failed:', err); }
        })();
        return;
    }
    if (t.closest("#filter-button")) {
        // Разрешаем открытие фильтров даже во время загрузки данных
        S.filterOpen = !0;
        // Убеждаемся, что фильтры правильно инициализированы
        if (!S.filters) S.filters = { colorIds: [], inCollectionOnly: false };
        if (!S.setFilters) S.setFilters = { minYear: "", maxYear: "", minParts: "", maxParts: "" };
        if (!S.sortBy) S.sortBy = 'popularity';
        
        // Скрываем указатель при открытии фильтров
        hideSidebarHint();
        
        tempFilters = {
            filters: JSON.parse(JSON.stringify(S.filters)),
            setFilters: JSON.parse(JSON.stringify(S.setFilters)),
            sortBy: S.sortBy
        };
        return void renderFilterModal();
    }
    if (t.closest("#refresh-images-button")) {
        return void forceRefreshPartImages();
    }

    if (t.closest("#settings-button")) {
        // Разрешаем открытие настроек даже во время загрузки данных
        S.settingsOpen = !0;
        
        // Скрываем указатель при открытии настроек
        hideSidebarHint();
        
        return void renderSettingsModal();
    }

    // Взаимодействия внутри модального окна фильтров
    if (filterModalEl?.contains(t)) {
        // Нажатие по пунктам сортировки (метка), переключателю коллекции, цветам и кнопкам Сбросить/Применить
        const actionEl = t.closest('[data-action]');
        // Клик по варианту сортировки через label → находим вложенный input
        const sortLabel = t.closest('label');
        if (sortLabel) {
            const input = sortLabel.querySelector('input[name="sort"][data-action="modal-set-sort"]');
            if (input) {
                tempFilters.sortBy = input.value;
                // Сбрасываем случайное изображение минифигурки при изменении сортировки
                resetRandomMinifigImage();
                updateFilterModalUI();
                return;
            }
        }
        if (actionEl) {
            switch (actionEl.dataset.action) {
                case 'modal-set-sort': {
                    const input = actionEl.tagName === 'INPUT' ? actionEl : actionEl.querySelector('input[name="sort"]');
                    if (input) {
                        tempFilters.sortBy = input.value;
                        // Сбрасываем случайное изображение минифигурки при изменении сортировки
                        resetRandomMinifigImage();
                    }
                    updateFilterModalUI();
                    return;
                }
                case 'modal-toggle-collection': {
                    const input = actionEl.tagName === 'INPUT' ? actionEl : actionEl.querySelector('input');
                    if (input && tempFilters.filters) {
                        tempFilters.filters.inCollectionOnly = !!input.checked;
                        // Сбрасываем случайное изображение минифигурки при изменении фильтра коллекции
                        resetRandomMinifigImage();
                    }
                    updateFilterModalUI();
                    return;
                }
                case 'modal-set-color': {
                    const colorId = actionEl.dataset.colorId;
                    if (colorId === 'null') {
                        tempFilters.filters.colorIds = [];
                    } else if (colorId) {
                        const list = tempFilters.filters.colorIds || [];
                        const idx = list.indexOf(colorId);
                        if (idx >= 0) list.splice(idx, 1); else list.push(colorId);
                        tempFilters.filters.colorIds = list;
                    }
                    
                    // Сбрасываем случайное изображение минифигурки при изменении цвета
                    resetRandomMinifigImage();
                    
                    updateFilterModalUI();
                    return;
                }
                case 'modal-reset-filters': {
                    if (S.subView === 'sets') {
                        tempFilters.setFilters = { minYear: '', maxYear: '', minParts: '', maxParts: '' };
                        tempFilters.sortBy = S.q ? 'relevance' : 'year_desc';
                    } else if (S.subView === 'minifigs') {
                        tempFilters.sortBy = S.q ? 'relevance' : 'name_asc';
                    } else {
                        tempFilters.filters = { colorIds: [], inCollectionOnly: false };
                        tempFilters.sortBy = S.q ? 'relevance' : 'popularity';
                    }
                    
                    // Сбрасываем случайное изображение минифигурки при сбросе фильтров
                    resetRandomMinifigImage();
                    
                    updateFilterModalUI();
                    return;
                }
                case 'modal-apply-filters': {
                    // Предотвращаем двойные срабатывания
                    e.preventDefault();
                    if (S.filterApplying) return;
                    S.filterApplying = true;
                    
                    // Сбрасываем случайное изображение минифигурки при применении фильтров
                    resetRandomMinifigImage();
                    
                    if (S.subView === 'sets') {
                        S.setFilters = { ...tempFilters.setFilters };
                        S.sortBy = tempFilters.sortBy;
                    } else if (S.subView === 'minifigs') {
                        S.sortBy = tempFilters.sortBy;
                    } else {
                        S.filters = { ...tempFilters.filters };
                        S.sortBy = tempFilters.sortBy;
                    }
                    // Закрываем модалку корректно с анимацией
                    closeFilterModal();
                    try { refreshWithNewFilters(); } finally { setTimeout(() => { S.filterApplying = false; }, 0); }
                    return;
                }
            }
        }
    }
    const h = t.closest('[data-action="remove-filter"]');
    if (h) {
        const e = h.dataset.filterType;
        if ("color" === e) {
            S.filters.colorIds = S.filters.colorIds.filter(id => id !== h.dataset.colorId)
        }
        if ("inCollectionOnly" === e) {
            S.filters.inCollectionOnly = !1;
        }
        if ("sortBy" === e) {
            S.sortBy = S.q ? "relevance" : "popularity";
        }
        
        // Сбрасываем случайное изображение минифигурки при удалении фильтра
        resetRandomMinifigImage();
        
        return void refreshWithNewFilters()
    }
    if (t.closest('[data-action="remove-all-filters"]')) {
        if ("sets" === S.subView) {
            S.setFilters = {
                minYear: "",
                maxYear: "",
                minParts: "",
                maxParts: ""
            };
            S.sortBy = S.q ? "relevance" : "year_desc";
        } else if ("minifigs" === S.subView) {
            S.sortBy = S.q ? "relevance" : "name_asc";
        } else {
            S.filters.colorIds = [];
            S.filters.inCollectionOnly = !1;
            S.sortBy = S.q ? "relevance" : "popularity";
        }
        
        // Сбрасываем случайное изображение минифигурки при удалении всех фильтров
        resetRandomMinifigImage();
        
        return void refreshWithNewFilters();
    }
     if (settingsModalEl?.contains(t)) {
        const e = t.closest("[data-action]");
        if (!e) return;
        switch (e.dataset.action) {
            case "disable-color-images":
            case "toggle-settings-stats":
                const panel = document.getElementById('settings-stats-panel');
                const chevron = document.getElementById('settings-stats-chevron');
                if (panel) {
                    panel.classList.toggle('open');
                }
                if (chevron) {
                    chevron.classList.toggle('rotate-180');
                }
                break;
            case "toggle-api-stats":
                const apiPanel = document.getElementById('api-stats-panel');
                const apiChevron = document.getElementById('api-stats-chevron');
                if (apiPanel) {
                    apiPanel.classList.toggle('open');
                    const isOpen = apiPanel.classList.contains('open');
                    try { localStorage.setItem('apiStatsOpen', String(isOpen)); } catch {}
                }
                if (apiChevron) {
                    apiChevron.classList.toggle('rotate-180');
                }
                break;
                const checkbox = document.getElementById('disable-color-images');
                if (checkbox) {
                    localStorage.setItem('disableColorSpecificImages', checkbox.checked.toString());
                    if (checkbox.checked) {
                        S.settingsModal.status = "Загрузка изображений для каждого цвета отключена. Коллекция будет загружаться быстрее.", S.settingsModal.statusType = "success";
                    } else {
                        S.settingsModal.status = "Загрузка изображений для каждого цвета включена.", S.settingsModal.statusType = "success";
                    }
                    renderSettingsModal();
                }
                break;
            case "share-collection": {
                (async () => {
                    try {
                        const csvData = generateCsvData();
                        const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
                        const fileName = `lego-collection-${new Date().toISOString().slice(0,10)}.csv`;
                        const siteUrl = 'https://zeka3535.github.io/LEGO-Part-Catalog/';
                        const siteText = `Моя коллекция из LEGO Part Catalog — удобный каталог деталей, наборов и минифигурок. Сайт: ${siteUrl}`;
                        if (navigator.share && navigator.canShare && navigator.canShare({ files: [new File([blob], fileName, { type: 'text/csv' })] })) {
                            const file = new File([blob], fileName, { type: 'text/csv' });
                            await navigator.share({ files: [file], title: 'Коллекция LEGO (CSV)', text: siteText });
                        } else if (navigator.share) {
                            await navigator.share({ title: 'Коллекция LEGO (CSV)', text: siteText + '\n\n' + csvData, url: siteUrl });
                        } else {
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url; a.download = fileName; document.body.appendChild(a); a.click(); a.remove();
                            setTimeout(() => URL.revokeObjectURL(url), 5000);
                            window.open(siteUrl, '_blank');
                        }
                        S.settingsModal.status = 'Коллекция подготовлена и передана.'; S.settingsModal.statusType = 'success';
                        renderSettingsModal();
                        // Автоочистка статуса через 2.5с
                        setTimeout(() => { if (S.settingsOpen && S.settingsModal.status === 'Коллекция подготовлена и передана.') { S.settingsModal.status = ''; renderSettingsModal(); } }, 2500);
                    } catch (err) {
                        console.error('Share collection failed:', err);
                        S.settingsModal.status = 'Не удалось передать коллекцию.'; S.settingsModal.statusType = 'error';
                        renderSettingsModal();
                        setTimeout(() => { if (S.settingsOpen && S.settingsModal.status === 'Не удалось передать коллекцию.') { S.settingsModal.status = ''; renderSettingsModal(); } }, 3000);
                    }
                })();
                return;
            }
            case "toggle-catalog-multiselect":
                S.catalogMultiSelectEnabled = !S.catalogMultiSelectEnabled;
                localStorage.setItem('catalogMultiSelectEnabled', String(S.catalogMultiSelectEnabled));
                // При выключении скрываем панель мультивыбора и сбрасываем выбранные элементы
                if (!S.catalogMultiSelectEnabled) { S.multiSelect.active = false; S.multiSelect.items = new Set(); }
                // Обновляем только сам тумблер без перерисовки модалки
                (function(){
                    const btn = settingsModalEl.querySelector('[data-action="toggle-catalog-multiselect"]');
                    if (btn) {
                        if (S.catalogMultiSelectEnabled) btn.classList.add('on'); else btn.classList.remove('on');
                        btn.setAttribute('aria-pressed', String(S.catalogMultiSelectEnabled));
                    }
                })();
                S.gridStale = true; updateUI();
                return;
            case "toggle-collection-multiselect":
                S.collectionMultiSelectEnabled = !S.collectionMultiSelectEnabled;
                localStorage.setItem('collectionMultiSelectEnabled', String(S.collectionMultiSelectEnabled));
                if (!S.collectionMultiSelectEnabled) { S.multiSelect.active = false; S.multiSelect.items = new Set(); }
                // Обновляем только тумблер, не трогая остальной контент
                (function(){
                    const btn = settingsModalEl.querySelector('[data-action="toggle-collection-multiselect"]');
                    if (btn) {
                        if (S.collectionMultiSelectEnabled) btn.classList.add('on'); else btn.classList.remove('on');
                        btn.setAttribute('aria-pressed', String(S.collectionMultiSelectEnabled));
                    }
                })();
                S.gridStale = true; updateUI();
                return;
            case "toggle-folders":
                S.foldersEnabled = !S.foldersEnabled;
                localStorage.setItem('foldersEnabled', String(S.foldersEnabled));
                // Обновляем только тумблер, не трогая остальной контент
                (function(){
                    const btn = settingsModalEl.querySelector('[data-action="toggle-folders"]');
                    if (btn) {
                        if (S.foldersEnabled) btn.classList.add('on'); else btn.classList.remove('on');
                        btn.setAttribute('aria-pressed', String(S.foldersEnabled));
                    }
                })();
                S.settingsModal.status = S.foldersEnabled ? "Группировка в папки включена" : "Группировка в папки отключена";
                S.settingsModal.statusType = "success";
                S.gridStale = true; updateUI();
                // Перерисовываем модал для обновления статуса
                renderSettingsModal();
                setTimeout(()=>{ if (S.settingsOpen) { S.settingsModal.status=''; renderSettingsModal(); } }, 2000);
                return;
            case "toggle-prevent-exit":
                S.preventAccidentalExit = !S.preventAccidentalExit;
                try { localStorage.setItem('preventAccidentalExit', String(S.preventAccidentalExit)); } catch {}
                // Обновляем только тумблер без полной перерисовки
                (function(){
                    const btn = settingsModalEl.querySelector('[data-action="toggle-prevent-exit"]');
                    if (btn) {
                        if (S.preventAccidentalExit) btn.classList.add('on'); else btn.classList.remove('on');
                        btn.setAttribute('aria-pressed', String(S.preventAccidentalExit));
                    }
                })();
                S.settingsModal.status = S.preventAccidentalExit ? "Подтверждение выхода включено" : "Подтверждение выхода отключено";
                S.settingsModal.statusType = "success";
                // Перерисовывать весь модал не нужно, достаточно обновить тумблер и статус
                renderSettingsModal();
                setTimeout(()=>{ if (S.settingsOpen) { S.settingsModal.status=''; renderSettingsModal(); } }, 2000);
                return;

            case "delete-all-parts":
                S.settingsModal.delConfirm = "parts", renderSettingsModal();
                break;
            case "delete-all-sets":
                S.settingsModal.delConfirm = "sets", renderSettingsModal();
                break;
            case "delete-all-minifigs":
                S.settingsModal.delConfirm = "minifigs", renderSettingsModal();
                break;
            case "delete-all-data":
                S.settingsModal.delConfirm = "all", renderSettingsModal();
                break;
            case "cancel-delete":
                S.settingsModal.delConfirm = null, renderSettingsModal();
                break;
            case "confirm-delete-parts":
                S.coll = {}, saveState(), S.settingsModal.delConfirm = null, renderSettingsModal(), updateUI();
                break;
            case "confirm-delete-sets":
                S.setColl = {}, saveState(), S.settingsModal.delConfirm = null, renderSettingsModal(), updateUI();
                break;
            case "confirm-delete-minifigs":
                S.minifigColl = {}, saveState(), S.settingsModal.delConfirm = null, renderSettingsModal(), updateUI();
                break;
            case "confirm-delete-all":
                S.coll = {}, S.setColl = {}, S.minifigColl = {}, saveState(), S.settingsModal.delConfirm = null, renderSettingsModal(), updateUI();
                break;
            case "refresh-minifig-data":
                updateSettingsModalStatus("Обновление данных минифигурок...", "info");
                try {
                    await refreshMinifigData();
                    S.settingsModal.status = "Данные минифигурок обновлены", S.settingsModal.statusType = "success";
                } catch (err) {
                    console.error(err);
                    S.settingsModal.status = "Не удалось обновить минифигурки", S.settingsModal.statusType = "error";
                }
                renderSettingsModal();
                break;
            case "reload-csv-data":
                updateSettingsModalStatus("Перезагрузка данных из CSV...", "info");
                try {
                    await loadDataFromCSV();
                    updateSettingsModalStatus("Данные из CSV перезагружены успешно!", "success");
                } catch (error) {
                    updateSettingsModalStatus(`Ошибка перезагрузки CSV: ${error.message}`, "error");
                }
                break;
            case "load-missing-api-data":
                updateSettingsModalStatus("Загрузка недостающих данных из API...", "info");
                try {
                    await loadMissingDataFromAPI();
                    updateSettingsModalStatus("Недостающие данные загружены успешно!", "success");
                } catch (error) {
                    updateSettingsModalStatus(`Ошибка загрузки API данных: ${error.message}`, "error");
                }
                break;
            case "force-reload-csv":
                updateSettingsModalStatus("Принудительная перезагрузка CSV данных...", "info");
                try {
                    // Сначала очищаем все карты данных
                    Object.keys(PART_MAP).forEach(key => delete PART_MAP[key]);
                    Object.keys(SET_MAP).forEach(key => delete SET_MAP[key]);
                    Object.keys(MINIFIG_MAP).forEach(key => delete MINIFIG_MAP[key]);
                    Object.keys(COLOR_MAP).forEach(key => delete COLOR_MAP[key]);
                    flatCategories.length = 0;
                    Object.keys(THEME_MAP).forEach(key => delete THEME_MAP[key]);
                    
                    // Перезагружаем из CSV
                    await loadDataFromCSV();
                    updateSettingsModalStatus("CSV данные принудительно перезагружены!", "success");
                } catch (error) {
                    updateSettingsModalStatus(`Ошибка принудительной перезагрузки: ${error.message}`, "error");
                }
                break;
            case "clear-app-cache":
                updateSettingsModalStatus("Очистка кэша приложения...", "info");
                try {
                    const success = await window.clearAppCache();
                    if (success) {
                        updateSettingsModalStatus("Кэш очищен! Страница будет обновлена...", "success");
                        
                        // Через 1.5 секунды обновляем страницу
                        setTimeout(() => {
                            window.location.reload();
                        }, 1500);
                    } else {
                        updateSettingsModalStatus("Ошибка очистки кэша", "error");
                    }
                } catch (error) {
                    updateSettingsModalStatus(`Ошибка очистки кэша: ${error.message}`, "error");
                }
                break;
            // Кнопка "Информация" убрана; сведения о кэше обновляются автоматически при открытии настроек

            case "import-csv":
                document.getElementById("import-csv-input")?.click();
                break;
            case "export-csv":
                exportCollectionToCSV();
                break;
        }
    } else if (minifigModalEl?.contains(t)) {
        const e = t.closest("[data-action]");
        if (!e) return;
        switch (e.dataset.action) {
            case "decrease-minifig-qty":
                S.minifigModal.qty > 0 && (S.minifigModal.qty--, renderMinifigModal(!1));
                break;
            case "increase-minifig-qty":
                S.minifigModal.qty++, renderMinifigModal(!1);
                break;
            case "update-minifig-collection":
                S.selFigNum && await handleUpdateMinifigCollection(S.selFigNum, S.minifigModal.qty);
                break;
            case "delete-from-minifig-collection-modal":
                if (S.selFigNum) {
                    await handleUpdateMinifigCollection(S.selFigNum, 0);
                    S.minifigModal.qty = 0;
                }
                break;
            case "toggle-minifig-modal-view":
                S.minifigModal.view = "details" === S.minifigModal.view ? "inventory" : "details";
                if ("inventory" === S.minifigModal.view && !S.minifigModal.inv) {
                    // Показываем индикатор загрузки для инвентаря минифигурки
                    updateLoadingStatus("Загрузка инвентаря минифигурки...", 75, "Загрузка списка деталей");
                    S.minifigModal.loadingInv = !0; S.minifigModal.invError = !1;
                    // Перерисовываем всю модалку, чтобы обновить заголовок и кнопку-переключатель
                    renderMinifigModal(false);
                    try {
                        S.minifigModal.inv = await fetchMinifigParts(S.selFigNum)
                    } catch (t) {
                        S.minifigModal.invError = !0
                    } finally {
                        S.minifigModal.loadingInv = !1;
                        // Обновляем статус загрузки для инвентаря минифигурки
                        if (S.minifigModal.inv && S.minifigModal.inv.length > 0) {
                            updateLoadingStatus("Инвентарь минифигурки загружен", 80, `Загружено ${S.minifigModal.inv.length} деталей`);
                        } else {
                            updateLoadingStatus("Инвентарь минифигурки пуст", 80, "Детали не найдены");
                        }
                        // Перерисовываем модалку после загрузки
                        renderMinifigModal(false);
                    }
                } else {
                    // Простое переключение — перерисовываем всю модалку как у наборов
                    renderMinifigModal(false);
                }
                break;
            case "add-minifig-parts-modal":
                S.selFigNum && handleBulkAddMinifigPartsFromModal(S.selFigNum);
                break;
            case "retry-load-minifig-inv":
                S.minifigModal.inv = null;
                const o = minifigModalEl.querySelector('[data-action="toggle-minifig-modal-view"]');
                o?.click();
                break
            case "refresh-minifig-image":
                if (S.selFigNum) {
                    try {
                        await fetchMinifigDetails(S.selFigNum);
                        renderMinifigModal(false);
                    } catch (error) {
                        console.error('Failed to refresh minifig image:', error);
                    }
                }
                break;
            case "show-related-sets":
                console.log('show-related-sets clicked, selFigNum:', S.selFigNum);
                if (S.selFigNum) {
                    // Закрываем все открытые модальные окна
                    modalManager.closeAllModals();
                    
                    // Дополнительно принудительно закрываем все модальные окна
                    const allModals = [
                        'modal-container',
                        'set-modal-container', 
                        'minifig-modal-container',
                        'filter-modal-container',
                        'settings-modal-container',
                        'related-sets-modal-container'
                    ];
                    
                    allModals.forEach(modalId => {
                        const modalEl = document.getElementById(modalId);
                        if (modalEl && !modalEl.classList.contains('modal-hidden')) {
                            console.log(`Force closing modal: ${modalId}`);
                            modalEl.classList.add('modal-hidden');
                            modalEl.classList.remove('visible');
                            modalEl.innerHTML = '';
                        }
                    });
                    
                    // Убираем overflow-hidden
                    document.body.classList.remove('overflow-hidden');
                    
                    console.log('All modals force closed, switching to catalog/sets');
                    
                    // Переключаемся на каталог и вкладку "Наборы" для показа связанных наборов
                    S.view = "catalog";
                    S.subView = "sets";
                    S.showRelatedSets = true; // Устанавливаем флаг для показа связанных наборов
                    console.log('Switched to catalog/sets, selFigNum:', S.selFigNum, 'showRelatedSets:', S.showRelatedSets);
                    
                    // Обновляем интерфейс
                    updateUI();
                    console.log('updateUI called, selFigNum after:', S.selFigNum);
                }
                break;
        }
    } else if (relatedSetsModalEl?.contains(t)) {
        // Обработка кликов в модальном окне связанных наборов
        const actionEl = t.closest("[data-action]");
        if (!actionEl) return;
        
        const { action, setNum } = actionEl.dataset;
        switch (action) {
            case "open-set-from-related":
                if (setNum) {
                    console.log('Opening set from related sets:', setNum);
                    // НЕ закрываем модальное окно связанных наборов
                    // closeRelatedSetsModal();
                    openModalForSet(setNum);
                    
                    // Временно поднимаем модальное окно набора на самый верх
                    setTimeout(() => {
                        modalManager.bringToFront('set-modal-container');
                    }, 100); // Небольшая задержка для завершения анимации открытия
                    

                }
                break;
        }
        
        // Закрытие модального окна
        if (t.id === 'related-sets-modal-close' || t.closest('#related-sets-modal-close')) {
            if (t.closest('#related-sets-modal-close')) {
                animateCloseButtonClick(t.closest('#related-sets-modal-close'));
            }
            closeRelatedSetsModal();
            // Если есть открытое модальное окно минифигурки, восстанавливаем его z-index
            if (S.selFigNum && minifigModalEl && !minifigModalEl.classList.contains("modal-hidden")) {
                minifigModalEl.style.setProperty('z-index', '70', 'important');
            }
        }
    } else if (setModalEl?.contains(t)) {
        // Если клик пришел по вкладке минифигурки целиком, не перехватываем клики на внутренних кнопках
        const e = t.closest("[data-action]");
        if (!e) return;
        const {
            action: o,
            themeId: l,
            figNum: a,
            quantity: i
        } = e.dataset;
        switch (o) {
            case "toggle-set-modal-view":
                S.setModal.view = "details" === S.setModal.view ? "inventory" : "details", renderSetModal(!1);
                break;
            case "load-more-inventory":
                S.selSetNum && fetchSetInventory(S.selSetNum, S.setModal.invPage + 1);
                break;
            case "decrease-set-qty":
                S.setModal.qty > 0 && (S.setModal.qty--, updateSetModalControlsState());
                break;
            case "increase-set-qty":
                S.setModal.qty++, updateSetModalControlsState();
                break;
            case "update-set-collection":
                S.selSetNum && handleUpdateSetCollection(S.selSetNum, S.setModal.qty);
                break;
            case "delete-from-set-collection-modal":
                S.selSetNum && (handleUpdateSetCollection(S.selSetNum, 0), S.setModal.qty = 0);
                break;
            case "go-to-theme":
                l && (closeSetModal(), S.view = "catalog", S.multiSelect.active = false, S.multiSelect.items = new Set(), S.subView = "sets", S.selThemeId = parseInt(l, 10), S.selFigNum = null, S.showRelatedSets = false, fetchSets());
                // Обновляем статистику после перехода к теме
                setTimeout(() => updateFeelingLuckyStats(), 500);
                break;
            case "bulk-add-parts":
                S.selSetNum && handleBulkUpdatePartsFromSet(S.selSetNum, "add");
                break;
            case "bulk-remove-parts":
                S.selSetNum && handleBulkUpdatePartsFromSet(S.selSetNum, "remove");
                break;
            case "toggle-minifig-parts":
                if (a) {
                    const e = S.setModal.minifigs.find(e => e.set_num === a);
                    if (e) {
                        e.isExpanded = !e.isExpanded;
                        if (e.isExpanded && !e.parts && !e.loadingError) {
                            // Показываем индикатор загрузки для деталей минифигурки в модальном окне набора
                            updateLoadingStatus("Загрузка деталей минифигурки...", 75, "Загрузка списка деталей");
                            
                            e.isLoadingParts = !0, renderSetModal(!1), fetchMinifigParts(a).then(t => {
                                e.parts = t;
                                
                                // Обновляем статус загрузки для деталей минифигурки
                                updateLoadingStatus("Детали минифигурки загружены", 80, `Загружено ${t.length} деталей`);
                            }).catch(() => {
                                e.loadingError = !0;
                                updateLoadingStatus("Ошибка загрузки деталей", 0, "Не удалось загрузить детали минифигурки");
                            }).finally(() => {
                                e.isLoadingParts = !1, S.selSetNum && renderSetModal(!1)
                            })
                        } else e.isExpanded || (e.loadingError = !1), renderSetModal(!1)
                    }
                }
                break;
            case "retry-load-minifig-parts":
                if (a) {
                    const e = S.setModal.minifigs.find(e => e.set_num === a);
                    e && (e.loadingError = !1, e.isLoadingParts = !0, e.parts = null, renderSetModal(!1), 
                        // Показываем индикатор загрузки для повторной загрузки деталей минифигурки
                        updateLoadingStatus("Повторная загрузка деталей минифигурки...", 75, "Загрузка списка деталей"),
                        fetchMinifigParts(a).then(t => {
                            e.parts = t;
                            
                            // Обновляем статус загрузки для деталей минифигурки
                            updateLoadingStatus("Детали минифигурки загружены", 80, `Загружено ${t.length} деталей`);
                        }).catch(() => {
                            e.loadingError = !0;
                            updateLoadingStatus("Ошибка загрузки деталей", 0, "Не удалось загрузить детали минифигурки");
                        }).finally(() => {
                            e.isLoadingParts = !1, S.selSetNum && renderSetModal(!1)
                        })
                    )
                }
                break;
            case "add-minifig-to-collection":
                a && i && await handleUpdateMinifigCollection(a, (S.minifigColl[a]?.qty || 0) + parseInt(i, 10), !1);
                break;
            case "add-minifig-parts-to-collection":
                a && handleBulkAddMinifigParts(a)
        }
    } else if (partModalEl?.contains(t)) {
        // Обрабатываем клик по кнопке селектора пользовательских вариаций
        if (t.id === "variation-select-button") {
            // Переключаем выпадающее меню
            const dropdown = document.getElementById("variation-dropdown");
            const isOpen = dropdown.style.display !== 'none';
            
            if (!isOpen) {
                dropdown.style.display = 'block';
                t.classList.add('open');
            } else {
                dropdown.style.display = 'none';
                t.classList.remove('open');
            }
            return;
        }
        
        // Обрабатываем выбор опции вариации
        if (t.classList.contains("variation-option")) {
            const selectedVariationId = t.dataset.value;
            const selectedVariation = S.partModal.variants?.find(v => v.id === selectedVariationId);
            
            if (selectedVariation && selectedVariation.id !== S.selPartId) {
                // Обновляем выбранный ID детали на новую вариацию
                S.selPartId = selectedVariationId;
                
                // Обновляем текст кнопки
                const buttonText = document.getElementById("variation-select-text");
                if (buttonText) {
                    buttonText.textContent = selectedVariation.name;
                }
                
                // Обновляем стиль опций
                const dropdown = document.getElementById("variation-dropdown");
                if (dropdown) {
                    dropdown.querySelectorAll('.variation-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    t.classList.add('selected');
                }
                
                // Закрываем выпадающее меню
                const button = document.getElementById("variation-select-button");
                if (button) {
                    button.classList.remove('open');
                }
                if (dropdown) {
                    dropdown.style.display = 'none';
                }
                // Обновляем данные модального окна детали для новой вариации
                const newPart = PART_MAP[selectedVariationId];
                if (newPart) {
                    S.partModal.imgUrl = newPart.rebrickable_img_url || null;
                    S.partModal.selColorId = null;
                    S.partModal.qty = 0;
                    
                    // Обновляем изображение
                    updateModalPartially({
                        image: true
                    });
                    
                    // Обновляем заголовок модального окна для отображения имени выбранной вариации
                    const modalTitle = document.querySelector('#modal-content h2');
                    if (modalTitle) {
                        modalTitle.textContent = selectedVariation.name;
                    }
                    
                    // Загружаем цвета для новой вариации
                    if (newPart.availableColorIds && newPart.availableColorIds.length > 0) {
                        S.partModal.selColorId = sortColorIds(newPart.availableColorIds, newPart.id)[0];
                        S.partModal.qty = S.coll[selectedVariationId]?.[S.partModal.selColorId] || 0;
                        updateModalPartially({
                            colors: true,
                            controls: true
                        });
                        fetchPartColorSpecifics(newPart.id, S.partModal.selColorId);
                    } else {
                        fetchPartColors(newPart.id);
                    }
                }
            }
            return;
        }
        
        const e = t.closest("[data-action]");
        if (e) {
            const {
                action: t,
                categoryId: o
            } = e.dataset;
            switch (t) {
                case "decrease-qty":
                    S.partModal.qty > 0 && (S.partModal.qty--, updateModalControlsState());
                    break;
                case "increase-qty":
                    S.partModal.qty++, updateModalControlsState();
                    break;
                case "update-collection":
                    S.selPartId && S.partModal.selColorId && await handleUpdateCollection(S.selPartId, S.partModal.selColorId, S.partModal.qty);
                    break;
                case "delete-from-collection-modal":
                    S.selPartId && S.partModal.selColorId && (await handleUpdateCollection(S.selPartId, S.partModal.selColorId, 0), S.partModal.qty = 0);
                    break;
                case "go-to-category":
                    o && (closeModal(), S.view = "catalog", S.multiSelect.active = false, S.multiSelect.items = new Set(), S.subView = "parts", S.selCatId = parseInt(o, 10), S.selFigNum = null, S.showRelatedSets = false, loadPartsForCategory(S.selCatId));
                    // Обновляем статистику после перехода к категории
                    setTimeout(() => updateFeelingLuckyStats(), 500);
                    break;
                case "retry-fetch-colors":
                    S.selPartId && fetchPartColors(S.selPartId)
            }
        }
        const o = t.closest("button[data-color-id]");
        if (o && o.dataset.colorId) {
            S.partModal.selColorId = o.dataset.colorId;
            S.partModal.qty = S.coll[S.selPartId]?.[S.partModal.selColorId] || 0;
            
            // Сначала обновляем элементы управления
            updateModalPartially({
                controls: !0
            });
            
            // Обновляем цвета без полной перерисовки, чтобы предотвратить скачки
            const colorContainer = document.getElementById("color-selector-container");
            if (colorContainer) {
                // Обновляем только стиль кнопки выбранного цвета
                const allColorButtons = colorContainer.querySelectorAll('button[data-color-id]');
                allColorButtons.forEach(btn => {
                    btn.classList.remove('border-blue-500', 'scale-110');
                    btn.classList.add('border-gray-600');
                });
                
                // Выделяем выбранный цвет
                const selectedButton = colorContainer.querySelector(`button[data-color-id="${S.partModal.selColorId}"]`);
                if (selectedButton) {
                    selectedButton.classList.remove('border-gray-600');
                    selectedButton.classList.add('border-blue-500', 'scale-110');
                }
            }
            
            fetchPartColorSpecifics(S.selPartId, S.partModal.selColorId);
        }
    }
}), document.addEventListener("keydown", e => {
    const activeElement = document.activeElement;
    
        if ("Escape" === e.key) {
            if (viewerEl.classList.contains("viewer-hidden")) {
                if (S.filterOpen) {
                    closeFilterModal();
                } else if (S.settingsOpen) {
                    closeSettingsModal();
                } else if (S.selSetNum) {
                    closeSetModal();
                } else if (S.selFigNum) {
                    closeMinifigModal();
                } else if (S.selPartId) {
                    closeModal();
                } else if (!relatedSetsModalEl.classList.contains("modal-hidden")) {
                    closeRelatedSetsModal();
                }
            } else {
                closeImageViewer();
            }
            
            // Двойное нажатие Escape для принудительного восстановления модальных окон
            if (e.repeat) {
                console.log('Double Escape detected, force restoring modals...');
                forceRestoreAllModals();
            }
    } else if ("Enter" === e.key && activeElement.id === "search-input") {
        triggerSearch();
    }
}), mainEl.addEventListener("scroll", () => {
    const threshold = 300;
    const isAtBottom = mainEl.scrollHeight - mainEl.scrollTop <= mainEl.clientHeight + threshold;

    if (isAtBottom && !S.loading && S.hasMoreItems) {
        S.toDisplay += S.increment;
        renderMainContent();
    }
    
    const e = mainEl.scrollTop > 300;
    e && toTopBtn.classList.contains("opacity-0") ? toTopBtn.classList.remove("opacity-0", "pointer-events-none", "translate-y-4") : !e && !toTopBtn.classList.contains("opacity-0") && toTopBtn.classList.add("opacity-0", "pointer-events-none", "translate-y-4")
});

// Функция для фоновой предзагрузки остальных изображений
async function preloadRemainingImagesInBackground() {
    try {
        // Предзагружаем остальные изображения деталей (51-100)
        // console.log('Background preloading remaining part images (51-100)...');
        // const remainingPartPromises = [];
        // for (let i = 51; i <= 100; i++) {
        //     const img = new Image();
        //     const preloadPromise = new Promise((resolve) => {
        //         img.onload = () => resolve();
        //         img.onerror = () => {
        //             console.warn(`Failed to preload part image part-${i}.png (folder may not exist)`);
        //             resolve();
        //         };
        //         img.src = `./Parts_png/part-${i}.png`;
        //     });
        //     remainingPartPromises.push(preloadPromise);
        // }
        
        // Предзагружаем остальные изображения наборов (21-50)
        // console.log('Background preloading remaining set images (21-50)...');
        // const remainingSetPromises = [];
        // for (let i = 21; i <= 50; i++) {
        //     const img = new Image();
        //         const preloadPromise = new Promise((resolve) => {
        //             img.onload = () => resolve();
        //             img.onerror = () => {
        //                 console.warn(`Failed to preload set image set-${i}.png (folder may not exist)`);
        //                 resolve();
        //             };
        //             img.src = `./Sets_png/set-${i}.png`;
        //         };
        //         remainingSetPromises.push(preloadPromise);
        // }
        
        // Загружаем все изображения параллельно в фоновом режиме
        // await Promise.all([...remainingPartPromises, ...remainingSetPromises]);
        console.log('Background image preloading disabled - Parts_png and Sets_png folders not found');
        
    } catch (error) {
        console.error('Error preloading remaining images in background:', error);
    }
}

// Функция для предварительной загрузки изображений в кэш
async function preloadImages() {
    try {
        // Предзагружаем изображения минифигурок
        const minifigCount = window.MINIFIG_COUNT || 30; // Используем количество из загруженного файла или fallback
        console.log(`Preloading ${minifigCount} minifig images...`);
        
        const minifigPromises = [];
        for (let i = 1; i <= minifigCount; i++) {
            const img = new Image();
            const preloadPromise = new Promise((resolve) => {
                img.onload = () => resolve();
                img.onerror = () => {
                    console.warn(`Failed to preload minifig image fig-${i}.png`);
                    resolve(); // Не прерываем загрузку других изображений при ошибке
                };
                img.src = `./Minifig_png/fig-${i}.png`;
            });
            minifigPromises.push(preloadPromise);
        }
        
        // Предзагружаем популярные изображения деталей (первые 50)
        // console.log('Preloading popular part images...');
        // const partPromises = [];
        // for (let i = 1; i <= 50; i++) {
        //     const img = new Image();
        //     const preloadPromise = new Promise((resolve) => {
        //         img.onload = () => resolve();
        //         img.onerror = () => {
        //             console.warn(`Failed to preload part image part-${i}.png (folder may not exist)`);
        //             resolve();
        //         };
        //         img.src = `./Parts_png/part-${i}.png`;
        //     });
        //     partPromises.push(preloadPromise);
        // }
        
        // Предзагружаем популярные изображения наборов (первые 20)
        // console.log('Preloading popular set images...');
        // const setPromises = [];
        // for (let i = 1; i <= 20; i++) {
        //     const img = new Image();
        //     const preloadPromise = new Promise((resolve) => {
        //         img.onload = () => resolve();
        //         img.onerror = () => {
        //             console.warn(`Failed to preload set image set-${i}.png (folder may not exist)`);
        //             resolve();
        //         };
        //         img.src = `./Sets_png/set-${i}.png`;
        //     });
        //     setPromises.push(preloadPromise);
        // }
        
        // Загружаем все изображения параллельно
        await Promise.all([...minifigPromises]);
        console.log(`Successfully preloaded ${minifigCount} minifig images`);
        
        // Обновляем прогресс загрузки
        updateLoadingStatus("Кэширование завершено", 92, "Основные изображения загружены в кэш");
        
    } catch (error) {
        console.error('Error preloading images:', error);
    }
}

async function initializeApp() {
    // Массив подсказок для кнопки "мне повезёт"
    window.FEELING_LUCKY_TIPS = [
        "🎲 Удерживайте кнопки 'Детали', 'Наборы' или 'Фигурки' 1 секунду для случайного элемента",
        "💡 После обновления сайта обязательно очистите кэш в настройках сайта для корректной работы",
        "🔍 Используйте поиск по названию для быстрого нахождения нужных деталей",
        "🎨 Фильтруйте детали по цвету для точного подбора к вашей коллекции",
        "📱 Сайт адаптирован для мобильных устройств - удобно использовать на телефоне",
        "⭐ Добавляйте часто используемые категории в избранное для быстрого доступа",
        "🔄 При проблемах с загрузкой попробуйте обновить страницу или очистить кэш",
        "💡 После обновления сайта обязательно очистите кэш в настройках сайта для корректной работы",
        "📊 Статистика показывает общее количество элементов в каталоге",
        "🎯 Кнопка 'мне повезёт' показывает случайные элементы из всего каталога",
        "💾 Данные сохраняются локально в браузере для быстрой работы",
        "🖼️ Изображения загружаются автоматически при просмотре деталей",
        "🔧 Используйте фильтры по темам для поиска наборов определенной серии",
        "📋 Переключайтесь между каталогом и коллекцией для разных задач",
        "💡 После обновления сайта обязательно очистите кэш в настройках сайта для корректной работы",
        "⚡ Сайт работает офлайн после первой загрузки данных",
        "🔄 Регулярно обновляйте данные для получения актуальной информации",
        "🎯 Используйте комбинацию фильтров для точного поиска нужных элементов",
        "📱 На мобильных устройствах используйте свайпы для навигации",
        "🔍 Поиск работает по частичному совпадению - не нужно вводить полное название",
        "⭐ Добавляйте в избранное часто используемые темы для быстрого доступа",
        "📊 В коллекции можно группировать детали по названию для удобства",
        "🖼️ Нажмите на изображение детали для просмотра в полном размере",
        "💡 После обновления сайта обязательно очистите кэш в настройках сайта для корректной работы",
        "📋 Экспортируйте свою коллекцию в формате CSV",
        "🎲 Статистика обновляется в реальном времени при изменении коллекции",
        "⚡ Быстрый поиск работает даже при медленном интернете",
        "🔄 Автосохранение состояния происходит после каждого действия",
        "🎯 Клик по карточке открывает детальную информацию",
        "💡 После обновления сайта обязательно очистите кэш в настройках сайта для корректной работы",
        "🔍 Фильтры можно комбинировать для создания сложных запросов",
        "🎨 Используйте цветовые фильтры для подбора деталей к набору",
        "📊 Отслеживайте статистику использования различных элементов",
        "🖼️ Предзагрузка изображений ускоряет работу с каталогом",
        "🔧 Настройки интерфейса сохраняются между сессиями",
        "📋 Импортируйте коллекции из других источников",
        "🎲 Удерживайте кнопку Детали/Наборы/Фигурки 1 секунду для случайного элемента",
        "📱 Интерфейс оптимизирован для всех устройств"
    ];
    
    console.log('FEELING_LUCKY_TIPS initialized with', window.FEELING_LUCKY_TIPS.length, 'tips');
    
    // Массив подсказок для экрана загрузки
    window.LOADING_TIPS = [
        "🎲 Удерживайте кнопки 'Детали', 'Наборы' или 'Фигурки' 1 секунду для случайного элемента",
        "💡 После обновления сайта обязательно очистите кэш в настройках сайта для корректной работы",
        "🔍 Используйте поиск по названию для быстрого нахождения нужных деталей",
        "🎨 Фильтруйте детали по цвету для точного подбора к вашей коллекции",
        "📱 Сайт адаптирован для мобильных устройств - удобно использовать на телефоне",
        "❤️ Добавляйте часто используемые категории в избранное для быстрого доступа",
        "🔄 При проблемах с загрузкой попробуйте обновить страницу или очистить кэш",
        "📊 Статистика показывает общее количество элементов в каталоге",
        "🎯 Кнопка 'мне повезёт' показывает случайные элементы из всего каталога",
        "💾 Данные сохраняются локально в браузере для быстрой работы",
        "🖼️ Изображения загружаются автоматически при просмотре деталей",
        "🔧 Используйте фильтры по темам для поиска наборов определенной серии",
        "📋 Переключайтесь между каталогом и коллекцией для разных задач",
        "⚡ Сайт работает офлайн после первой загрузки данных",
        "💡 После обновления сайта обязательно очистите кэш в настройках сайта для корректной работы",
        "🔄 Регулярно обновляйте данные для получения актуальной информации",
        "🎯 Используйте комбинацию фильтров для точного поиска нужных элементов",
        "📱 На мобильных устройствах используйте свайпы для навигации",
        "🔍 Поиск работает по частичному совпадению - не нужно вводить полное название",
        "⭐ Добавляйте в избранное часто используемые темы для быстрого доступа",
        "📊 В коллекции можно группировать детали по названию для удобства",
        "🖼️ Нажмите на изображение детали для просмотра в полном размере",
        "📋 Экспортируйте свою коллекцию в формате CSV",
        "🎲 Статистика обновляется в реальном времени при изменении коллекции",
        "⚡ Быстрый поиск работает даже при медленном интернете",
        "🔄 Автосохранение состояния происходит после каждого действия",
        "🎯 Клик по карточке открывает детальную информацию",
        "🔍 Фильтры можно комбинировать для создания сложных запросов",
        "🎨 Используйте цветовые фильтры для подбора деталей к набору",
        "💡 После обновления сайта обязательно очистите кэш в настройках сайта для корректной работы",
        "📊 Отслеживайте статистику использования различных элементов",
        "🖼️ Предзагрузка изображений ускоряет работу с каталогом",
        "🔧 Настройки интерфейса сохраняются между сессиями",
        "📋 Импортируйте коллекции из других источников",
        "💡 Все подсказки содержат полезную информацию по использованию сайта"
    ];
    
    console.log('LOADING_TIPS initialized with', window.LOADING_TIPS.length, 'tips');
    
    // Глобальные переменные для отслеживания последних подсказок
    window.LAST_TIPS_HISTORY = {
        feelingLucky: [],
        loading: [],
        maxHistory: 3 // Храним последние 3 подсказки
    };
    
    // Функция для получения случайной подсказки
    window.getRandomTip = function() {
        if (!window.FEELING_LUCKY_TIPS || window.FEELING_LUCKY_TIPS.length === 0) {
            console.error('FEELING_LUCKY_TIPS array is not available');
            return '💡 Подсказка недоступна';
        }
        
        // Получаем текущую подсказку для исключения
        const currentTip = document.getElementById('feeling-lucky-tip')?.textContent || '';
        
        // Фильтруем подсказки, исключая текущую и последние из истории
        const availableTips = window.FEELING_LUCKY_TIPS.filter(tip => 
            tip !== currentTip && !window.LAST_TIPS_HISTORY.feelingLucky.includes(tip)
        );
        
        if (availableTips.length === 0) {
            // Если все подсказки в истории, очищаем историю и начинаем заново
            console.log('All tips are in history, clearing history');
            window.LAST_TIPS_HISTORY.feelingLucky = [];
            
            // Исключаем только текущую подсказку
            const freshTips = window.FEELING_LUCKY_TIPS.filter(tip => tip !== currentTip);
            if (freshTips.length === 0) {
                // Если все подсказки одинаковые, возвращаем любую
                const randomIndex = Math.floor(Math.random() * window.FEELING_LUCKY_TIPS.length);
                const tip = window.FEELING_LUCKY_TIPS[randomIndex];
                console.log(`All tips are the same, selected: index ${randomIndex}, tip: ${tip}`);
                return tip;
            }
            
            const randomIndex = Math.floor(Math.random() * freshTips.length);
            const tip = freshTips[randomIndex];
            console.log(`Fresh tip selected after history clear: index ${randomIndex}, tip: ${tip}`);
            return tip;
        }
        
        // Выбираем случайную подсказку из доступных
        const randomIndex = Math.floor(Math.random() * availableTips.length);
        const tip = availableTips[randomIndex];
        console.log(`Random tip selected (excluding current and history): index ${randomIndex}, tip: ${tip}`);
        return tip;
    };
    
    // Функция для получения случайной подсказки для экрана загрузки
    window.getRandomLoadingTip = function() {
        if (!window.LOADING_TIPS || window.LOADING_TIPS.length === 0) {
            console.error('LOADING_TIPS array is not available');
            return '💡 Загружаем полезные советы...';
        }
        
        // Получаем текущую подсказку для исключения
        const currentTip = document.getElementById('loading-tip')?.textContent || '';
        
        // Фильтруем подсказки, исключая текущую и последние из истории
        const availableTips = window.LOADING_TIPS.filter(tip => 
            tip !== currentTip && !window.LAST_TIPS_HISTORY.loading.includes(tip)
        );
        
        if (availableTips.length === 0) {
            // Если все подсказки в истории, очищаем историю и начинаем заново
            console.log('All loading tips are in history, clearing history');
            window.LAST_TIPS_HISTORY.loading = [];
            
            // Исключаем только текущую подсказку
            const freshTips = window.LOADING_TIPS.filter(tip => tip !== currentTip);
            if (freshTips.length === 0) {
                // Если все подсказки одинаковые, возвращаем любую
                const randomIndex = Math.floor(Math.random() * window.FEELING_LUCKY_TIPS.length);
                const tip = window.LOADING_TIPS[randomIndex];
                console.log(`All loading tips are the same, selected: index ${randomIndex}, tip: ${tip}`);
                return tip;
            }
            
            const randomIndex = Math.floor(Math.random() * freshTips.length);
            const tip = freshTips[randomIndex];
            console.log(`Fresh loading tip selected after history clear: index ${randomIndex}, tip: ${tip}`);
            return tip;
        }
        
        // Выбираем случайную подсказку из доступных
        const randomIndex = Math.floor(Math.random() * availableTips.length);
        const tip = availableTips[randomIndex];
        console.log(`Random loading tip selected (excluding current and history): index ${randomIndex}, tip: ${tip}`);
        return tip;
    };
    
    // Функция для красивой анимации смены подсказок
    window.animateTipChange = function(element, newTip, onComplete = null) {
        if (!element) return;
        
        // Добавляем класс для анимации исчезновения
        element.classList.add('fade-out');
        
        // Ждем завершения анимации исчезновения
        setTimeout(() => {
            // Меняем текст
            element.textContent = newTip;
            
            // Убираем класс исчезновения и добавляем класс появления
            element.classList.remove('fade-out');
            element.classList.add('fade-in');
            
            // Добавляем небольшую задержку для плавности
            setTimeout(() => {
                // Показываем новую подсказку
                element.classList.add('show');
                
                // Добавляем пульсацию для привлечения внимания
                element.classList.add('pulse');
                
                // Убираем пульсацию через 2 секунды
                setTimeout(() => {
                    element.classList.remove('pulse');
                }, 2000);
                
                // Убираем классы анимации
                setTimeout(() => {
                    element.classList.remove('fade-in', 'show');
                }, 600);
                
                // Вызываем callback если он есть
                if (onComplete) onComplete();
            }, 50);
        }, 300);
    };
    
    // Функция для добавления подсказки в историю
    window.addTipToHistory = function(tip, type = 'feelingLucky') {
        if (!window.LAST_TIPS_HISTORY || !window.LAST_TIPS_HISTORY[type]) return;
        
        const history = window.LAST_TIPS_HISTORY[type];
        
        // Добавляем новую подсказку в начало массива
        history.unshift(tip);
        
        // Ограничиваем размер истории
        if (history.length > window.LAST_TIPS_HISTORY.maxHistory) {
            history.pop();
        }
        
        console.log(`Added tip to ${type} history:`, tip);
        console.log(`Current ${type} history:`, history);
    };
    
    // Функция для автоматической смены подсказок каждые 5 секунд
    window.startTipRotation = function() {
        console.log('🔄 startTipRotation called, current interval:', window.tipRotationInterval);
        
        // Защита от множественного запуска
        if (window.tipRotationInterval) {
            console.log('⚠️ Tip rotation already running, skipping start request');
            return;
        }
        
        let tipElement = document.getElementById('feeling-lucky-tip');
        
        // Если элемент не найден, попробуем найти его через несколько секунд
        if (!tipElement) {
            console.log('🔍 Tip element not found, waiting for it to appear...');
            let attempts = 0;
            const maxAttempts = 10;
            
            const waitForElement = setInterval(() => {
                tipElement = document.getElementById('feeling-lucky-tip');
                attempts++;
                
                if (tipElement) {
                    clearInterval(waitForElement);
                    console.log('✅ Tip element found after', attempts, 'attempts');
                    startRotation();
                } else if (attempts >= maxAttempts) {
                    clearInterval(waitForElement);
                    console.log('❌ Tip element not found after', maxAttempts, 'attempts, giving up');
                    return;
                }
            }, 500);
            
            return;
        }
        
        startRotation();
        
        function startRotation() {
            console.log('🎯 startRotation called, current tip:', tipElement.textContent);
            
            // Останавливаем предыдущий интервал, если он существует
            if (window.tipRotationInterval) {
                clearInterval(window.tipRotationInterval);
                console.log('🧹 Cleared previous tip rotation interval');
            }
            
            // Запускаем автоматическую смену подсказок каждые 5 секунд
            window.tipRotationInterval = setInterval(() => {
                if (tipElement && window.getRandomTip && window.animateTipChange) {
                    const newTip = window.getRandomTip();
                    console.log('🔄 Rotating tip to:', newTip);
                    window.animateTipChange(tipElement, newTip, () => {
                        console.log('✅ Tip rotated to:', newTip);
                        // Добавляем подсказку в историю
                        if (window.addTipToHistory) {
                            window.addTipToHistory(newTip, 'feelingLucky');
                        }
                    });
                }
            }, 5000);
            
            console.log('🚀 Tip rotation started, interval ID:', window.tipRotationInterval);
        }
    };
    
    // Функция для остановки автоматической смены подсказок
    window.stopTipRotation = function() {
        console.log('🛑 stopTipRotation called, current interval:', window.tipRotationInterval);
        if (window.tipRotationInterval) {
            console.log('🛑 Stopping tip rotation, interval ID:', window.tipRotationInterval);
            clearInterval(window.tipRotationInterval);
            window.tipRotationInterval = null;
            console.log('✅ Tip rotation stopped');
        } else {
            console.log('ℹ️ No tip rotation interval to stop');
        }
    };
    
    // Функция для принудительного запуска автоматической смены подсказок (для тестирования)
    window.forceStartTipRotation = function() {
        console.log('Force starting tip rotation...');
        if (window.startTipRotation) {
            window.startTipRotation();
        } else {
            console.error('startTipRotation function not available');
        }
    };
    
    // Функция для проверки состояния автоматической смены подсказок
    window.checkTipRotationStatus = function() {
        console.log('🔍 Tip rotation status:');
        console.log('- FEELING_LUCKY_TIPS array length:', window.FEELING_LUCKY_TIPS ? window.FEELING_LUCKY_TIPS.length : 'undefined');
        console.log('- getRandomTip function available:', !!window.getRandomTip);
        console.log('- startTipRotation function available:', !!window.startTipRotation);
        console.log('- stopTipRotation function available:', !!window.stopTipRotation);
        console.log('- Current interval ID:', window.tipRotationInterval);
        console.log('- Tip element exists:', !!document.getElementById('feeling-lucky-tip'));
        
        const tipElement = document.getElementById('feeling-lucky-tip');
        if (tipElement) {
            console.log('- Current tip text:', tipElement.textContent);
        }
    };
    
    // Добавляем глобальную дебаг команду для анализа состояния
    window.debugFeelingLucky = function() {
        console.log('🔍 === DEBUG FEELING LUCKY ===');
        console.log('S.view:', S.view);
        console.log('S.subView:', S.subView);
        console.log('S.loading:', S.loading);
        console.log('S.err:', S.err);
        console.log('window.tipRotationInterval:', window.tipRotationInterval);
        console.log('window.startTipRotation available:', !!window.startTipRotation);
        console.log('window.stopTipRotation available:', !!window.stopTipRotation);
        console.log('window.getRandomTip available:', !!window.getRandomTip);
        console.log('window.animateTipChange available:', !!window.animateTipChange);
        console.log('feeling-lucky-button exists:', !!document.getElementById('feeling-lucky-button'));
        console.log('feeling-lucky-stats exists:', !!document.getElementById('feeling-lucky-stats'));
        console.log('feeling-lucky-tip exists:', !!document.getElementById('feeling-lucky-tip'));
        console.log('=== END DEBUG ===');
    };
    
    // Добавляем дебаг команду для проверки состояния прокрутки
    window.debugScrollState = function() {
        console.log('📜 === DEBUG SCROLL STATE ===');
        console.log('S.toDisplay:', S.toDisplay);
        console.log('S.totalItems:', S.totalItems);
        console.log('S.hasMoreItems:', S.hasMoreItems);
        console.log('S.increment:', S.increment);
        console.log('S.loadedItems:', S.loadedItems);
        console.log('mainEl.scrollHeight:', mainEl?.scrollHeight);
        console.log('mainEl.clientHeight:', mainEl?.clientHeight);
        console.log('mainEl.scrollTop:', mainEl?.scrollTop);
        console.log('Scroll listener attribute:', mainEl?.getAttribute('data-scroll-listener'));
        console.log('=== END SCROLL DEBUG ===');
    };
    
    // Функция для автоматической смены подсказок на экране загрузки
    window.startLoadingTipRotation = function() {
        const loadingTipElement = document.getElementById('loading-tip');
        if (!loadingTipElement) {
            console.log('Loading tip element not found, cannot start rotation');
            return;
        }
        
        console.log('Starting loading tip rotation, current tip:', loadingTipElement.textContent);
        
        // Останавливаем предыдущий интервал, если он существует
        if (window.loadingTipRotationInterval) {
            clearInterval(window.loadingTipRotationInterval);
            console.log('Cleared previous loading tip rotation interval');
        }
        
        // Запускаем автоматическую смену подсказок каждые 3 секунды (быстрее чем на основном экране)
        window.loadingTipRotationInterval = setInterval(() => {
            if (loadingTipElement && window.getRandomLoadingTip && window.animateTipChange) {
                const newTip = window.getRandomLoadingTip();
                window.animateTipChange(loadingTipElement, newTip, () => {
                    console.log('Loading tip rotated to:', newTip);
                    // Добавляем подсказку в историю
                    if (window.addTipToHistory) {
                        window.addTipToHistory(newTip, 'loading');
                    }
                });
            }
        }, 3000);
        
        console.log('Loading tip rotation started, interval ID:', window.loadingTipRotationInterval);
    };
    
    // Функция для остановки автоматической смены подсказок на экране загрузки
    window.stopLoadingTipRotation = function() {
        if (window.loadingTipRotationInterval) {
            console.log('Stopping loading tip rotation, interval ID:', window.loadingTipRotationInterval);
            clearInterval(window.loadingTipRotationInterval);
            window.loadingTipRotationInterval = null;
            console.log('Loading tip rotation stopped');
        } else {
            console.log('No loading tip rotation interval to stop');
        }
    };
    
    // ВРЕМЕННО ОТКЛЮЧЕНО: Добавляем класс для анимации первой загрузки страницы
    // document.body.classList.add('page-loading');
    
    // Немедленно показываем индикатор загрузки
    updateLoadingStatus("Инициализация приложения...", 5, "Загрузка состояния и подготовка данных");
    
    // Запускаем автоматическую смену подсказок на экране загрузки
    setTimeout(() => {
        if (window.startLoadingTipRotation) {
            console.log('Starting loading tip rotation...');
            window.startLoadingTipRotation();
        }
    }, 1000);
    
    // Сбрасываем случайное изображение минифигурки при инициализации приложения
    resetRandomMinifigImage();
    
    loadState();
    
    // Инициализируем агрегатор прогресса загрузки CSV
    try {
        window.CSV_MB_PROGRESS = { totalBytes: 0, totalExpected: 0 };
    } catch {}

    S.sidebarLoading = true;
    updateUI();

    try {
        console.log('Starting data loading from CSV...');
        
        // Всегда сначала загружаем данные из CSV файлов (быстро, офлайн)
        await loadDataFromCSV();
        
        console.log('CSV data loading completed');
        console.log('PART_MAP size after CSV loading:', Object.keys(PART_MAP).length);
        
        // Загружаем информацию о количестве доступных изображений минифигурок
        try {
            const response = await fetch('./Minifig_png/minifig-count.txt');
            if (response.ok) {
                const count = await response.text();
                window.MINIFIG_COUNT = parseInt(count.trim());
                console.log('Minifig count loaded:', window.MINIFIG_COUNT);
            }
        } catch (e) {
            console.log('Minifig count file not found, using fallback range 1-30');
        }
        
        // Предзагружаем изображения в кэш
        updateLoadingStatus("Кэширование изображений...", 90, "Предзагрузка изображений минифигурок");
        await preloadImages();
        
        // Проверяем наличие новых данных из API в фоновом режиме (без перегрузки)
        updateLoadingStatus("Проверка обновлений...", 95, "Проверка новых данных из API");
        checkForNewDataInBackground();
        
    } catch (e) {
        console.error("Data loading failed:", e);
        S.err = S.err || `Не удалось загрузить данные каталога: ${e.message}`;
    } finally {
        S.sidebarLoading = false;
        updateUI();
    }

            // Загружаем данные коллекции, если у пользователя есть
    (async () => {
        try {
            if (Object.keys(S.coll).length > 0) {
                await fetchMissingCollectionPartDetails();
                await ensureBasicPartImagesForCollection();
                // Не загружаем изображения конкретных цветов автоматически, чтобы избежать задержек
                // Пользователь может использовать кнопку обновления, если нужно
            }
            
            if (Object.keys(S.setColl).length > 0) {
                await fetchMissingCollectionSetDetails();
            }
            
            if (Object.keys(S.minifigColl).length > 0) {
                await fetchMissingCollectionMinifigDetails();
            }
            
            // Сохраняем состояние после фоновой загрузки
            saveState();
            
            // Обновляем UI, если необходимо
            if (S.view === 'collection') {
                S.gridStale = true;
                updateUI();
            }
            
            // Настраиваем слушатель прокрутки для автоматической загрузки изображений
            setupScrollListener();
            
            // Теперь загружаем отсутствующие изображения после того, как все данные загружены
            console.log('Loading missing images after all data is loaded...');
            await fetchMissingImagesFromCSV();
            
            // Фоновая предзагрузка остальных изображений
            console.log('Starting background image preloading...');
            preloadRemainingImagesInBackground();
            
            // Окончательное завершение загрузки
            updateLoadingStatus("Загрузка завершена!", 100, "Приложение готово к использованию");
            
            // ВРЕМЕННО ОТКЛЮЧЕНО: Убираем класс для анимации первой загрузки страницы
            // setTimeout(() => {
            //     document.body.classList.remove('page-loading');
            // }, 500);
            
            setTimeout(() => {
                hideLoadingIndicator();
                
                // Анимация появления кнопок
                animateButtonsAppearance();
                
                // Показываем указатель sidebar-toggle на малых устройствах для первой загрузки
                setTimeout(() => {
                    showSidebarHint();
                }, 1500);
                
                // Запускаем автоматическую смену подсказок после полной загрузки приложения
                // ОТКЛЮЧЕНО: конфликт с системой неактивности
                // setTimeout(() => {
                //     if (window.startTipRotation) {
                //         console.log('Starting automatic tip rotation...');
                //         window.startTipRotation();
                //     }
                // }, 2000);
            }, 1000);
            
        } catch (e) {
            console.error("Background collection data fetch failed:", e);
            // Скрываем индикатор загрузки даже при ошибке
            updateLoadingStatus("Загрузка завершена с предупреждениями", 100, "Приложение готово к использованию");
            setTimeout(() => {
                hideLoadingIndicator();
            }, 1000);
        }
    })();
}
document.addEventListener("DOMContentLoaded", () => {
    // Защита от случайного масштабирования страницы
    document.addEventListener('wheel', (e) => {
        if (e.ctrlKey) {
            e.preventDefault();
        }
    }, { passive: false });
    
    // Блокировка жестов масштабирования на мобильных устройствах
    document.addEventListener('gesturestart', (e) => e.preventDefault());
    document.addEventListener('gesturechange', (e) => e.preventDefault());
    document.addEventListener('gestureend', (e) => e.preventDefault());
    
    viewerCloseBtn.innerHTML = I_X("w-6 h-6");
            // Добавляем слушатель события для импорта CSV файла
    const csvImportInput = document.getElementById('import-csv-input');
    if (csvImportInput) {
        csvImportInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                try {
                    const content = await file.text();
                    await processCsvData(content);
                    // Очищаем ввод после успешного импорта
                    event.target.value = '';
                    // Обновляем UI
                    S.gridStale = true;
                    updateUI();
                } catch (error) {
                    console.error('CSV import failed:', error);
                    // Очищаем ввод в случае ошибки
                    event.target.value = '';
                }
            }
        });
    }
    
    initializeApp();

    // S.preventAccidentalExit уже инициализирован из localStorage при создании S

    // Защита от случайной перезагрузки/закрытия вкладки
    window.addEventListener('beforeunload', (event) => {
        try {
            if (!S || !S.preventAccidentalExit) return;
            // Сбрасываем случайное изображение минифигурки при закрытии/обновлении страницы
            resetRandomMinifigImage();
            // Останавливаем автоматическую смену подсказок
            if (window.stopTipRotation) {
                window.stopTipRotation();
            }
            
            // Останавливаем автоматическую смену подсказок на экране загрузки
            if (window.stopLoadingTipRotation) {
                window.stopLoadingTipRotation();
            }
            event.preventDefault();
            event.returnValue = '';
        } catch {}
    });

    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            if (!window.isSecureContext && location.hostname !== 'localhost') {
                console.warn('Service Worker требует безопасный контекст (https или localhost). Сейчас: ', location.protocol);
            }
            // Проверяем обновления Service Worker
            navigator.serviceWorker.register('./service-worker.js', { scope: './' })
                .then(registration => {
                    console.log('ServiceWorker registration successful with scope:', registration.scope);
                    
                    // Проверяем обновления
                    registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing;
                        console.log('Service Worker update found');
                        
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                // Новый Service Worker готов, предлагаем пользователю обновить
                                console.log('New service worker ready, prompting update');
                                if (confirm('Доступно обновление приложения. Обновить сейчас?')) {
                                    newWorker.postMessage({ type: 'SKIP_WAITING' });
                                    window.location.reload();
                                }
                            }
                        });
                    });
                    
                    return navigator.serviceWorker.ready;
                })
                .then(() => {
                    console.log('ServiceWorker is active and ready.');
                    
                    // Слушаем сообщения от Service Worker
                    navigator.serviceWorker.addEventListener('message', event => {
                        if (event.data && event.data.type === 'RELOAD_PAGE') {
                            window.location.reload();
                        }
                    });
                    
                    // Добавляем функции управления кэшем
                    window.clearAppCache = async () => {
                        try {
                            const cacheNames = await caches.keys();
                            await Promise.all(
                                cacheNames.map(cacheName => {
                                    if (cacheName.startsWith('lego-catalog-cache')) {
                                        console.log('Deleting cache:', cacheName);
                                        return caches.delete(cacheName);
                                    }
                                })
                            );
                            
                            // Сбрасываем статистику API при очистке кэша
                            try {
                                const initialStats = {
                                    colors: 0,
                                    parts: 0,
                                    sets: 0,
                                    minifigs: 0,
                                    images: 0,
                                    lastUpdate: null
                                };
                                localStorage.setItem('legoApiStats', JSON.stringify(initialStats));
                                window.API_STATS = initialStats;
                                console.log('API stats reset successfully');
                            } catch (statsError) {
                                console.error('Failed to reset API stats:', statsError);
                            }
                            
                            console.log('App cache cleared successfully');
                            return true;
                        } catch (error) {
                            console.error('Failed to clear cache:', error);
                            return false;
                        }
                    };
                    
                    window.getCacheInfo = async () => {
                        try {
                            const cacheNames = await caches.keys();
                            const cacheInfo = {};
                            
                            for (const cacheName of cacheNames) {
                                if (cacheName.startsWith('lego-catalog-cache')) {
                                    const cache = await caches.open(cacheName);
                                    const keys = await cache.keys();
                                    cacheInfo[cacheName] = keys.length;
                                }
                            }
                            
                            return cacheInfo;
                        } catch (error) {
                            console.error('Failed to get cache info:', error);
                            return {};
                        }
                    };
                })
                .catch(error => {
                    console.log('ServiceWorker registration failed:', error);
                });
        });
    }

    // PWA install prompt (приглашение установить как приложение)
    (function(){
        let deferredInstallPrompt = null;
        let pwaPromptShown = false;
        let loadTimestamp = null;
        try {
            pwaPromptShown = localStorage.getItem('pwaPromptShown') === 'true';
        } catch {}
        window.addEventListener('load', () => { loadTimestamp = Date.now(); });

        window.addEventListener('beforeinstallprompt', (e) => {
            // Блокируем авто-показ системного баннера
            e.preventDefault();
            deferredInstallPrompt = e;
            if (!pwaPromptShown) {
                const now = Date.now();
                const base = loadTimestamp || now;
                const delay = Math.max(0, 3000 - (now - base));
                setTimeout(() => {
                    showPwaInstallNotice();
                    try { localStorage.setItem('pwaPromptShown', 'true'); } catch {}
                }, delay);
                pwaPromptShown = true;
            }
        });

        window.addEventListener('appinstalled', () => {
            deferredInstallPrompt = null;
            try { localStorage.setItem('pwaPromptShown', 'true'); } catch {}
        });

        function showPwaInstallNotice() {
            // Баннер в стиле блоков настроек только для мобильных устройств
            const bar = document.createElement('div');
            bar.setAttribute('role', 'dialog');
            bar.className = 'fixed inset-0 z-[70] pointer-events-none sm:hidden';
            bar.innerHTML = `
                <div class="flex justify-end p-4">
                    <div class="pointer-events-auto w-full max-w-md bg-gray-900/80 backdrop-blur-md rounded-lg p-4 border border-gray-700 shadow-xl mb-4">
                        <div class="flex flex-col items-start gap-3">
                            <div class="flex-1 min-w-0">
                                <div class="text-sm font-semibold text-gray-300 mb-1">Установите LEGO Catalog как приложение</div>
                                <div class="text-xs text-gray-400">Быстрый доступ, офлайн-режим и нативный интерфейс</div>
                            </div>
                            <div class="flex items-center gap-2 w-full justify-center">
                                <button id="pwa-install-btn" class="flex-1 px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-blue-600 hover:bg-blue-700 text-white">Установить</button>
                                <button id="pwa-install-dismiss" class="flex-1 px-3 py-2 text-sm rounded-md text-gray-300 hover:text-white hover:bg-gray-700/60">Позже</button>
                            </div>
                        </div>
                    </div>
                </div>`;
            document.body.appendChild(bar);

            const onDismiss = () => { bar.remove(); };
            const onInstall = async () => {
                if (!deferredInstallPrompt) { onDismiss(); return; }
                try {
                    deferredInstallPrompt.prompt();
                    await deferredInstallPrompt.userChoice;
                } catch {}
                deferredInstallPrompt = null;
                onDismiss();
            };
            document.getElementById('pwa-install-dismiss')?.addEventListener('click', onDismiss, { once: true });
            document.getElementById('pwa-install-btn')?.addEventListener('click', onInstall, { once: true });
        }
    })();
});
// Функция для загрузки данных из CSV файлов последовательно по приоритету
// Теперь файлы загружаются по очереди, начиная с самых важных для работы приложения
async function loadDataFromCSV() {
    try {
        // Фаза 1: Критические данные для навигации по боковой панели (загружаем первыми)
        updateLoadingStatus("Загрузка критических данных...", 10, "Подготовка к загрузке");
        
        // Загружаем категории ПЕРВЫМИ (самые важные для навигации)
        updateLoadingStatus("Загрузка категорий деталей...", 20, "Категории необходимы для навигации");
        await loadCategoriesFromCSV();
        
        // Загружаем темы (для навигации по наборам)
        updateLoadingStatus("Загрузка тем наборов...", 30, "Темы необходимы для навигации по наборам");
        await loadThemesFromCSV();
        
        // Загружаем цвета (необходимы для отображения деталей)
        updateLoadingStatus("Загрузка цветов...", 40, "Цвета необходимы для отображения деталей");
        await loadColorsFromCSV();
        
        // Фаза 2: Основные данные каталога (загружаем последовательно по приоритету для стабильности)
        // Последовательная загрузка обеспечивает стабильность и предсказуемость процесса
        updateLoadingStatus("Загрузка деталей...", 50, "Детали - основа каталога");
        await loadPartsFromCSV();
        
        updateLoadingStatus("Загрузка наборов...", 60, "Наборы LEGO");
        await loadSetsFromCSV();
        
        updateLoadingStatus("Загрузка минифигурок...", 65, "Минифигурки");
        await loadMinifigsFromCSV();
        
        updateLoadingStatus("Загрузка дополнительных данных...", 70, "Загрузка элементов и инвентарей");
        
        // Фаза 3: Дополнительные данные (загружаем последними, так как зависят от основных данных)
        await loadElementsFromCSV();
        await loadInventoriesFromCSV();
        
        updateLoadingStatus("Завершение загрузки...", 90, "Сохранение состояния и обновление интерфейса");
        
        // Сохраняем состояние после загрузки CSV
        saveState();
        
        // Отладка: выводим статистику загруженных данных
        console.log('CSV Data loaded successfully:');
        console.log('- Parts:', Object.keys(PART_MAP).length);
        console.log('- Sets:', Object.keys(SET_MAP).length);
        console.log('- Minifigs:', Object.keys(MINIFIG_MAP).length);
        console.log('- Colors:', Object.keys(COLOR_MAP).length);
        console.log('- Categories:', flatCategories.length);
        console.log('- Themes:', Object.keys(THEME_MAP).length);
        
        // Глобальная сортировка всех данных после загрузки
        console.log('📅 Starting global sorting of all data...');
        
        // Сортируем все наборы по году (новые первыми)
        if (Object.keys(SET_MAP).length > 0) {
            console.log('📦 Sorting all sets by year (newest first)...');
            const allSets = Object.values(SET_MAP);
            allSets.sort((a, b) => {
                const yearA = parseInt(a.year) || 0;
                const yearB = parseInt(b.year) || 0;
                return yearB - yearA; // Новые первыми
            });
            console.log('✅ All sets sorted by year, newest first');
        }
        
        // Сортируем все минифигурки по году (новые первыми)
        if (Object.keys(MINIFIG_MAP).length > 0) {
            console.log('👤 Sorting all minifigs by year (newest first)...');
            const allMinifigs = Object.values(MINIFIG_MAP);
            allMinifigs.sort((a, b) => {
                const yearA = parseInt(a.year) || 0;
                const yearB = parseInt(b.year) || 0;
                return yearB - yearA; // Новые первыми
            });
            console.log('✅ All minifigs sorted by year, newest first');
        }
        
        // Сортируем все детали по популярности (часто используемые первыми)
        if (Object.keys(PART_MAP).length > 0) {
            console.log('🔧 Sorting all parts by popularity (most used first)...');
            const allParts = Object.values(PART_MAP);
            allParts.sort((a, b) => {
                const popularityA = parseInt(a.num_sets) || 0;
                const popularityB = parseInt(b.num_sets) || 0;
                return popularityB - popularityA; // Популярные первыми
            });
            console.log('✅ All parts sorted by popularity, most used first');
        }
        
        console.log('🎯 Global sorting completed successfully!');
        
        // Инициализируем общее количество всех деталей в каталоге
        S.totalPartsInCatalog = Object.keys(PART_MAP).length;
        
        // Инициализируем общее количество всех наборов в каталоге
        S.totalSetsInCatalog = Object.keys(SET_MAP).length;
        
        // Обновляем UI
        S.gridStale = true;
        updateUI();
        
        // Скрываем индикатор загрузки
        updateLoadingStatus("Загрузка завершена!", 100, "Каталог готов к использованию");
        setTimeout(() => {
            hideLoadingIndicator();
        }, 1000);
        
    } catch (error) {
        console.error('Failed to load CSV data:', error);
        S.err = `Ошибка загрузки CSV данных: ${error.message}`;
        
        updateLoadingStatus("Ошибка загрузки", 0, `Ошибка: ${error.message}`);
        
        // Переход на загрузку API, если CSV не удается
        try {
            updateLoadingStatus("Попытка загрузки из API...", 50, "Резервная загрузка");
            await Promise.all([fetchAllColors(), fetchCategories(), fetchThemes()]);
            
            // Инициализируем общее количество деталей из API (если доступно)
            if (Object.keys(PART_MAP).length > 0) {
                S.totalPartsInCatalog = Object.keys(PART_MAP).length;
            }
            
            // Инициализируем общее количество наборов из API (если доступно)
            if (Object.keys(SET_MAP).length > 0) {
                S.totalSetsInCatalog = Object.keys(SET_MAP).length;
            }
            
            // Глобальная сортировка данных из API
            console.log('📅 Starting global sorting of API data...');
            
            // Сортируем все наборы по году (новые первыми)
            if (Object.keys(SET_MAP).length > 0) {
                console.log('📦 Sorting all API sets by year (newest first)...');
                const allSets = Object.values(SET_MAP);
                allSets.sort((a, b) => {
                    const yearA = parseInt(a.year) || 0;
                    const yearB = parseInt(b.year) || 0;
                    return yearB - yearA; // Новые первыми
                });
                console.log('✅ All API sets sorted by year, newest first');
            }
            
            // Сортируем все минифигурки по году (новые первыми)
            if (Object.keys(MINIFIG_MAP).length > 0) {
                console.log('👤 Sorting all API minifigs by year (newest first)...');
                const allMinifigs = Object.values(MINIFIG_MAP);
                allMinifigs.sort((a, b) => {
                    const yearA = parseInt(a.year) || 0;
                    const yearB = parseInt(b.year) || 0;
                    return yearB - yearA; // Новые первыми
                });
                console.log('✅ All API minifigs sorted by year, newest first');
            }
            
            // Сортируем все детали по популярности (часто используемые первыми)
            if (Object.keys(PART_MAP).length > 0) {
                console.log('🔧 Sorting all API parts by popularity (most used first)...');
                const allParts = Object.values(PART_MAP);
                allParts.sort((a, b) => {
                    const popularityA = parseInt(a.num_sets) || 0;
                    const popularityB = parseInt(b.num_sets) || 0;
                    return popularityB - popularityA; // Популярные первыми
                });
                console.log('✅ All API parts sorted by popularity, most used first');
            }
            
            console.log('🎯 Global API sorting completed successfully!');
            
            updateLoadingStatus("Загрузка из API завершена", 100, "Каталог готов к использованию");
            setTimeout(() => {
                hideLoadingIndicator();
            }, 1000);
        } catch (apiError) {
            console.error('Fallback API loading also failed:', apiError);
            S.err = `${S.err}\nТакже не удалось загрузить данные из API: ${apiError.message}`;
            updateLoadingStatus("Критическая ошибка", 0, "Не удалось загрузить данные ни из CSV, ни из API");
        }
    }
}

// Функция для загрузки цветов из CSV
async function loadColorsFromCSV() {
    try {
        const csvText = await fetchTextWithProgress('./Data/colors.csv', 'Загрузка цветов...', 'colors.csv');
        const lines = csvText.split('\n').slice(1); // Пропускаем заголовок
        
        lines.forEach(line => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                const [id, name, rgb, is_trans] = fields;
                if (id && name) {
                    COLOR_MAP[id] = {
                        id: id,
                        name: name,
                        hex: `#${rgb || '000000'}`,
                        isTransparent: is_trans === 'True',
                        rgb: rgb || '000000',
                        is_trans: is_trans === 'True'
                    };
                }
            }
        });
        

    } catch (error) {
        console.error('Failed to load colors from CSV:', error);
        throw error;
    }
}
// Функция для загрузки категорий из CSV
async function loadCategoriesFromCSV() {
    try {
        const csvText = await fetchTextWithProgress('./Data/part_categories.csv', 'Загрузка категорий деталей...', 'part_categories.csv');
        const lines = csvText.split('\n').slice(1); // Пропускаем заголовок
        
        lines.forEach(line => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                const [id, name] = fields;
                if (id && name) {
                    flatCategories.push({
                        id: parseInt(id),
                        name: name,
                        parent_id: null
                    });
                }
            }
        });
        
        // Строим дерево категорий
        S.catTree = buildCategoryTree(flatCategories);
        

    } catch (error) {
        console.error('Failed to load categories from CSV:', error);
        throw error;
    }
}

// Функция для загрузки тем из CSV
async function loadThemesFromCSV() {
    try {
        const csvText = await fetchTextWithProgress('./Data/themes.csv', 'Загрузка тем наборов...', 'themes.csv');
        const lines = csvText.split('\n').slice(1); // Пропускаем заголовок
        
        const themeMap = {};
        
        lines.forEach(line => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                const [id, name, parent_id] = fields;
                if (id && name) {
                    const theme = {
                        id: parseInt(id),
                        name: name,
                        parent_id: parent_id ? parseInt(parent_id) : null,
                        children: []
                    };
                    themeMap[id] = theme;
                    THEME_MAP[id] = theme;
                }
            }
        });
        
        // Строим дерево тем
        const rootThemes = [];
        Object.values(themeMap).forEach(theme => {
            if (theme.parent_id && themeMap[theme.parent_id]) {
                themeMap[theme.parent_id].children.push(theme);
            } else {
                rootThemes.push(theme);
            }
        });
        
        S.themeTree = rootThemes;
        

    } catch (error) {
        console.error('Failed to load themes from CSV:', error);
        throw error;
    }
}

// Функция для загрузки деталей из CSV
async function loadPartsFromCSV() {
    try {
        const csvText = await fetchTextWithProgress('./Data/parts.csv', 'Загрузка деталей...', 'parts.csv');
        const lines = csvText.split('\n').slice(1); // Пропускаем заголовок
        
        lines.forEach(line => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                const [part_num, name, part_cat_id] = fields;
                if (part_num && name) {
                    // Не устанавливаем URL изображения здесь - он будет получен из inventory_parts.csv
                    PART_MAP[part_num] = {
                        id: part_num,
                        name: name,
                        part_num: part_num,
                        part_cat_id: part_cat_id ? parseInt(part_cat_id) : null,
                        categoryId: part_cat_id ? parseInt(part_cat_id) : null,
                        num_sets: 0, // Будет обновлено из API, если потребуется
                        part_img_url: null, // Будет установлено из inventory_parts.csv
                        rebrickable_img_url: null
                    };
                    
                    // Проверяем корректность данных
                    if (PART_MAP[part_num].categoryId && (PART_MAP[part_num].categoryId < 1 || PART_MAP[part_num].categoryId > 1000)) {
                        console.warn('Invalid category ID for part', part_num, ':', PART_MAP[part_num].categoryId);
                        PART_MAP[part_num].categoryId = null;
                        PART_MAP[part_num].part_cat_id = null;
                    }
                }
            }
        });
        

    } catch (error) {
        console.error('Failed to load parts from CSV:', error);
        throw error;
    }
}
// Функция для загрузки наборов из CSV
async function loadSetsFromCSV() {
    try {
        const csvText = await fetchTextWithProgress('./Data/sets.csv', 'Загрузка наборов...', 'sets.csv');
        const lines = csvText.split('\n').slice(1); // Пропускаем заголовок
        
        lines.forEach(line => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                const [set_num, name, year, theme_id, num_parts, img_url] = fields;
                if (set_num && name) {
                    // Используем URL изображения из CSV, если доступно, иначе генерируем
                    let setImgUrl = img_url || `https://cdn.rebrickable.com/media/sets/${set_num}.jpg`;
                    
                    // Проверяем URL изображения
                    if (setImgUrl && (!setImgUrl.startsWith('http') || setImgUrl.includes('localhost'))) {
                        console.warn('Invalid image URL detected for set', set_num, ':', setImgUrl);
                        setImgUrl = `https://cdn.rebrickable.com/media/sets/${set_num}.jpg`;
                    }
                    
                    SET_MAP[set_num] = {
                        set_num: set_num,
                        name: name,
                        year: year ? parseInt(year) : null,
                        theme_id: theme_id ? parseInt(theme_id) : null,
                        num_parts: num_parts ? parseInt(num_parts) : null,
                        set_img_url: setImgUrl
                    };
                    
                    // Проверяем корректность данных
                    if (SET_MAP[set_num].year && (SET_MAP[set_num].year < 1900 || SET_MAP[set_num].year > 2030)) {
                        console.warn('Invalid year for set', set_num, ':', SET_MAP[set_num].year);
                        SET_MAP[set_num].year = null;
                    }
                    
                    if (SET_MAP[set_num].num_parts && (SET_MAP[set_num].num_parts < 0 || SET_MAP[set_num].num_parts > 10000)) {
                        console.warn('Invalid num_parts for set', set_num, ':', SET_MAP[set_num].num_parts);
                        SET_MAP[set_num].num_parts = null;
                    }
                }
            }
        });
        

    } catch (error) {
        console.error('Failed to load sets from CSV:', error);
        throw error;
    }
}

// Функция для загрузки минифигурок из CSV
// ИСПРАВЛЕНО: Теперь правильно считывает поле img_url из CSV и использует правильный запасной URL
async function loadMinifigsFromCSV() {
    try {
        const csvText = await fetchTextWithProgress('./Data/minifigs.csv', 'Загрузка минифигурок...', 'minifigs.csv');
        const lines = csvText.split('\n').slice(1); // Пропускаем заголовок
        
        lines.forEach(line => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                const [fig_num, name, num_parts, img_url] = fields;
                if (fig_num && name) {
                    // Используем URL изображения из CSV, если доступно, иначе генерируем
                    let minifigImgUrl = img_url || `https://cdn.rebrickable.com/media/minifigs/${fig_num}.jpg`;
                    
                    // Проверяем URL изображения
                    if (minifigImgUrl && (!minifigImgUrl.startsWith('http') || minifigImgUrl.includes('localhost'))) {
                        console.warn('Invalid image URL detected for minifig', fig_num, ':', minifigImgUrl);
                        minifigImgUrl = `https://cdn.rebrickable.com/media/minifigs/${fig_num}.jpg`;
                    }
                    
                    MINIFIG_MAP[fig_num] = {
                        set_num: fig_num, // Используем set_num для согласованности
                        name: name,
                        num_parts: num_parts ? parseInt(num_parts) : null,
                        minifig_img_url: minifigImgUrl
                    };
                    
                    // Проверяем корректность данных
                    if (MINIFIG_MAP[fig_num].num_parts && (MINIFIG_MAP[fig_num].num_parts < 0 || MINIFIG_MAP[fig_num].num_parts > 100)) {
                        console.warn('Invalid num_parts for minifig', fig_num, ':', MINIFIG_MAP[fig_num].num_parts);
                        MINIFIG_MAP[fig_num].num_parts = null;
                    }
                }
            }
        });
        

        
        // Загружаем отсутствующие URL изображений минифигурок из API для минифигурок без изображений
        await fetchMissingMinifigImages();
    } catch (error) {
        console.error('Failed to load minifigs from CSV:', error);
        throw error;
    }
}
// Функция для загрузки отсутствующих URL изображений минифигурок из API
async function fetchMissingMinifigImages() {
    const minifigsWithoutImages = Object.values(MINIFIG_MAP).filter(m => !m.minifig_img_url);
    
    if (minifigsWithoutImages.length === 0) {
        return;
    }
    
    for (const minifig of minifigsWithoutImages.slice(0, 10)) { // Ограничиваем до 10, чтобы избежать ограничения частоты запросов
        if (!minifig || !minifig.set_num) {
            continue;
        }
        
        try {
            const response = await fetch(`${REBRICKABLE_API_URL}/minifigs/${minifig.set_num}/?key=${getApiKey()}`);
            if (response.ok) {
                const data = await response.json();
                if (data.results && data.results[0] && data.results[0].set_img_url) {
                    minifig.minifig_img_url = data.results[0].set_img_url;
                    try { markApiStatOnce('images', `minifig:${minifig.set_num}`); } catch {}
                }
            }
            // Добавляем задержку, чтобы избежать ограничения частоты запросов
            await new Promise(resolve => setTimeout(resolve, 100));
        } catch (error) {
            // Игнорируем отдельные ошибки загрузки минифигурок
        }
    }
}

// Функция для загрузки элементов из CSV
async function loadElementsFromCSV() {
    try {
        const csvText = await fetchTextWithProgress('./Data/elements.csv', 'Загрузка элементов...', 'elements.csv');
        const lines = csvText.split('\n').slice(1); // Пропускаем заголовок
        
        lines.forEach(line => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                const [element_id, part_num, color_id] = fields;
                if (element_id && part_num && color_id) {
                    // Сохраняем информацию об элементе для последующего использования
                    if (!PART_MAP[part_num]) {
                        PART_MAP[part_num] = { id: part_num, name: 'Unknown Part' };
                    }
                    if (!COLOR_MAP[color_id]) {
                        COLOR_MAP[color_id] = { id: color_id, name: 'Unknown Color', hex: '#000000' };
                    }
                }
            }
        });
        

    } catch (error) {
        console.error('Failed to load elements from CSV:', error);
        // Не выбрасываем ошибку для элементов, так как это не критично
    }
}
// Вспомогательная функция: получить список файлов inventory_parts_part_XXX из parts_info.txt
async function discoverInventoryPartFiles() {
    const baseDir = './Data/inventory_parts_split/';
    const infoUrl = baseDir + 'parts_info.txt';
    try {
        const resp = await fetch(infoUrl, { cache: 'no-cache' });
        if (!resp.ok) throw new Error('parts_info not found');
        const text = await resp.text();
        const files = [];
        const lines = text.split('\n');
        const re = /inventory_parts_part_\d{3}\.csv/;
        for (const line of lines) {
            const m = line.match(re);
            if (m) files.push(m[0]);
        }
        if (files.length > 0) return files.map(name => baseDir + name);
    } catch (e) {
        // fall through to heuristic
    }
    // Fallback: пробуем до 50 частей и берём только существующие
    const discovered = [];
    for (let partNum = 1; partNum <= 50; partNum++) {
        const name = `inventory_parts_part_${partNum.toString().padStart(3, '0')}.csv`;
        const url = baseDir + name;
        try {
            const head = await fetch(url, { method: 'HEAD' });
            if (head.ok) discovered.push(url); else break;
        } catch {
            break;
        }
    }
    return discovered;
}

// Функция для загрузки инвентарей из CSV
async function loadInventoriesFromCSV() {
    try {
        // Загружаем inventory_parts из динамически обнаруженных файлов
        const inventoryPartsLines = [];
        const partFiles = await discoverInventoryPartFiles();
        const maxParts = partFiles.length || 1;
        // Обновляем план прогресса с учётом фактического количества частей
        try {
            window.DYNAMIC_PARTS_COUNT = maxParts;
            window.CSV_PROGRESS_PLAN = null;
            initCsvProgressPlan();
        } catch {}
        let loadedParts = 0;
        for (let idx = 0; idx < partFiles.length; idx++) {
            const url = partFiles[idx];
            const label = url.substring(url.lastIndexOf('/') + 1);
            try {
                const csvText = await fetchTextWithProgress(url, 'Загрузка инвентарей деталей...', label);
                const lines = csvText.split('\n');
                const linesToAdd = idx === 0 ? lines.slice(1) : lines.slice(1);
                for (let i = 0; i < linesToAdd.length; i++) {
                    inventoryPartsLines.push(linesToAdd[i]);
                }
                loadedParts++;
                if (S.settingsOpen) {
                    S.settingsModal.status = `Загрузка инвентарей (часть ${idx + 1}/${maxParts})...`;
                    renderSettingsModal();
                }
            } catch (error) {
                console.error(`Failed to load part ${label}:`, error);
                break;
            }
        }
        

        
        const lines = inventoryPartsLines;
        
        // Создаем карты инвентаря для быстрого поиска
        const inventoryPartsMap = {};
        const inventorySetsMap = {};
        const inventoryMinifigsMap = {};
        
        // Обрабатываем строки инвентаря деталей и обновляем PART_MAP информацией об изображениях
        let partsWithImagesCount = 0;
        let partsWithColorImagesCount = 0;
        
        let processedLines = 0;
        let skippedLines = 0;
        
        lines.forEach((line, lineIndex) => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                processedLines++;
                
                const [inventory_id, part_num, color_id, quantity, is_spare, img_url] = fields;
                
                if (inventory_id && part_num && color_id && quantity && is_spare !== 't') {
                    if (!inventoryPartsMap[inventory_id]) {
                        inventoryPartsMap[inventory_id] = [];
                    }
                    inventoryPartsMap[inventory_id].push({
                        part_num,
                        color_id: parseInt(color_id),
                        quantity: parseInt(quantity),
                        img_url: img_url || null
                    });
                    
                    // Сохраняем URL изображения для этой комбинации деталь-цвет (если присутствует)
                    if (fields.length > 5 && img_url && img_url.trim() && img_url.startsWith('http')) {
                        // Убеждаемся, что запись PART_MAP существует
                        if (!PART_MAP[part_num]) {
                            PART_MAP[part_num] = { 
                                id: part_num, 
                                name: 'Unknown Part'
                            };
                        }
                        
                        // Инициализируем colorImages, если он не существует
                        if (!PART_MAP[part_num].colorImages) {
                            PART_MAP[part_num].colorImages = {};
                        }
                        
                        // Сохраняем URL изображения для этого конкретного цвета
                        PART_MAP[part_num].colorImages[color_id] = img_url;
                        partsWithColorImagesCount++;
                        
                        // Также устанавливаем как изображение по умолчанию, если ни одно не существует
                        if (!PART_MAP[part_num].part_img_url) {
                            PART_MAP[part_num].part_img_url = img_url;
                            PART_MAP[part_num].rebrickable_img_url = img_url;
                            partsWithImagesCount++;
                        }
                    }
                    
                    // Убеждаемся, что детали и цвета существуют
                    if (!PART_MAP[part_num]) {
                        PART_MAP[part_num] = { 
                            id: part_num, 
                            name: 'Unknown Part'
                        };
                    }
                    if (!COLOR_MAP[color_id]) {
                        COLOR_MAP[color_id] = { 
                            id: color_id, 
                            name: 'Unknown Color', 
                            hex: '#000000' 
                        };
                    }
                } else {
                    skippedLines++;
                }
            }
        });
        

        
        // Загружаем inventories.csv для создания связей инвентарь-набор
        const inventoriesCsvText = await fetchTextWithProgress('./Data/inventories.csv', 'Загрузка инвентарей...', 'inventories.csv');
        const inventoriesLines = inventoriesCsvText.split('\n').slice(1);
        
        const inventoryToSetMap = {};
        inventoriesLines.forEach(line => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                const [inventory_id, version, set_num] = fields;
                if (inventory_id && set_num) {
                    inventoryToSetMap[inventory_id] = set_num;
                }
            }
        });
        
        // Загружаем inventory_sets
        const setCsvText = await fetchTextWithProgress('./Data/inventory_sets.csv', 'Загрузка инвентаря наборов...', 'inventory_sets.csv');
        const setLines = setCsvText.split('\n').slice(1);
        
        setLines.forEach(line => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                const [inventory_id, set_num, quantity] = fields;
                if (inventory_id && set_num && quantity) {
                    if (!inventorySetsMap[inventory_id]) {
                        inventorySetsMap[inventory_id] = [];
                    }
                    inventorySetsMap[inventory_id].push({
                        set_num,
                        quantity: parseInt(quantity)
                    });
                }
            }
        });
        
        // Дополняем inventorySetsMap данными из inventories.csv
        Object.keys(inventoryToSetMap).forEach(inventoryId => {
            const setNum = inventoryToSetMap[inventoryId];
            if (!inventorySetsMap[inventoryId]) {
                inventorySetsMap[inventoryId] = [];
            }
            // Проверяем, что набор еще не добавлен
            const exists = inventorySetsMap[inventoryId].some(set => set.set_num === setNum);
            if (!exists) {
                inventorySetsMap[inventoryId].push({
                    set_num: setNum,
                    quantity: 1
                });
            }
        });
        
        // Загружаем inventory_minifigs
        const minifigCsvText = await fetchTextWithProgress('./Data/inventory_minifigs.csv', 'Загрузка инвентаря минифигурок...', 'inventory_minifigs.csv');
        const minifigLines = minifigCsvText.split('\n').slice(1);
        
        minifigLines.forEach(line => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                const [inventory_id, fig_num, quantity] = fields;
                if (inventory_id && fig_num && quantity) {
                    if (!inventoryMinifigsMap[inventory_id]) {
                        inventoryMinifigsMap[inventory_id] = [];
                    }
                    inventoryMinifigsMap[inventory_id].push({
                        fig_num,
                        quantity: parseInt(quantity)
                    });
                }
            }
        });
        
        // Сохраняем данные инвентаря глобально для использования в модальных окнах
        window.INVENTORY_DATA = {
            parts: inventoryPartsMap,
            sets: inventorySetsMap,
            minifigs: inventoryMinifigsMap
        };

        
        // Загружаем отсутствующие изображения для элементов коллекции
        // await fetchMissingImagesFromCSV(); // Moved to initializeApp to ensure proper order
    } catch (error) {
        console.error('Failed to load inventory data from CSV:', error);
        // Не выбрасываем ошибку для инвентаря, так как это не критично
    }
}
// Функция для получения статистики загрузки
function getLoadingStats() {
    const stats = {
        colors: Object.keys(COLOR_MAP).length,
        categories: flatCategories.length,
        themes: Object.keys(THEME_MAP).length,
        parts: Object.keys(PART_MAP).length,
        sets: Object.keys(SET_MAP).length,
        minifigs: Object.keys(MINIFIG_MAP).length,
        partsWithImages: Object.values(PART_MAP).filter(p => p.part_img_url || p.rebrickable_img_url).length,
        setsWithImages: Object.values(SET_MAP).filter(s => s.set_img_url).length,
        minifigsWithImages: Object.values(MINIFIG_MAP).filter(m => m.minifig_img_url).length
    };
    
            // Получаем статистику загрузки API
    const apiStats = getApiLoadingStats();
    
    return {
        ...stats,
        ...apiStats
    };
}
// Функция для получения статистики загрузки API
function getApiLoadingStats() {
    let apiStats = {};
    try {
        apiStats = JSON.parse(localStorage.getItem('legoApiStats') || '{}');
    } catch {}
    // Fallback на оперативные данные, если localStorage пуст
    if ((!apiStats || Object.keys(apiStats).length === 0) && window.API_STATS) {
        apiStats = window.API_STATS;
    }
    return {
        apiColors: Number(apiStats.colors) || 0,
        apiParts: Number(apiStats.parts) || 0,
        apiSets: Number(apiStats.sets) || 0,
        apiMinifigs: Number(apiStats.minifigs) || 0,
        apiImages: Number(apiStats.images) || 0,
        lastApiUpdate: apiStats.lastUpdate || null
    };
}

// Кэш для ускорения фильтрации деталей по цвету в каталоге
window.PARTS_BY_COLOR_CACHE = window.PARTS_BY_COLOR_CACHE || {};
function getPartsWithColorSet(colorId) {
    try {
        if (colorId === undefined || colorId === null) return new Set();
        const id = String(colorId);
        if (window.PARTS_BY_COLOR_CACHE[id]) return window.PARTS_BY_COLOR_CACHE[id];
        const set = new Set();
        const invParts = (window.INVENTORY_DATA && window.INVENTORY_DATA.parts) ? Object.values(window.INVENTORY_DATA.parts) : [];
        for (const inventory of invParts) {
            if (!Array.isArray(inventory)) continue;
            for (const item of inventory) {
                if (!item) continue;
                if (String(item.color_id) === id && item.part_num) set.add(String(item.part_num));
            }
        }
        window.PARTS_BY_COLOR_CACHE[id] = set;
        return set;
    } catch {
        return new Set();
    }
}

// Функция для обновления статистики загрузки API
function updateApiLoadingStats(type, count = 1) {
    try {
        const current = JSON.parse(localStorage.getItem('legoApiStats') || '{}');
        const apiStats = {
            colors: Number(current.colors) || 0,
            parts: Number(current.parts) || 0,
            sets: Number(current.sets) || 0,
            minifigs: Number(current.minifigs) || 0,
            images: Number(current.images) || 0,
            lastUpdate: current.lastUpdate || null
        };
        const n = Number(count) || 0;
        if (['colors','parts','sets','minifigs','images'].includes(type)) {
            apiStats[type] += n;
        }
        apiStats.lastUpdate = new Date().toISOString();
        localStorage.setItem('legoApiStats', JSON.stringify(apiStats));
        // Дублируем в оперативное состояние для моментального доступа
        window.API_STATS = apiStats;
        // Если открыт модал настроек, обновим панель статистики (без полной перерисовки)
        if (S.settingsOpen) {
            try { refreshSettingsStatsPanel(); } catch {}
        }
    } catch (error) {
        console.error('Failed to update API stats:', error);
    }
}

// Обновление статистики API один раз на уникальный элемент
function markApiStatOnce(type, id) {
    try {
        if (!['colors','parts','sets','minifigs','images'].includes(type)) return;
        if (id === undefined || id === null) return;
        const idStr = String(id);

        // Текущие значения счетчиков
        const current = JSON.parse(localStorage.getItem('legoApiStats') || '{}');
        const apiStats = {
            colors: Number(current.colors) || 0,
            parts: Number(current.parts) || 0,
            sets: Number(current.sets) || 0,
            minifigs: Number(current.minifigs) || 0,
            images: Number(current.images) || 0,
            lastUpdate: current.lastUpdate || null
        };

        // Набор уже учтенных элементов
        let seen = {};
        try { seen = JSON.parse(localStorage.getItem('legoApiSeen') || '{}') || {}; } catch {}
        if (!seen[type]) seen[type] = {};

        // Если еще не учитывали — увеличиваем счетчик и помечаем как учтенный
        if (!seen[type][idStr]) {
            apiStats[type] = Number(apiStats[type] || 0) + 1;
            apiStats.lastUpdate = new Date().toISOString();
            seen[type][idStr] = true;
            localStorage.setItem('legoApiStats', JSON.stringify(apiStats));
            localStorage.setItem('legoApiSeen', JSON.stringify(seen));
            try { console.debug('[API stats] +1', type, idStr, apiStats[type]); } catch {}
            window.API_STATS = apiStats;
            if (S.settingsOpen) {
                try { refreshSettingsStatsPanel(); } catch {}
            }
        }
    } catch (error) {
        console.error('Failed to mark API stat once:', error);
    }
}

// Локальное обновление панели статистики в настройках без полной перерисовки модала
function refreshSettingsStatsPanel() {
    const panel = document.getElementById('settings-stats-panel');
    if (!panel) return;
    const stats = getLoadingStats();
    const lastUpdate = stats.lastApiUpdate ? new Date(stats.lastApiUpdate).toLocaleString('ru-RU') : 'Никогда';
    const apiOpen = localStorage.getItem('apiStatsOpen') === 'true';
    panel.innerHTML = `
        <div class="text-green-400 text-xs mb-2">✓ Все данные загружаются из CSV файлов</div>
        <div class="space-y-1">
            <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                <div class="flex items-center text-gray-300 text-xs">
                    <div class="w-2 h-2 rounded-full bg-red-500 mr-2"></div>
                    Цвета:
                </div>
                <div class="text-white font-semibold text-xs">${stats.colors}</div>
            </div>
            <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                <div class="flex items-center text-gray-300 text-xs">
                    <div class="w-2 h-2 rounded-full bg-blue-500 mr-2"></div>
                    Категории:
                </div>
                <div class="text-white font-semibold text-xs">${stats.categories}</div>
            </div>
            <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                <div class="flex items-center text-gray-300 text-xs">
                    <div class="w-2 h-2 rounded-full bg-green-500 mr-2"></div>
                    Темы:
                </div>
                <div class="text-white font-semibold text-xs">${stats.themes}</div>
            </div>
            <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                <div class="flex items-center text-gray-300 text-xs">
                    <div class="w-2 h-2 rounded-full bg-yellow-500 mr-2"></div>
                    Детали:
                </div>
                <div class="text-white font-semibold text-xs">${stats.parts}</div>
            </div>
            <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                <div class="flex items-center text-gray-300 text-xs">
                    <div class="w-2 h-2 rounded-full bg-purple-500 mr-2"></div>
                    Наборы:
                </div>
                <div class="text-white font-semibold text-xs">${stats.sets}</div>
            </div>
            <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                <div class="flex items-center text-gray-300 text-xs">
                    <div class="w-2 h-2 rounded-full bg-pink-500 mr-2"></div>
                    Минифигурки:
                </div>
                <div class="text-white font-semibold text-xs">${stats.minifigs}</div>
            </div>
        </div>
        <button data-action="toggle-api-stats" class="w-full flex items-center justify-between text-left text-xs font-semibold text-yellow-300 mt-3 pt-2 border-t border-gray-700/50">
            <span>Данные через API</span>
            <span id="api-stats-chevron" class="${apiOpen ? 'rotate-180' : ''}">${I_Chev('w-4 h-4 text-yellow-300')}</span>
        </button>
        <div id="api-stats-panel" class="${apiOpen ? 'open ' : ''}collapse-panel">
            <div class="space-y-1 mt-1">
                <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                    <div class="flex items-center text-gray-300 text-xs">
                        <div class="w-2 h-2 rounded-full bg-red-500 mr-2"></div>
                        Цвета:
                    </div>
                    <div class="text-white font-semibold text-xs">${stats.apiColors}</div>
                </div>
                <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                    <div class="flex items-center text-gray-300 text-xs">
                        <div class="w-2 h-2 rounded-full bg-yellow-500 mr-2"></div>
                        Детали:
                    </div>
                    <div class="text-white font-semibold text-xs">${stats.apiParts}</div>
                </div>
                <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                    <div class="flex items-center text-gray-300 text-xs">
                        <div class="w-2 h-2 rounded-full bg-purple-500 mr-2"></div>
                        Наборы:
                    </div>
                    <div class="text-white font-semibold text-xs">${stats.apiSets}</div>
                </div>
                <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                    <div class="flex items-center text-gray-300 text-xs">
                        <div class="w-2 h-2 rounded-full bg-pink-500 mr-2"></div>
                        Минифигурки:
                    </div>
                    <div class="text-white font-semibold text-xs">${stats.apiMinifigs}</div>
                </div>
                <div class="flex items-center justify-between py-1 px-2 rounded bg-gray-800/50">
                    <div class="flex items-center text-gray-300 text-xs">
                        <div class="w-2 h-2 rounded-full bg-blue-500 mr-2"></div>
                        Изображения:
                    </div>
                    <div class="text-white font-semibold text-xs">${stats.apiImages}</div>
                </div>
            </div>
            <div class="text-blue-400 text-xs mt-2">
                Последнее обновление API: ${lastUpdate}
            </div>
        </div>
    `;
}

// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ: прогресс скачивания CSV в мегабайтах (только при первой загрузке)
function formatMb(bytes) {
    if (!bytes || isNaN(bytes)) return '0.00';
    return (bytes / (1024 * 1024)).toFixed(2);
}
async function fetchTextWithProgress(url, statusText, label) {
    try {
        const resp = await fetch(url);
        // Если поток недоступен, используем обычное чтение
        const reader = resp && resp.body && resp.body.getReader ? resp.body.getReader() : null;
        const contentLengthHeader = resp && resp.headers ? resp.headers.get('content-length') : null;
        const totalForFile = contentLengthHeader ? parseInt(contentLengthHeader, 10) : 0;
        if (!window.CSV_MB_PROGRESS) window.CSV_MB_PROGRESS = { totalBytes: 0, totalExpected: 0 };
        if (!window.CSV_PROGRESS_PLAN) initCsvProgressPlan();
        if (!window.CSV_PROGRESS_STATE) window.CSV_PROGRESS_STATE = { completed: new Set() };
        if (!reader) {
            const text = await resp.text();
            // Обновим общий прогресс хотя бы по размеру текста (приближенно)
            try {
                const approxBytes = text.length; // приблизительно (UTF-16 -> меньшее число)
                window.CSV_MB_PROGRESS.totalBytes += approxBytes;
                // Плановая шкала прогресса по этапам/файлам
                const progressPercent = calcPlannedProgress(label, 1);
                const details = `Загружается: ${label} • Файл: ${formatMb(approxBytes)} MB • Всего: ${formatMb(window.CSV_MB_PROGRESS.totalBytes)} MB`;
                updateLoadingStatus(statusText, progressPercent, details);
                window.CSV_PROGRESS_STATE.completed.add(label);
            } catch {}
            return text;
        }
        const decoder = new TextDecoder();
        let received = 0;
        let text = '';
        for (;;) {
            const { done, value } = await reader.read();
            if (done) break;
            received += value.length;
            window.CSV_MB_PROGRESS.totalBytes += value.length;
            text += decoder.decode(value, { stream: true });
            const current = `Файл: ${formatMb(received)} MB`;
            // Плановая шкала прогресса по этапам/файлам
            const fileFraction = totalForFile > 0 ? Math.max(0, Math.min(1, received / totalForFile)) : null;
            const progressPercent = calcPlannedProgress(label, fileFraction);
            const details = `Загружается: ${label} • ${current} • Всего: ${formatMb(window.CSV_MB_PROGRESS.totalBytes)} MB`;
            updateLoadingStatus(statusText, progressPercent, details);
        }
        text += decoder.decode();
        try { window.CSV_PROGRESS_STATE.completed.add(label); } catch {}
        return text;
    } catch (e) {
        // В случае любых проблем просто читаем как текст
        const resp = await fetch(url);
        return await resp.text();
    }
}

// План этапов загрузки CSV с весами для корректного индикатора прогресса
function initCsvProgressPlan() {
    try {
        const dynamicParts = (typeof window !== 'undefined' && window.DYNAMIC_PARTS_COUNT) ? window.DYNAMIC_PARTS_COUNT : 7;
        const plan = [
            { type: 'single', match: 'part_categories.csv', weight: 3 },
            { type: 'single', match: 'themes.csv', weight: 3 },
            { type: 'single', match: 'colors.csv', weight: 3 },
            { type: 'single', match: 'parts.csv', weight: 10 },
            { type: 'single', match: 'sets.csv', weight: 8 },
            { type: 'single', match: 'minifigs.csv', weight: 6 },
            { type: 'single', match: 'elements.csv', weight: 8 },
            { type: 'group', prefix: 'inventory_parts_part_', count: dynamicParts, weight: 40 },
            { type: 'single', match: 'inventory_sets.csv', weight: 9 },
            { type: 'single', match: 'inventory_minifigs.csv', weight: 10 }
        ];
        const totalWeight = plan.reduce((sum, p) => sum + p.weight, 0) || 100;
        // Нормализуем к 100
        plan.forEach(p => p.norm = (p.weight / totalWeight) * 100);
        window.CSV_PROGRESS_PLAN = plan;
        if (!window.CSV_PROGRESS_STATE) window.CSV_PROGRESS_STATE = { completed: new Set() };
    } catch {}
}

function matchPlanEntry(label) {
    if (!window.CSV_PROGRESS_PLAN) initCsvProgressPlan();
    for (const entry of window.CSV_PROGRESS_PLAN) {
        if (entry.type === 'single' && label === entry.match) return entry;
        if (entry.type === 'group' && label.startsWith(entry.prefix)) return entry;
    }
    return null;
}

function calcPlannedProgress(label, fileFraction) {
    if (!window.CSV_PROGRESS_PLAN) initCsvProgressPlan();
    if (!window.CSV_PROGRESS_STATE) window.CSV_PROGRESS_STATE = { completed: new Set() };
    // Суммируем полные веса завершенных этапов до текущего
    let progress = 0;
    for (const entry of window.CSV_PROGRESS_PLAN) {
        const isCurrent = (entry.type === 'single' && label === entry.match) || (entry.type === 'group' && label.startsWith(entry.prefix));
        if (isCurrent) {
            // Добавляем долю текущего этапа
            if (entry.type === 'single') {
                const frac = (fileFraction != null) ? fileFraction : 0.2; // без длины — даём небольшой прирост
                progress += entry.norm * Math.max(0, Math.min(1, frac));
            } else {
                // Группа файлов с равномерным распределением
                const completedInGroup = Array.from(window.CSV_PROGRESS_STATE.completed || []).filter(l => l.startsWith(entry.prefix)).length;
                const frac = (fileFraction != null) ? fileFraction : 0.05; // без длины — очень маленький шаг
                const perFile = entry.norm / (entry.count || 1);
                progress += perFile * (completedInGroup + Math.max(0, Math.min(1, frac)));
            }
            break;
        } else {
            // Если этап полностью завершён — учитываем его полностью
            if (entry.type === 'single') {
                if (window.CSV_PROGRESS_STATE.completed && window.CSV_PROGRESS_STATE.completed.has(entry.match)) {
                    progress += entry.norm;
                }
            } else {
                const completedInGroup = Array.from(window.CSV_PROGRESS_STATE.completed || []).filter(l => l.startsWith(entry.prefix)).length;
                const total = entry.count || 1;
                const perFile = entry.norm / total;
                progress += perFile * Math.max(0, Math.min(total, completedInGroup));
            }
        }
    }
    // Никогда не возвращаем 100 до финального шага скрытия индикатора
    return Math.min(99, Math.floor(progress));
}

// Функции для управления индикатором загрузки
function updateLoadingStatus(status, progress = null, details = null) {
    const statusElement = document.getElementById('loading-status');
    const progressElement = document.getElementById('loading-progress');
    const detailsElement = document.getElementById('loading-details');
    const loadingTipElement = document.getElementById('loading-tip');
    
    if (statusElement) {
        statusElement.textContent = status;
    }
    
    if (progressElement && progress !== null) {
        progressElement.style.width = `${progress}%`;
    }
    
    if (detailsElement && details !== null) {
        detailsElement.textContent = details;
    }
    
    // Показываем первую подсказку при первом вызове с анимацией
    if (loadingTipElement && !loadingTipElement.textContent && window.getRandomLoadingTip && window.animateTipChange) {
        const firstTip = window.getRandomLoadingTip();
        // Для первой подсказки используем только анимацию появления
        loadingTipElement.textContent = firstTip;
        loadingTipElement.classList.add('fade-in', 'show');
        setTimeout(() => {
            loadingTipElement.classList.remove('fade-in', 'show');
        }, 600);
        // Добавляем первую подсказку в историю
        if (window.addTipToHistory) {
            window.addTipToHistory(firstTip, 'loading');
        }
    }
}
function hideLoadingIndicator() {
    const loadingContainer = document.getElementById('loading-container');
    if (loadingContainer) {
        // Останавливаем автоматическую смену подсказок на экране загрузки
        if (window.stopLoadingTipRotation) {
            window.stopLoadingTipRotation();
        }
        
        loadingContainer.classList.add('hidden');
        // Убираем контейнер загрузки после анимации
        setTimeout(() => {
            if (loadingContainer.parentNode) {
                loadingContainer.parentNode.removeChild(loadingContainer);
            }
            // После скрытия индикатора рендерим основной контент,
            // чтобы избежать пустой страницы при первом открытии
            try { updateUI(); } catch (e) { console.error('Failed to update UI after loading hide:', e); }
        }, 500);
    }
}

// Функция для обновления статуса модального окна настроек без полной перерисовки
function updateSettingsModalStatus(status, statusType = 'info') {
    if (!S.settingsOpen || !S.settingsModal) return;
    
    S.settingsModal.status = status;
    S.settingsModal.statusType = statusType;
    
            // Обновляем только элемент статуса без полной перерисовки
    const statusElement = document.getElementById('import-export-status');
    if (statusElement) {
        const statusClass = statusType === 'error' ? 'bg-red-900/50 text-red-300' : 
                           statusType === 'success' ? 'bg-green-900/50 text-green-300' : 
                           'bg-blue-900/50 text-blue-300';
        
        statusElement.className = `mb-2 p-2 text-sm rounded-md ${statusClass}`;
        statusElement.textContent = status;
        statusElement.classList.remove('hidden');
    }
}

// Функция для поиска в данных CSV вместо API
function searchInCSVData(query, type = 'parts') {
    if (!query || query.trim().length < 2) return [];
    
    const searchTerm = query.toLowerCase().trim();
    const results = [];
    
    console.log('searchInCSVData called with:', { query, type, searchTerm });
    
    // Проверяем, что данные загружены
    if (type === 'parts' && Object.keys(PART_MAP).length === 0) {
        console.warn('PART_MAP is empty, cannot search parts');
        return [];
    }
    if (type === 'sets' && Object.keys(SET_MAP).length === 0) {
        console.warn('SET_MAP is empty, cannot search sets');
        return [];
    }
    if (type === 'minifigs' && Object.keys(MINIFIG_MAP).length === 0) {
        console.warn('MINIFIG_MAP is empty, cannot search minifigs');
        return [];
    }
    
    switch (type) {
        case 'parts':
            Object.values(PART_MAP).forEach(part => {
                if (part.name && part.name.toLowerCase().includes(searchTerm) ||
                    part.id && part.id.toLowerCase().includes(searchTerm)) {
                    results.push({
                        ...part,
                        type: 'part',
                        searchScore: calculateSearchScore(part, searchTerm)
                    });
                }
            });
            break;
            
        case 'sets':
            Object.values(SET_MAP).forEach(set => {
                if (set.name && set.name.toLowerCase().includes(searchTerm) ||
                    set.set_num && set.set_num.toLowerCase().includes(searchTerm)) {
                    results.push({
                        ...set,
                        type: 'set',
                        searchScore: calculateSearchScore(set, searchTerm)
                    });
                }
            });
            break;
            
        case 'minifigs':
            Object.values(MINIFIG_MAP).forEach(minifig => {
                if (minifig.name && minifig.name.toLowerCase().includes(searchTerm) ||
                    minifig.set_num && minifig.set_num.toLowerCase().includes(searchTerm)) {
                    results.push({
                        ...minifig,
                        type: 'minifig',
                        searchScore: calculateSearchScore(minifig, searchTerm)
                    });
                }
            });
            break;
            
        default:
            // Ищем во всех типах
            searchInCSVData(query, 'parts').forEach(r => results.push(r));
            searchInCSVData(query, 'sets').forEach(r => results.push(r));
            searchInCSVData(query, 'minifigs').forEach(r => results.push(r));
            break;
    }
    
            // Сортируем по релевантности поиска и ограничиваем результаты
    return results
        .sort((a, b) => b.searchScore - a.searchScore)
        .slice(0, 50);
}

// Функция для расчета релевантности поиска
function calculateSearchScore(item, searchTerm) {
    let score = 0;
    
            // Точное совпадение получает наивысший балл
    if (item.name && item.name.toLowerCase() === searchTerm) score += 100;
    if (item.id && item.id.toLowerCase() === searchTerm) score += 100;
    if (item.set_num && item.set_num.toLowerCase() === searchTerm) score += 100;
    
            // Начинается с поискового запроса
    if (item.name && item.name.toLowerCase().startsWith(searchTerm)) score += 50;
    if (item.id && item.id.toLowerCase().startsWith(searchTerm)) score += 50;
    if (item.set_num && item.set_num.toLowerCase().startsWith(searchTerm)) score += 50;
    
    // Contains search term
    if (item.name && item.name.toLowerCase().includes(searchTerm)) score += 25;
    if (item.id && item.id.toLowerCase().includes(searchTerm)) score += 25;
    if (item.set_num && item.set_num.toLowerCase().includes(searchTerm)) score += 25;
    

    
    return score;
}
// (Removed) Background data check/download functions kept for future use
// Function to fetch missing images from CSV data
async function fetchMissingImagesFromCSV() {
    try {
        console.log('Starting fetchMissingImagesFromCSV...');
        console.log(`PART_MAP size: ${Object.keys(PART_MAP).length}`);
        console.log(`SET_MAP size: ${Object.keys(SET_MAP).length}`);
        console.log(`MINIFIG_MAP size: ${Object.keys(MINIFIG_MAP).length}`);
        
        // Debug: Check some existing parts
        const sampleParts = Object.values(PART_MAP).slice(0, 3);
        console.log('Sample parts:', sampleParts.map(p => ({
            id: p.id,
            name: p.name,
            part_img_url: p.part_img_url,
            rebrickable_img_url: p.rebrickable_img_url
        })));
        
        // Since we now generate image URLs from CSV data, this function mainly ensures
        // that all parts, sets, and minifigs have their image URLs properly set
        
        // Check parts without images
        const partsWithoutImages = Object.values(PART_MAP).filter(p => 
            p && !p.part_img_url && !p.rebrickable_img_url
        );
        
        console.log('Parts without images:', partsWithoutImages.slice(0, 5)); // Show first 5 for debugging
        
        if (partsWithoutImages.length > 0) {
            console.log(`Found ${partsWithoutImages.length} parts without images, attempting to generate URLs`);
            
            // Try to generate image URLs for parts that don't have them
            for (const part of partsWithoutImages) {
                if (part.id) {
                    // Generate standard image URL format for parts
                    const imageUrl = `https://cdn.rebrickable.com/media/parts/${part.id}.jpg`;
                    part.part_img_url = imageUrl;
                    part.rebrickable_img_url = imageUrl; // Also set rebrickable_img_url
                    console.log(`Generated image URL for part ${part.id}: ${imageUrl}`);
                } else {
                    console.warn('Part without id:', part);
                }
            }
        } else {
            console.log('All parts already have image URLs');
        }
        
        // Check sets without images
        const setsWithoutImages = Object.values(SET_MAP).filter(s => 
            s && !s.set_img_url
        );
        
        if (setsWithoutImages.length > 0) {
            console.log(`Found ${setsWithoutImages.length} sets without images, attempting to generate URLs`);
            
            // Try to generate image URLs for sets that don't have them
            for (const set of setsWithoutImages) {
                if (set.set_num) {
                    // Generate standard image URL format for sets
                    const imageUrl = `https://cdn.rebrickable.com/media/sets/${set.set_num}.jpg`;
                    set.set_img_url = imageUrl;
                    console.log(`Generated image URL for set ${set.set_num}: ${imageUrl}`);
                }
            }
        } else {
            console.log('All sets already have image URLs');
        }
        
        // Check minifigs without images
        const minifigsWithoutImages = Object.values(MINIFIG_MAP).filter(s => 
            s && !s.minifig_img_url && !s.set_img_url
        );
        
        if (minifigsWithoutImages.length > 0) {
            console.log(`Found ${minifigsWithoutImages.length} minifigs without images, attempting to generate URLs`);
            
            // Try to generate image URLs for minifigs that don't have them
            for (const minifig of minifigsWithoutImages) {
                if (minifig.fig_num) {
                    // Generate standard image URL format for minifigs
                    const imageUrl = `https://cdn.rebrickable.com/media/minifigs/${minifig.fig_num}.jpg`;
                    minifig.minifig_img_url = imageUrl;
                    console.log(`Generated image URL for minifig ${minifig.fig_num}: ${imageUrl}`);
                }
            }
        } else {
            console.log('All minifigs already have image URLs');
        }
        
        console.log('Image URL generation from CSV completed');
        console.log(`Generated URLs for ${partsWithoutImages.length} parts, ${setsWithoutImages.length} sets, ${minifigsWithoutImages.length} minifigs`);
        
        // Debug: Check final state of some parts
        const finalSampleParts = Object.values(PART_MAP).slice(0, 3);
        console.log('Final sample parts:', finalSampleParts.map(p => ({
            id: p.id,
            name: p.name,
            part_img_url: p.part_img_url,
            rebrickable_img_url: p.rebrickable_img_url
        })));
        
    } catch (error) {
        console.error('Error in fetchMissingImagesFromCSV:', error);
    }
}

// Function to check for new data in background
async function checkForNewDataInBackground() {
    try {
        // This function runs in the background to check for any new data
        // that might be available from the API but not in our CSV files
        
        console.log('Background data check started');
        
        // For now, we'll just log that the check is complete
        // In the future, this could check for new releases or updates
        console.log('Background data check completed');
        
        // Return a resolved promise to indicate completion
        return Promise.resolve();
        
    } catch (error) {
        console.error('Error in background data check:', error);
        // Return a resolved promise even on error to prevent blocking
        return Promise.resolve();
    }
}
// Function to check what data is missing and needs API calls
function checkMissingData() {
    const missing = {
        parts: [],
        sets: [],
        minifigs: [],
        colors: [],
        categories: [],
        themes: []
    };
    
    // Since we now generate image URLs from CSV data, we don't need to check for missing images
    // Only check for data that might be truly missing (e.g., new releases not in CSV)
    
    return missing;
}

// Function to load missing data from API
async function loadMissingDataFromAPI() {
    try {
        const missing = checkMissingData();
        
        if (missing.parts.length === 0 && missing.sets.length === 0 && missing.minifigs.length === 0) {
            return;
        }
        
        // Update loading status
        updateSettingsModalStatus("Загрузка недостающих данных из API...", "info");
        
        // Since we now generate all image URLs from CSV, this function is mainly for future use
        // when new data might be available that's not in our CSV files
        
        const stats = getLoadingStats();
        
        // Update loading status
        updateSettingsModalStatus("Все данные доступны из CSV!", "success");
        
        // Save state after API loading
        saveState();
        
    } catch (error) {
        console.error('Failed to load missing data from API:', error);
    }
}

// Function to force refresh minifig data to avoid #undefined
async function refreshMinifigData() {
    try {
        const minifigsToRefresh = Object.keys(S.minifigColl).filter(figNum => !MINIFIG_MAP[figNum]?.name);
        
        if (minifigsToRefresh.length === 0) {
            return;
        }
        
        updateSettingsModalStatus("Обновление данных минифигурок...", "info");
        await fetchMissingCollectionMinifigDetails();
        
        // Update UI after refresh
        S.gridStale = true;
        updateUI();
        updateSettingsModalStatus("Данные минифигурок обновлены!", "success");
    } catch (error) {
        console.error('Failed to refresh minifig data:', error);
    }
}
// Function to force refresh image cache for better performance
async function refreshImageCache() {
    try {
        const cache = await caches.open(CACHE_NAME);
        const requests = await cache.keys();
        
        // Find image requests
        const imageRequests = requests.filter(req => 
            req.url.match(/\.(png|jpg|jpeg|gif|webp|svg)$/i) ||
            req.url.includes('cdn.rebrickable.com') ||
            req.url.includes('m.rebrickable.com')
        );
        
        if (imageRequests.length === 0) {
            return;
        }
        
        // Refresh each image by fetching it again
        for (const request of imageRequests) {
            try {
                const response = await fetch(request.url, { 
                    mode: 'no-cors',
                    cache: 'reload'
                });
                if (response) {
                    await cache.put(request, response);
                }
            } catch (error) {
                // Ignore individual image refresh errors
            }
        }
    } catch (error) {
        console.error('Failed to refresh image cache:', error);
    }
}

// Auto-refresh image cache every 30 minutes for better performance
setInterval(refreshImageCache, 30 * 60 * 1000);

// Function to force save all state data including newly fetched details
function forceSaveState() {
    try {
        saveState();
        
        // Also save any additional data that might have been fetched
        const cache = {
            parts: Object.keys(PART_MAP).length,
            colors: Object.keys(COLOR_MAP).length,
            categories: flatCategories.length,
            themes: Object.keys(THEME_MAP).length,
            sets: Object.keys(SET_MAP).length,
            minifigs: Object.keys(MINIFIG_MAP).length
        };
        
        localStorage.setItem('legoDataCacheStats', JSON.stringify(cache));
    } catch (e) {
        console.error('Failed to force save state:', e);
    }
}

// Function to get color-specific image URL with automatic API fallback
function getColorImageUrl(partNum, colorId, fallbackUrl = null) {
    const part = PART_MAP[partNum];
    if (!part || !part.colorImages) {
        // If no color images cached, trigger fetch
        fetchColorDetailsForPart(partNum).catch(console.error);
        return fallbackUrl || `data:image/svg+xml,${encodeURIComponent(I_Img("w-full h-full text-gray-500"))}`;
    }
    
    const colorImageUrl = part.colorImages[colorId];
    if (!colorImageUrl) {
        // If specific color image not found, trigger fetch
        fetchColorDetailsForPart(partNum).catch(console.error);
        return fallbackUrl || `data:image/svg+xml,${encodeURIComponent(I_Img("w-full h-full text-gray-500"))}`;
    }
    
    return `src="${colorImageUrl}" onerror="this.onerror=null; this.src='${fallbackUrl || `data:image/svg+xml,${encodeURIComponent(I_Img("w-full h-full text-gray-500"))}`}'; handleColorImageLoadError(this, '${partNum}', '${colorId}', '${colorImageUrl}');"`
}
// Function to handle color image load errors and fetch from API
async function handleColorImageLoadError(imgElement, partNum, colorId, originalUrl) {
    try {
        const key = `${partNum}:${colorId}`;
        if (PART_COLOR_FAILED.has(key)) return; // уже проваливалось — не спамим
        if (PART_COLOR_FETCHING.has(key)) return; // уже в процессе
        if (API_PART_COLOR_FETCH_COUNT >= API_PART_COLOR_FETCH_LIMIT) return; // общий лимит
        PART_COLOR_FETCHING.add(key);
        API_PART_COLOR_FETCH_COUNT++;

        // Fetch color details from API to get fresh image URL
        const colorDetails = await fetchPartColorDetailsFromAPI(partNum, colorId);
        if (colorDetails && colorDetails.part_img_url) {
            // Update the image source
            imgElement.src = colorDetails.part_img_url;
            
            // Cache the new color image URL
            if (PART_MAP[partNum] && PART_MAP[partNum].colorImages) {
                PART_MAP[partNum].colorImages[colorId] = colorDetails.part_img_url;
                forceSaveState();
            }
            // Счетчик изображений увеличиваем только при загрузке карточек, не в модалке
            try { markApiStatOnce('parts', partNum); } catch {}
            

            return;
        }
        
        console.warn(`Could not fetch color image for part ${partNum} color ${colorId}`);
        PART_COLOR_FAILED.add(key);
    } catch (error) {
        console.error('Error handling color image load error:', error);
        const key = `${partNum}:${colorId}`;
        PART_COLOR_FAILED.add(key);
    } finally {
        const key = `${partNum}:${colorId}`;
        PART_COLOR_FETCHING.delete(key);
    }
}
// Helper function to fetch part color details from API
async function fetchPartColorDetailsFromAPI(partNum, colorId) {
    try {
        // Глобальный троттлинг
        const now = Date.now();
        const since = now - lastApiRequestTime;
        if (since < API_REQUEST_DELAY) {
            await new Promise(r => setTimeout(r, API_REQUEST_DELAY - since));
        }
        lastApiRequestTime = Date.now();
        const response = await fetch(`${REBRICKABLE_API_URL}/parts/${partNum}/colors/${colorId}/`, {
            headers: {
                Authorization: `key ${getApiKey()}`
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            return data;
        }
    } catch (error) {
        console.error(`Failed to fetch color details for part ${partNum} color ${colorId}:`, error);
    }
    return null;
}
// Function to check for missing images in collection
async function fetchMissingImagesForCollection() {
    try {
        // Check for missing minifig images
        const minifigsWithoutImages = Object.values(MINIFIG_MAP).filter(m => 
            m && !m.minifig_img_url && !m.set_img_url
        );
        
        if (minifigsWithoutImages.length > 0) {
            await fetchMissingMinifigImages();
        }
        
        // Check for missing part images
        const partsWithoutImages = Object.values(PART_MAP).filter(p => 
            p && !p.part_img_url && !p.rebrickable_img_url
        );
        
        if (partsWithoutImages.length > 0) {
            // This will be handled by the existing functions
        }
        
        // Check for missing set images
        const setsWithoutImages = Object.values(SET_MAP).filter(s => 
            s && !s.set_img_url
        );
        
        if (setsWithoutImages.length > 0) {
            // This will be handled by the existing functions
        }
        
    } catch (error) {
        console.error('Error checking missing images:', error);
    }
}

// Function to check images for currently viewed items
async function fetchImagesForViewedItems() {
    try {
        // Check minifig modal
        if (S.selFigNum && MINIFIG_MAP[S.selFigNum]) {
            const minifig = MINIFIG_MAP[S.selFigNum];
            if (!minifig.minifig_img_url && !minifig.set_img_url) {
                await fetchMinifigDetails(S.selFigNum);
            }
        }
        
        // Check part modal
        if (S.selPartId && PART_MAP[S.selPartId]) {
            const part = PART_MAP[S.selPartId];
            if (!part.part_img_url && !part.rebrickable_img_url) {
                // This will be handled by the part modal itself
            }
        }
        
        // Check set modal
        if (S.selSetNum && SET_MAP[S.selSetNum]) {
            const set = SET_MAP[S.selSetNum];
            if (!set.set_img_url) {
                // This will be handled by the set modal itself
            }
        }
        
    } catch (error) {
        console.error('Error checking viewed item images:', error);
    }
}
        


async function fetchMinifigDetailsWithRetry(figNum, retries = 3, delay = 1000) {
    for (let attempt = 0; attempt < retries; attempt++) {
        try {
            await fetchMinifigDetails(figNum);
            return;
        } catch (err) {
            if (err && err.message && err.message.includes('429')) {
                // Too Many Requests, wait and retry
                await new Promise(res => setTimeout(res, delay * (attempt + 1)));
            } else {
                // Other error, do not retry
                break;
            }
        }
    }
}

async function fetchMissingCollectionMinifigDetails() {
    
    
    const allFigNums = Object.keys(S.minifigColl).filter(e => !MINIFIG_MAP[e] || !MINIFIG_MAP[e].name);
    if (allFigNums.length === 0) return;
    try {
        const batchSize = 5;
        for (let i = 0; i < allFigNums.length; i += batchSize) {
            const batch = allFigNums.slice(i, i + batchSize);
            try {
                const results = await Promise.all(batch.map(figNum => fetchMinifigDetailsWithRetry(figNum)));
                // Save state after each batch to avoid data loss
                saveState();
                
                // Счетчики обновляются внутри fetchMinifigDetails по одному на элемент
            } catch (error) {
                console.error(`Failed to fetch batch ${i}-${i + batchSize}:`, error);
            }
            // Add delay between batches to avoid rate limiting
            if (i + batchSize < allFigNums.length) {
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
    } catch (error) {
        console.error('Error in fetchMissingCollectionMinifigDetails:', error);
        // Force save state even after error to persist any successful fetches
        saveState();
    }
}

// Initialize API loading statistics if not exists
function initializeApiStats() {
    if (!localStorage.getItem('legoApiStats')) {
        const initialStats = {
            colors: 0,
            parts: 0,
            sets: 0,
            minifigs: 0,
            images: 0,
            lastUpdate: null
        };
        localStorage.setItem('legoApiStats', JSON.stringify(initialStats));
    }
}

// Вызываем инициализацию при запуске приложения
initializeApiStats();

// Функция для обновления значений фильтров при вводе
function updateFilterValue(inputElement, filterKey) {
    if (tempFilters && tempFilters.setFilters) {
        tempFilters.setFilters[filterKey] = inputElement.value;
        console.log('Filter updated via input:', filterKey, '=', inputElement.value);
        console.log('Current tempFilters.setFilters:', tempFilters.setFilters);
        
        // Сбрасываем случайное изображение минифигурки при изменении фильтров
        resetRandomMinifigImage();
    }
    
    // Также обрабатываем фильтры для деталей
    if (tempFilters && tempFilters.filters && filterKey === 'colorIds') {
        // Сбрасываем случайное изображение минифигурки при изменении цветовых фильтров
        resetRandomMinifigImage();
    }
}

// Обработчик клавиши Escape для закрытия последнего модального окна
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        // Закрытие модалки папки по Esc
        if (colorsModalEl && !colorsModalEl.classList.contains('modal-hidden')) {
            modalManager.closeModal('colors-modal-container');
            e.preventDefault();
            return;
        }
        if (modalManager.getOpenModalsCount() > 0) {
            modalManager.closeLastModal();
            e.preventDefault();
        }
        
        // Скрываем указатель sidebar-toggle по Escape (только если нет активных модальных окон)
        const activeModal = document.querySelector('[id$="-modal-container"]:not(.modal-hidden)');
        if (!activeModal) {
            hideSidebarHint();
        }
    }
});

// Инициализация modalManager
console.log('modalManager initialized');

// Функция для показа указателя sidebar-toggle
function showSidebarHint() {
    if (!S.showSidebarHint || window.innerWidth >= 1024) return;
    
    const hintEl = document.getElementById('sidebar-hint');
    if (hintEl) {
        hintEl.classList.remove('hidden');
        
        // Добавляем пульсацию к кнопке sidebar-toggle
        const sidebarToggleBtn = document.getElementById('sidebar-toggle');
        if (sidebarToggleBtn) {
            sidebarToggleBtn.classList.add('pulse');
            
            // Анимация появления кнопки
            sidebarToggleBtn.style.opacity = '0';
            sidebarToggleBtn.style.transform = 'scale(0.8) rotate(-10deg)';
            
            setTimeout(() => {
                sidebarToggleBtn.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                sidebarToggleBtn.style.opacity = '1';
                sidebarToggleBtn.style.transform = 'scale(1) rotate(0deg)';
            }, 100);
            
            // Убираем пульсацию через 5 секунд
            setTimeout(() => {
                sidebarToggleBtn.classList.remove('pulse');
            }, 5000);
        }
        
        // Автоматически скрываем через 8 секунд
        setTimeout(() => {
            hideSidebarHint();
        }, 8000);
    }
}

// Функция для скрытия указателя sidebar-toggle
function hideSidebarHint() {
    const hintEl = document.getElementById('sidebar-hint');
    if (hintEl) {
        hintEl.classList.add('hidden');
        // Сохраняем в localStorage, что указатель больше не показывать
        S.showSidebarHint = false;
        try {
            localStorage.setItem('showSidebarHint', 'false');
        } catch {}
    }
}

// Функция для анимации появления кнопок
function animateButtonsAppearance() {
    // Добавляем анимацию появления для всех кнопок
    const buttons = document.querySelectorAll('.sidebar-toggle-btn, .modal-close-btn, .sidebar-hint-close');
    
    buttons.forEach((button, index) => {
        // Сначала скрываем кнопки
        button.style.opacity = '0';
        button.style.transform = 'scale(0.8) rotate(-10deg)';
        
        // Затем показываем их с задержкой
        setTimeout(() => {
            button.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
            button.style.opacity = '1';
            button.style.transform = 'scale(1) rotate(0deg)';
        }, index * 100);
    });
}

// Функция для анимации кнопки закрытия при клике
function animateCloseButtonClick(button) {
    if (button) {
        button.style.transform = 'scale(0.9) rotate(2deg)';
        setTimeout(() => {
            button.style.transform = 'scale(1) rotate(0deg)';
        }, 150);
    }
}

    // Обработчик для кнопки закрытия указателя и клика по странице
    document.addEventListener('click', (e) => {
        if (e.target.id === 'sidebar-hint-close') {
            // Анимация кнопки при клике
            const hintCloseBtn = e.target;
            if (hintCloseBtn) {
                hintCloseBtn.style.transform = 'scale(0.9) rotate(2deg)';
                setTimeout(() => {
                    hintCloseBtn.style.transform = 'scale(1) rotate(0deg)';
                }, 150);
            }
            hideSidebarHint();
        } else if (!e.target.closest('#sidebar-hint') && !e.target.closest('.modal-content') && !e.target.closest('[id$="-modal-container"]')) {
            // Скрываем указатель при клике в любом месте страницы (кроме самого указателя и модальных окон)
            hideSidebarHint();
        }
    });
    
    // Обработчик изменения размера окна для автоматического скрытия указателя
    window.addEventListener('resize', () => {
        // Не скрываем указатель при изменении размера модальных окон
        const activeModal = document.querySelector('[id$="-modal-container"]:not(.modal-hidden)');
        if (activeModal) return;
        
        if (window.innerWidth >= 1024) {
            hideSidebarHint();
        }
    });
    
    // Обработчик прокрутки для автоматического скрытия указателя
    let scrollTimeout;
    window.addEventListener('scroll', () => {
        // Не скрываем указатель при прокрутке внутри модальных окон
        const activeModal = document.querySelector('[id$="-modal-container"]:not(.modal-hidden)');
        if (activeModal) return;
        
        if (scrollTimeout) {
            clearTimeout(scrollTimeout);
        }
        scrollTimeout = setTimeout(() => {
            hideSidebarHint();
        }, 1000);
    });
    
    // Обработчик фокуса на поиске для скрытия указателя
    document.addEventListener('focusin', (e) => {
        // Не скрываем указатель при фокусе внутри модальных окон
        const activeModal = document.querySelector('[id$="-modal-container"]:not(.modal-hidden)');
        if (activeModal && activeModal.contains(e.target)) return;
        
        if (e.target.id === 'search-input') {
            hideSidebarHint();
        }
    });

    // Система неактивности с подсказками
    console.log('🔧 Начинаем инициализацию системы неактивности...');
    
    // Переменные уже объявлены глобально выше, используем их
    inactivityOverlay = document.getElementById('inactivity-overlay');
    inactivityTip = document.getElementById('inactivity-tip');
    inactivityCloseBtn = document.getElementById('inactivity-close');

    // Функция для показа подсказки по порядку
    function showRandomTip() {
        console.log('💡 showRandomTip вызвана, стек вызовов:', new Error().stack);
        
        if (!inactivityOverlay) {
            console.log('❌ inactivityOverlay не найден');
            return;
        }
        
        // Показываем подсказку по текущему индексу
        inactivityTip.textContent = inactivityTips[currentTipIndex];
        
        inactivityOverlay.classList.remove('hidden');
        document.body.classList.add('inactive');
        
        // Показываем с анимацией
        setTimeout(() => {
            inactivityOverlay.classList.add('show');
        }, 100);
        
        // Запускаем автоматическую смену подсказок каждые 5 секунд
        startTipRotation();
        
        console.log('💡 Подсказка показана:', inactivityTips[currentTipIndex]);
    }

    // Функция для автоматической смены подсказок
    function startTipRotation() {
        if (tipRotationTimer) {
            clearInterval(tipRotationTimer);
        }
        
        tipRotationTimer = setInterval(() => {
            if (inactivityOverlay && inactivityOverlay.classList.contains('show') && inactivityTip) {
                // Переходим к следующей подсказке
                currentTipIndex = (currentTipIndex + 1) % inactivityTips.length;
                inactivityTip.textContent = inactivityTips[currentTipIndex];
            }
        }, 5000);
    }

    // Функция для остановки смены подсказок
    function stopTipRotation() {
        if (tipRotationTimer) {
            clearInterval(tipRotationTimer);
            tipRotationTimer = null;
        }
    }

    // Функция для скрытия подсказки
    function hideInactivityTip() {
        if (!inactivityOverlay) return;
        
        // Останавливаем смену подсказок
        stopTipRotation();
        
        inactivityOverlay.classList.remove('show');
        document.body.classList.remove('inactive');
        
        setTimeout(() => {
            inactivityOverlay.classList.add('hidden');
        }, 500);
        
        // Сбрасываем индекс подсказки для следующего цикла
        currentTipIndex = 0;
        
        // Сбрасываем таймер
        resetInactivityTimer();
    }

    // Функция для сброса таймера неактивности
    function resetInactivityTimer() {
        console.log('🔄 resetInactivityTimer вызвана');
        
        if (inactivityTimer) {
            console.log('⏰ Очищаем предыдущий таймер:', inactivityTimer);
            clearTimeout(inactivityTimer);
        }
        
        // Останавливаем смену подсказок при активности пользователя
        stopTipRotation();
        
        // Запускаем таймер на 90 секунд (для тестирования)
        inactivityTimer = setTimeout(() => {
            console.log('⏰ Таймер сработал! Показываем подсказку');
            showRandomTip();
        }, 90000);
        
        console.log('🔄 Таймер неактивности сброшен, следующий показ через 90 секунд. ID таймера:', inactivityTimer);
    }

    // Функция для инициализации системы неактивности
    function initInactivitySystem() {
        console.log('🚀 initInactivitySystem вызвана');
        
        // Проверяем, не инициализирована ли уже система
        if (document.hasAttribute('data-inactivity-initialized')) {
            console.log('⚠️ Система неактивности уже инициализирована');
            return;
        }
        
        inactivityOverlay = document.getElementById('inactivity-overlay');
        inactivityTip = document.getElementById('inactivity-tip');
        inactivityCloseBtn = document.getElementById('inactivity-close');
        
        console.log('🔍 Элементы найдены:', {
            overlay: !!inactivityOverlay,
            tip: !!inactivityTip,
            closeBtn: !!inactivityCloseBtn
        });
        
        // Дополнительная проверка элементов
        console.log('🔍 Проверяем элементы в DOM:');
        console.log('  - inactivity-overlay:', document.getElementById('inactivity-overlay'));
        console.log('  - inactivity-tip:', document.getElementById('inactivity-tip'));
        console.log('  - inactivity-close:', document.getElementById('inactivity-close'));
        
        if (!inactivityOverlay || !inactivityTip || !inactivityCloseBtn) {
            console.log('❌ Не все элементы найдены, выходим');
            return;
        }
        
        // Обработчик для кнопки закрытия
        inactivityCloseBtn.addEventListener('click', hideInactivityTip);
        
        // Обработчик для клика по оверлею (закрытие)
        inactivityOverlay.addEventListener('click', (e) => {
            if (e.target === inactivityOverlay) {
                hideInactivityTip();
            }
        });
        
        // Обработчики активности пользователя
        const activityEvents = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];
        
        // Проверяем, не добавлены ли уже обработчики
        if (!document.hasAttribute('data-inactivity-listeners')) {
            document.setAttribute('data-inactivity-listeners', 'true');
            
            activityEvents.forEach(event => {
                document.addEventListener(event, () => {
                    console.log(`🎯 Активность пользователя: ${event}`);
                    resetInactivityTimer();
                }, { passive: true });
            });
            
            console.log('✅ Обработчики активности добавлены');
        } else {
            console.log('⚠️ Обработчики активности уже добавлены');
        }
        
        // Запускаем таймер при инициализации
        resetInactivityTimer();
        
        // Отмечаем, что система инициализирована
        document.setAttribute('data-inactivity-initialized', 'true');
        
        console.log('✅ Система неактивности инициализирована');
    }

    // Инициализируем систему неактивности после загрузки страницы
    console.log('🔧 Скрипт системы неактивности загружен');
    console.log('🔧 document.readyState:', document.readyState);
    console.log('🔧 Текущее время:', new Date().toLocaleTimeString());
    
    // Принудительная инициализация через 3 секунды
    setTimeout(() => {
        console.log('🔧 Принудительная инициализация через 3 секунды');
        initInactivitySystem();
    }, 3000);
    
    if (document.readyState === 'loading') {
        console.log('🔧 DOM еще загружается, ждем DOMContentLoaded');
        document.addEventListener('DOMContentLoaded', () => {
            console.log('🔧 DOMContentLoaded сработал');
            initInactivitySystem();
        });
    } else {
        console.log('🔧 DOM уже загружен, инициализируем сразу');
        initInactivitySystem();
    }

    console.log('🏁 КОНЕЦ СКРИПТА СИСТЕМЫ НЕАКТИВНОСТИ');

  </script>
  
  <!-- Указатель для sidebar-toggle на малых устройствах -->
  <div id="sidebar-hint" class="sidebar-hint hidden">
      <button class="sidebar-hint-close" id="sidebar-hint-close" title="Закрыть подсказку">×</button>
      <div class="sidebar-hint-icon">📱</div>
      <div class="sidebar-hint-title">Навигация</div>
      <div class="sidebar-hint-text">Используйте кнопку меню для открытия боковой панели с каталогом и категориями</div>
  </div>

</body>
</html>