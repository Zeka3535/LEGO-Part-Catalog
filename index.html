
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Каталог деталей LEGO</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    body { font-family: sans-serif; }
    .no-scrollbar::-webkit-scrollbar { display: none; }
    .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    /* Hide native search input clear button */
    #search-input::-webkit-search-cancel-button {
      -webkit-appearance: none;
      appearance: none;
      display: none;
    }
    .checkerboard {
      background-image:
        linear-gradient(45deg, #374151 25%, transparent 25%),
        linear-gradient(-45deg, #374151 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #374151 75%),
        linear-gradient(-45deg, transparent 75%, #374151 75%);
      background-size: 8px 8px;
      background-position: 0 0, 0 4px, 4px -4px, -4px 0px;
    }
    .modal-hidden { display: none !important; }
    .loader {
      border: 4px solid #4A5568; /* gray-700 */
      border-top: 4px solid #4299E1; /* blue-400 */
      border-radius: 50%;
      width: 48px;
      height: 48px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body class="bg-gray-900 text-gray-200">

  <!-- Sidebar -->
  <aside id="sidebar-container" class="w-72 bg-gray-800 p-4 flex flex-col h-full border-r border-gray-700 fixed inset-y-0 left-0 z-40 transition-transform duration-300 ease-in-out lg:translate-x-0 -translate-x-full"></aside>

  <!-- Backdrop for mobile sidebar -->
  <div id="sidebar-backdrop" class="fixed inset-0 bg-black bg-opacity-60 z-30 hidden lg:hidden"></div>

  <div class="lg:ml-72 flex flex-col h-screen">
    <!-- Header -->
    <header id="header-container" class="bg-gray-800/50 backdrop-blur-sm sticky top-0 z-20 p-4 border-b border-gray-700"></header>
    
    <!-- Main Content -->
    <main id="main-content" class="flex-1 overflow-y-auto no-scrollbar"></main>

  </div>

  <!-- Modal -->
  <div id="modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 backdrop-blur-sm modal-hidden"></div>

  <script>
    // --- APP LOGIC ---
    
    // --- API CONFIG ---
    const REBRICKABLE_API_URL = 'https://rebrickable.com/api/v3/lego';
    const REBRICKABLE_API_KEY = '20c78cc607d6059c8d2a61338d851590';

    // --- DATA MAPS (populated dynamically) ---
    let COLOR_MAP = {};
    let PART_MAP = {};

    // --- ICONS ---
    const CatalogIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>`;
    const CollectionIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polygon points="2 17 12 22 22 17"></polygon><polygon points="2 12 12 17 22 12"></polygon></svg>`;
    const PlusIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>`;
    const MinusIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>`;
    const XIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
    const MenuIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>`;
    const UploadIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>`;
    const DownloadIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>`;
    const ImageIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>`;
    const TrashIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`;
    const SearchIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>`;

    // --- STATE MANAGEMENT ---
    let state = {
      currentView: 'catalog',
      categories: [],
      selectedCategoryId: null,
      selectedCollectionCategoryId: null,
      catalogGroups: null,
      searchQuery: '',
      searchResultGroups: null,
      isLoading: true, // Start in loading state for initialization
      apiError: null,
      selectedPartId: null, // This is the ID of the selected *variation*
      isSidebarOpen: window.innerWidth >= 1024,
      modal: {
          partGroupId: null,
          partVariations: [],
          selectedColorId: null,
          quantity: 1,
          isLoadingColors: false,
          isImageLoading: false,
          partImageUrl: null,
      },
      itemsToDisplay: 48,
      itemsIncrement: 48,
      collection: {},
      importExportStatus: { message: '', type: '' },
    };

    function loadState() {
      const savedCollection = localStorage.getItem('legoCollection');
      if (savedCollection) {
        try {
          const parsed = JSON.parse(savedCollection);
          if (typeof parsed === 'object' && parsed !== null) {
            state.collection = parsed;
          }
        } catch (e) {
          console.error("Failed to parse lego collection from localStorage", e);
          state.collection = {};
        }
      }
    }

    function saveState() {
      localStorage.setItem('legoCollection', JSON.stringify(state.collection));
    }

    // --- DOM Elements ---
    const sidebarContainer = document.getElementById('sidebar-container');
    const sidebarBackdrop = document.getElementById('sidebar-backdrop');
    const headerContainer = document.getElementById('header-container');
    const mainContent = document.getElementById('main-content');
    const modalContainer = document.getElementById('modal-container');
    
    // --- API & DATA HANDLING ---
    
    async function apiFetchPaginated(baseEndpoint) {
        let allResults = [];
        let page = 1;
        const PAGE_SIZE = 1000;

        while (true) {
            const separator = baseEndpoint.includes('?') ? '&' : '?';
            const fullUrl = `${REBRICKABLE_API_URL}${baseEndpoint}${separator}page=${page}&page_size=${PAGE_SIZE}`;
            
            const response = await fetch(fullUrl, {
                headers: { 'Authorization': `key ${REBRICKABLE_API_KEY}` }
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ detail: 'Не удалось получить детали ошибки.' }));
                throw new Error(`Ошибка API Rebrickable: ${response.status} - ${errorData.detail}`);
            }

            const data = await response.json();
            
            if (data.results && data.results.length > 0) {
                allResults = allResults.concat(data.results);
            }
            
            if (!data.next) {
                break;
            }
            page++;
        }
        return allResults;
    }

    function processPartData(apiPart) {
      if (!apiPart || !apiPart.part_num) {
        console.warn("Пропуск некорректных данных о детали из API:", apiPart);
        return null;
      }
      const partData = {
          id: apiPart.part_num,
          name: apiPart.name,
          rebrickable_img_url: apiPart.part_img_url,
          categoryId: apiPart.part_cat_id,
          num_sets: apiPart.num_sets,
          part_num: apiPart.part_num,
      };
      PART_MAP[partData.id] = { ...PART_MAP[partData.id], ...partData };
      return partData;
    }

    function getGroupId(partNum) {
        if (!partNum || typeof partNum !== 'string') return partNum || 'unknown_group';
        const match = partNum.match(/^([0-9]+)/);
        return match ? match[1] : partNum.split('p')[0];
    }
    
    function groupParts(parts) {
        const groups = {};
        parts.forEach(part => {
            if (!part || !part.part_num) {
                console.warn('Пропуск детали без номера:', part);
                return;
            }
            const groupId = getGroupId(part.part_num);
            if (!groups[groupId]) {
                groups[groupId] = [];
            }
            groups[groupId].push(part);
        });
        for (const groupId in groups) {
            groups[groupId].sort(partRelevanceComparator);
        }
        return groups;
    }

    async function fetchCategories() {
        try {
            const categories = await apiFetchPaginated('/part_categories/');
            state.categories = categories.sort((a, b) => a.name.localeCompare(b.name));
        } catch (error) {
            console.error("Ошибка загрузки категорий:", error);
            state.apiError = `Не удалось загрузить категории: ${error.message}`;
            state.categories = [];
        }
    }

    async function fetchAllColors() {
        try {
            const colors = await apiFetchPaginated('/colors/');
            colors.forEach(colorInfo => {
                const colorIdStr = String(colorInfo.id);
                COLOR_MAP[colorIdStr] = {
                    id: colorIdStr,
                    name: colorInfo.name,
                    hex: `#${colorInfo.rgb}`,
                    isTransparent: colorInfo.is_trans,
                };
            });
        } catch (error) {
            console.error("Ошибка загрузки цветов:", error);
            state.apiError = (state.apiError ? state.apiError + '\n' : '') + 'Не удалось загрузить палитру цветов.';
        }
    }

    async function loadPartsForCategory(categoryId) {
        state.selectedCategoryId = categoryId;
        state.isLoading = true;
        state.apiError = null;
        state.searchResultGroups = null;
        state.searchQuery = '';
        state.catalogGroups = null;
        state.itemsToDisplay = state.itemsIncrement;
        updateUI();

        try {
            const rawParts = await apiFetchPaginated(`/parts/?part_cat_id=${categoryId}`);
            const parts = rawParts.map(processPartData).filter(Boolean);
            state.catalogGroups = groupParts(parts);
        } catch (error) {
            console.error("Rebrickable parts fetch failed:", error);
            state.apiError = error.message;
        } finally {
            state.isLoading = false;
            updateUI();
        }
    }

    function getRelevanceScore(part, query) {
        const lowerQuery = query.toLowerCase();
        const lowerName = part.name.toLowerCase();
        const partNum = part.part_num.toLowerCase();

        if (partNum === lowerQuery) return 100;
        if (lowerName === lowerQuery) return 90;
        if (partNum.startsWith(lowerQuery)) return 80;
        if (lowerName.startsWith(lowerQuery)) return 70;
        if (partNum.includes(lowerQuery)) return 60;
        if (lowerName.includes(lowerQuery)) return 50;
        return 0;
    }

    function partRelevanceComparator(a, b) {
        if (!b || !b.part_num || !b.name) return -1;
        if (!a || !a.part_num || !a.name) return 1;

        const isPrintA = a.name.toLowerCase().includes('print') || a.name.toLowerCase().includes('sticker') || a.name.toLowerCase().includes('pattern');
        const isPrintB = b.name.toLowerCase().includes('print') || b.name.toLowerCase().includes('sticker') || b.name.toLowerCase().includes('pattern');

        if (isPrintA && !isPrintB) return 1;
        if (!isPrintA && isPrintB) return -1;

        const isAltA = a.part_num.match(/[a-zA-Z]/);
        const isAltB = b.part_num.match(/[a-zA-Z]/);

        if (isAltA && !isAltB) return 1;
        if (!isAltA && isAltB) return -1;
        
        const popularityDiff = b.num_sets - a.num_sets;
        if (popularityDiff !== 0) return popularityDiff;

        const lengthDiff = a.name.length - b.name.length;
        if (lengthDiff !== 0) return lengthDiff;

        return a.part_num.localeCompare(b.part_num);
    }
    
    async function searchRebrickableParts(query) {
        if (!query || query.trim().length === 0) {
            state.searchResultGroups = null;
            state.isLoading = false;
            state.selectedCategoryId = null;
            updateUI();
            return;
        }
        state.isLoading = true;
        state.apiError = null;
        state.selectedCategoryId = null;
        state.catalogGroups = null;
        state.itemsToDisplay = state.itemsIncrement;
        updateUI();

        try {
            const rawParts = await apiFetchPaginated(`/parts/?search=${encodeURIComponent(query)}`);
            const parts = rawParts.map(processPartData).filter(Boolean);
            const groups = groupParts(parts);
            
            const scoredGroups = Object.entries(groups).map(([groupId, partList]) => {
                const bestScore = Math.max(...partList.map(p => getRelevanceScore(p, query)));
                return { groupId, partList, bestScore };
            });

            scoredGroups.sort((a, b) => {
                if (b.bestScore !== a.bestScore) return b.bestScore - a.bestScore;
                return partRelevanceComparator(a.partList[0], b.partList[0]);
            });

            const sortedGroups = {};
            scoredGroups.forEach(g => {
                if (g.bestScore > 0) { // Only include groups that match the search
                    sortedGroups[g.groupId] = g.partList;
                }
            });
            state.searchResultGroups = sortedGroups;

        } catch (error) {
            console.error("Rebrickable search failed:", error);
            state.apiError = error.message;
            state.searchResultGroups = {};
        } finally {
            state.isLoading = false;
            updateUI();
        }
    }
    
    async function fetchPartColors(partId) {
        state.modal.isLoadingColors = true;
        renderModal();
        
        try {
            const colorAvailability = await apiFetchPaginated(`/parts/${partId}/colors/`);
            const colorIds = colorAvailability.map(c => String(c.color_id));

            PART_MAP[partId].availableColorIds = colorIds;
            if (colorIds.length > 0 && (!state.modal.selectedColorId || !colorIds.includes(state.modal.selectedColorId))) {
                state.modal.selectedColorId = colorIds[0];
                fetchPartColorSpecifics(partId, colorIds[0]);
            } else if (state.modal.selectedColorId) {
                fetchPartColorSpecifics(partId, state.modal.selectedColorId);
            }
        } catch (error) {
            console.error(`Failed to fetch colors for ${partId}:`, error);
            PART_MAP[partId].availableColorIds = PART_MAP[partId].availableColorIds || [];
        } finally {
            state.modal.isLoadingColors = false;
            renderModal();
        }
    }
    
    async function fetchPartColorSpecifics(partId, colorId) {
        state.modal.isImageLoading = true;
        renderModal();

        try {
            const url = `${REBRICKABLE_API_URL}/parts/${partId}/colors/${colorId}/`;
            const response = await fetch(url, { headers: { 'Authorization': `key ${REBRICKABLE_API_KEY}` } });
            if (!response.ok) throw new Error('Image not found for this color.');
            const data = await response.json();
            
            state.modal.partImageUrl = data.part_img_url || PART_MAP[partId]?.rebrickable_img_url;
        } catch (error) {
            console.warn(`Could not fetch color-specific image:`, error);
            state.modal.partImageUrl = PART_MAP[partId]?.rebrickable_img_url;
        } finally {
            state.modal.isImageLoading = false;
            renderModal();
        }
    }

    async function fetchColorDetailsForPart(partId) {
        if (PART_MAP[partId]?.colorImages) return;
    
        try {
            const colorAvailability = await apiFetchPaginated(`/parts/${partId}/colors/`);
            if (!PART_MAP[partId]) PART_MAP[partId] = { id: partId };
            
            const colorImages = {};
            colorAvailability.forEach(colorInfo => {
                if (colorInfo.part_img_url) {
                    colorImages[String(colorInfo.color_id)] = colorInfo.part_img_url;
                }
            });
            PART_MAP[partId].colorImages = colorImages;
    
        } catch (error) {
            console.warn(`Could not fetch color details for part ${partId}:`, error);
        }
    }
    
    async function fetchColorDetailsForCollectionParts() {
        const collectionPartIds = Object.keys(state.collection);
        const partsToFetch = collectionPartIds.filter(id => !PART_MAP[id]?.colorImages);
        
        if (partsToFetch.length === 0) return;
        console.log(`Fetching color-specific images for ${partsToFetch.length} parts from collection...`);
    
        const promises = partsToFetch.map(partId => fetchColorDetailsForPart(partId));
        await Promise.all(promises);
    }

    async function fetchMissingCollectionPartDetails() {
      const collectionPartIds = Object.keys(state.collection);
      const missingPartIds = collectionPartIds.filter(id => !PART_MAP[id] || !PART_MAP[id].name);
      if (missingPartIds.length === 0) return;

      console.log(`Fetching details for ${missingPartIds.length} parts from collection...`);
      
      const BATCH_SIZE = 100;
      for (let i = 0; i < missingPartIds.length; i += BATCH_SIZE) {
          const batch = missingPartIds.slice(i, i + BATCH_SIZE);
          try {
            const rawParts = await apiFetchPaginated(`/parts/?part_nums=${batch.join(',')}`);
            rawParts.forEach(processPartData);
          } catch(err) {
            console.error(`Could not fetch details for batch starting with part ${batch[0]}:`, err);
            state.apiError = (state.apiError ? state.apiError + '\n' : '') + 'Не удалось загрузить данные для некоторых деталей коллекции.';
          }
      }
    }


    // --- RENDER FUNCTIONS ---
    function getPartImageUrl(url) {
        const placeholderSvg = `data:image/svg+xml,${encodeURIComponent(ImageIcon('w-full h-full text-gray-500'))}`;
        if (url) {
            return `src="${url}" onerror="this.onerror=null; this.src='${placeholderSvg}';"`;
        }
        return `src="${placeholderSvg}"`;
    }

    function renderSidebar() {
      const { uniqueModelsCount, totalPartsCount } = Object.keys(state.collection).reduce((acc, partId) => {
        const colors = state.collection[partId] || {};
        const colorKeys = Object.keys(colors);
        if (colorKeys.length > 0) {
            acc.uniqueModelsCount += colorKeys.length;
            acc.totalPartsCount += Object.values(colors).reduce((sum, q) => sum + q, 0);
        }
        return acc;
      }, { uniqueModelsCount: 0, totalPartsCount: 0 });

      const viewButtonStyle = (view) => `w-1/2 flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 ${state.currentView === view ? 'bg-blue-600 text-white' : 'text-gray-300 hover:bg-gray-700 hover:text-white'}`;
      
      let categoriesToRender = state.categories;
      if (state.currentView === 'collection') {
          const collectionCategoryIds = new Set(
              Object.keys(state.collection)
                  .map(partId => PART_MAP[partId]?.categoryId)
                  .filter(id => id !== undefined && id !== null)
          );
          categoriesToRender = state.categories.filter(cat => collectionCategoryIds.has(cat.id));
      }
      
      let categoryListContent = '';
      if (state.isLoading && state.categories.length === 0) {
          categoryListContent = `<div class="flex items-center justify-center p-4"><div class="loader !w-6 !h-6"></div></div>`;
      } else if (categoriesToRender.length === 0) {
          if (state.currentView === 'collection' && Object.keys(state.collection).length > 0) {
              categoryListContent = `<li class="text-gray-400 text-sm p-2">Нет деталей в категориях.</li>`;
          }
      } else {
          categoryListContent = categoriesToRender.map(cat => {
              const isSelected = state.currentView === 'catalog' 
                  ? state.selectedCategoryId === cat.id
                  : state.selectedCollectionCategoryId === cat.id;
              const buttonStyle = isSelected ? 'bg-blue-600 text-white' : 'text-gray-300 hover:bg-gray-700 hover:text-white';
              return `
                  <li class="mb-1">
                    <button data-category-id="${cat.id}" class="w-full text-left flex items-center p-2 rounded-md transition-colors duration-150 ${buttonStyle}">
                      <span class="truncate">${cat.name}</span>
                    </button>
                  </li>
              `;
          }).join('');
      }

      sidebarContainer.innerHTML = `
        <div class="flex items-center justify-between mb-4 flex-shrink-0">
          <h1 class="text-xl font-bold text-white">Меню</h1>
          <button id="sidebar-close" class="lg:hidden text-gray-400 hover:text-white p-1">
            ${XIcon('w-6 h-6')}
          </button>
        </div>

        <div class="flex bg-gray-900/70 rounded-lg p-1 mb-4 flex-shrink-0">
          <button data-view="catalog" class="${viewButtonStyle('catalog')}">${CatalogIcon('w-5 h-5 mr-2')} Каталог</button>
          <button data-view="collection" class="${viewButtonStyle('collection')}">${CollectionIcon('w-5 h-5 mr-2')} Коллекция</button>
        </div>
        
        <div class="flex-grow overflow-y-auto no-scrollbar">
          <h2 class="text-lg font-semibold text-white mb-2">Категории</h2>
          <nav>
            <ul id="category-list">${categoryListContent}</ul>
          </nav>
        </div>
        
        <div class="flex-shrink-0 mt-4 border-t border-gray-700 pt-4">
            <h2 class="text-lg font-semibold text-white mb-2">Сводка коллекции</h2>
            ${totalPartsCount === 0 ? '<p class="text-gray-400 text-sm">Ваша коллекция пуста.</p>' : `
              <div class="space-y-2 text-sm">
                  <div class="flex justify-between"><span class="text-gray-400">Уникальные модели:</span><span class="font-bold text-white">${uniqueModelsCount}</span></div>
                  <div class="flex justify-between"><span class="text-gray-400">Всего деталей:</span><span class="font-bold text-white">${totalPartsCount}</span></div>
              </div>
            `}
        </div>

        <div class="flex-shrink-0 mt-4 border-t border-gray-700 pt-4">
            <h2 class="text-lg font-semibold text-white mb-2">Управление данными</h2>
            <div class="space-y-2">
                <button id="import-button" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-600 hover:bg-gray-500 text-white">
                    ${UploadIcon('w-5 h-5 mr-2')} Импорт .zip
                </button>
                <input type="file" id="import-zip-input" class="hidden" accept=".zip">
                <button id="export-button" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-600 hover:bg-gray-500 text-white ${totalPartsCount === 0 ? 'opacity-50 cursor-not-allowed' : ''}" ${totalPartsCount === 0 ? 'disabled' : ''}>
                    ${DownloadIcon('w-5 h-5 mr-2')} Экспорт .zip
                </button>
            </div>
            ${state.importExportStatus.message ? `
              <div id="import-export-status" class="mt-3 p-2 text-sm rounded-md ${state.importExportStatus.type === 'error' ? 'bg-red-900/50 text-red-300' : 'bg-green-900/50 text-green-300'}">
                ${state.importExportStatus.message}
              </div>
            ` : ''}
        </div>
      `;
    }

    function renderHeader() {
        headerContainer.innerHTML = `
            <div class="flex justify-between items-center gap-4">
                <div class="flex items-center">
                    <button id="sidebar-toggle" class="lg:hidden text-gray-300 hover:text-white mr-4 -ml-1 p-1">
                        ${MenuIcon('w-6 h-6')}
                    </button>
                    <h1 class="text-xl font-bold text-white hidden sm:block">LEGO® Part Catalog</h1>
                </div>
                <div class="flex items-center space-x-2 w-full max-w-sm">
                    <div class="relative flex-grow">
                        <input id="search-input" type="search" placeholder="Поиск по ID или названию..." value="${state.searchQuery}" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 pl-4 pr-10 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"/>
                        <button id="clear-search" class="absolute inset-y-0 right-0 flex items-center pr-3 text-gray-400 hover:text-white ${!state.searchQuery ? 'hidden' : ''}">${XIcon('w-5 h-5')}</button>
                    </div>
                     <button id="search-button" class="p-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors flex-shrink-0" aria-label="Поиск">
                        ${SearchIcon('w-5 h-5')}
                    </button>
                </div>
            </div>
        `;
    }

    function renderPartCard(part, color, quantity) {
        const inCollection = state.currentView === 'collection';
        const groupId = getGroupId(part.id);
        
        let quantityIndicator = '';
        if (quantity > 0) {
            const positionClass = inCollection ? 'left-2' : 'right-2';
            quantityIndicator = `<div class="absolute top-2 ${positionClass} bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md">${quantity}</div>`;
        }
        
        let imageUrl = part.rebrickable_img_url;
        if (inCollection && color) {
            const colorSpecificUrl = PART_MAP[part.id]?.colorImages?.[color.id];
            if (colorSpecificUrl) {
                imageUrl = colorSpecificUrl;
            }
        }

        return `
            <div data-group-id="${groupId}" data-part-id="${part.id}" ${inCollection ? `data-color-id="${color.id}"` : ''} class="part-card relative bg-gray-800 rounded-lg overflow-hidden group transform transition-all duration-300 hover:bg-gray-700 cursor-pointer hover:scale-105">
                ${inCollection ? `
                    <button aria-label="Удалить ${part.name} (${color.name})" data-action="delete-from-collection" data-part-id="${part.id}" data-color-id="${color.id}" class="absolute top-2 right-2 bg-red-600 text-white p-1.5 rounded-full z-10 shadow-md transition-colors hover:bg-red-700 opacity-100 focus:opacity-100 md:opacity-0 md:group-hover:opacity-100">
                        ${TrashIcon('w-4 h-4')}
                    </button>
                ` : ''}
                ${quantityIndicator}
                <div class="w-full h-40 bg-gray-700 flex items-center justify-center p-2 rounded-t-lg">
                    <div class="w-full h-full bg-white rounded-md flex items-center justify-center overflow-hidden shadow-inner">
                        <img ${getPartImageUrl(imageUrl)} alt="${part.name}" class="w-full h-full object-contain pointer-events-none" loading="lazy" />
                    </div>
                </div>
                <div class="p-4">
                    <h3 class="text-sm font-semibold text-white truncate pointer-events-none">${part.name}</h3>
                    <p class="text-xs text-gray-400 pointer-events-none">ID: ${part.id}</p>
                    ${inCollection ? `
                        <div class="flex items-center mt-2 pointer-events-none">
                            <span class="w-4 h-4 rounded-full border border-gray-500 ${color.isTransparent ? 'checkerboard' : ''}" style="background-color: ${color.hex};"></span>
                            <span class="ml-2 text-xs text-gray-300 truncate">${color.name}</span>
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
    }

    function renderGrid() {
        let content = '';
        
        if (state.isLoading) {
            content = `<div class="flex flex-col items-center justify-center h-full p-8 text-center"><div class="loader"></div><p class="mt-4 text-gray-400">Загрузка...</p></div>`;
        } else if (state.apiError) {
            content = `<div class="flex flex-col items-center justify-center h-full p-8 text-center text-red-400"><p class="font-semibold">Произошла ошибка</p><p class="text-sm mt-2">${state.apiError}</p></div>`;
        } else if (state.currentView === 'collection') {
            const items = [];
            for (const partId in state.collection) {
              for (const colorId in state.collection[partId]) {
                const part = PART_MAP[partId];
                const color = COLOR_MAP[colorId];
                const quantity = state.collection[partId][colorId];
                if (part && color && quantity > 0) {
                  items.push({ part, color, quantity });
                }
              }
            }

            let filteredItems = items;
            
            if (state.selectedCollectionCategoryId) {
                filteredItems = filteredItems.filter(({ part }) => PART_MAP[part.id]?.categoryId === state.selectedCollectionCategoryId);
            }

            const query = state.searchQuery.trim().toLowerCase();
            if (query) {
                const getClientRelevanceScore = (item, q) => {
                    const lowerName = item.part.name.toLowerCase();
                    const partId = item.part.id.toLowerCase();
                    if (partId === q) return 100;
                    if (lowerName === q) return 90;
                    if (partId.startsWith(q)) return 80;
                    if (lowerName.startsWith(q)) return 70;
                    if (partId.includes(q)) return 60;
                    if (lowerName.includes(q)) return 50;
                    return 0;
                };

                filteredItems = filteredItems
                    .map(item => ({ item, score: getClientRelevanceScore(item, query) }))
                    .filter(i => i.score > 0)
                    .sort((a, b) => b.score - a.score)
                    .map(i => i.item);

            } else {
                 filteredItems.sort((a,b) => a.part.name.localeCompare(b.part.name));
            }


            if (filteredItems.length === 0) {
                let emptyMsg = 'В вашей коллекции нет деталей';
                if (state.searchQuery) emptyMsg += ', соответствующих поиску';
                else if (state.selectedCollectionCategoryId) emptyMsg += ' в выбранной категории';
                emptyMsg += '.';
                content = `<div class="flex items-center justify-center h-full p-4 text-center"><p class="text-gray-400">${emptyMsg}</p></div>`;
            } else {
                content = `<div class="grid grid-cols-[repeat(auto-fill,minmax(160px,1fr))] gap-4 p-4">
                    ${filteredItems.map(item => renderPartCard(item.part, item.color, item.quantity)).join('')}
                </div>`;
            }
        } else { // Catalog view
            let groupsToShow = {};
            let emptyMessage = 'Выберите категорию, чтобы увидеть детали, или воспользуйтесь поиском.';

            if (state.searchResultGroups !== null) {
                groupsToShow = state.searchResultGroups;
                emptyMessage = 'По вашему запросу ничего не найдено.';
            } else if (state.selectedCategoryId !== null) {
                groupsToShow = state.catalogGroups;
                emptyMessage = 'В этой категории нет деталей.';
            }

            const groupKeys = groupsToShow ? Object.keys(groupsToShow) : [];

            if (groupKeys.length === 0) {
                content = `<div class="flex items-center justify-center h-full p-4 text-center"><p class="text-gray-400">${emptyMessage}</p></div>`;
            } else {
                const groupsToRender = groupKeys.slice(0, state.itemsToDisplay);

                content = `<div class="grid grid-cols-[repeat(auto-fill,minmax(160px,1fr))] gap-4 p-4">
                    ${groupsToRender.map(key => {
                        const representativePart = groupsToShow[key][0];
                        const totalQuantity = Object.values(state.collection[representativePart.id] || {}).reduce((sum, q) => sum + q, 0);
                        return renderPartCard(representativePart, null, totalQuantity);
                    }).join('')}
                </div>`;
                
                if (groupKeys.length > state.itemsToDisplay) {
                    content += `
                        <div class="p-4 text-center">
                            <button id="load-more-button" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 transition-colors">
                                Загрузить ещё
                            </button>
                        </div>
                    `;
                }
            }
        }
        mainContent.innerHTML = content;
    }

    function renderModal() {
        if (!state.selectedPartId) {
            modalContainer.classList.add('modal-hidden');
            document.body.classList.remove('overflow-hidden');
            modalContainer.innerHTML = '';
            return;
        }

        const part = PART_MAP[state.selectedPartId];
        if (!part) {
            state.selectedPartId = null;
            updateUI();
            return;
        }

        const { partVariations, selectedColorId, quantity, isLoadingColors, isImageLoading, partImageUrl } = state.modal;
        const selectedColor = selectedColorId ? COLOR_MAP[selectedColorId] : null;
        const currentInCollection = (state.selectedPartId && selectedColorId && state.collection[state.selectedPartId] && state.collection[state.selectedPartId][selectedColorId]) || 0;
        
        const availableColorIds = part.availableColorIds || [];

        let variationSelector = '';
        if (partVariations && partVariations.length > 1) {
            variationSelector = `
                <div class="mb-4">
                    <label for="variation-select" class="block text-sm font-medium text-gray-400 mb-1">Вариация</label>
                    <select id="variation-select" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                        ${partVariations.map(variation => `
                            <option value="${variation.id}" ${variation.id === state.selectedPartId ? 'selected' : ''}>
                                ${variation.name}
                            </option>
                        `).join('')}
                    </select>
                </div>
            `;
        }

        let colorSelectorContent = '';
        if (isLoadingColors) {
            colorSelectorContent = `<div class="flex items-center justify-center h-24"><div class="loader !w-8 !h-8"></div></div>`;
        } else if (availableColorIds.length > 0) {
            colorSelectorContent = `
                <div id="color-selector" class="grid grid-cols-6 sm:grid-cols-8 gap-2 mb-4">
                    ${availableColorIds.map(cid => {
                        const color = COLOR_MAP[cid];
                        if (!color) return '';
                        const isInCollection = state.collection[part.id] && state.collection[part.id][cid] > 0;
                        return `
                            <button data-color-id="${cid}" title="${color.name}" class="w-10 h-10 rounded-full border-2 transition-transform duration-150 overflow-hidden ${color.isTransparent ? 'checkerboard' : ''} ${selectedColorId === cid ? 'border-blue-500 scale-110' : 'border-gray-600 hover:border-gray-400'}" style="background-color: ${color.hex};">
                                ${isInCollection ? '<div class="w-2 h-2 bg-white rounded-full m-auto"></div>' : ''}
                            </button>
                        `;
                    }).join('')}
                </div>`;
        } else {
             colorSelectorContent = `<p class="text-sm text-gray-400 text-center py-4">Нет информации о доступных цветах.</p>`;
        }
        
        document.body.classList.add('overflow-hidden');
        modalContainer.innerHTML = `
        <div id="modal-content" class="bg-gray-800 rounded-lg shadow-xl w-full max-w-2xl m-4 flex flex-col md:flex-row relative">
            <button id="modal-close" class="absolute top-3 right-3 text-gray-400 hover:text-white transition-colors z-10">${XIcon('w-6 h-6')}</button>
            
            <div class="md:w-1/2 p-6 bg-gray-700/50 rounded-t-lg md:rounded-l-lg md:rounded-tr-none flex items-center justify-center relative">
                 <div class="w-48 h-48 sm:w-64 sm:h-64 bg-white rounded-lg flex items-center justify-center overflow-hidden shadow-lg relative">
                    ${isImageLoading ? `<div class="absolute inset-0 bg-gray-900/80 flex items-center justify-center z-10"><div class="loader !w-10 !h-10"></div></div>` : ''}
                    <img ${getPartImageUrl(partImageUrl)} alt="${part.name}" class="max-w-full max-h-full object-contain">
                 </div>
            </div>
            
            <div class="md:w-1/2 p-6 flex flex-col">
                <h2 class="text-2xl font-bold text-white">${part.name}</h2>
                <p class="text-sm text-gray-400 mb-4">ID: ${part.id}</p>
                
                ${variationSelector}
                
                <div class="flex-grow">
                    <h3 class="text-md font-semibold text-gray-300 mb-2">Доступные цвета</h3>
                    ${colorSelectorContent}
                </div>
                
                ${selectedColor ? `
                    <div class="bg-gray-700/50 rounded-lg p-4 mt-auto">
                        <div class="space-y-3">
                            <div class="grid grid-cols-2 gap-x-4 items-center">
                                <p class="text-white font-semibold truncate" title="${selectedColor.name}">${selectedColor.name}</p>
                                <p class="text-sm text-gray-400 text-right">В коллекции: <span class="font-bold text-white">${currentInCollection}</span></p>
                            </div>
                            
                            <div class="grid grid-cols-2 gap-x-4 items-center">
                                <div class="flex items-center gap-2">
                                    <button data-action="decrease-qty" class="p-2 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors">${MinusIcon('w-5 h-5')}</button>
                                    <input type="number" value="${quantity}" readonly class="w-12 text-center bg-gray-900 text-white font-bold rounded-md py-1"/>
                                    <button data-action="increase-qty" class="p-2 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors">${PlusIcon('w-5 h-5')}</button>
                                </div>
                                <button data-action="update-collection" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors">
                                    ${currentInCollection > 0 ? 'Обновить' : 'Добавить'}
                                </button>
                            </div>
                            ${currentInCollection > 0 ? `
                                <div>
                                    <button data-action="delete-from-collection-modal" class="w-full mt-1 text-sm text-red-400 hover:text-red-300 hover:bg-red-900/50 rounded-md py-1.5 transition-colors">Удалить из коллекции</button>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                ` : ''}
            </div>
        </div>
        `;
        modalContainer.classList.remove('modal-hidden');
    }

    function updateUI() {
        renderSidebar();
        renderHeader();
        renderGrid();
        renderModal();

        const isMobile = window.innerWidth < 1024;
        if (isMobile) {
            if (state.isSidebarOpen) {
                sidebarContainer.classList.remove('-translate-x-full');
                sidebarBackdrop.classList.remove('hidden');
                document.body.style.overflow = 'hidden';
            } else {
                sidebarContainer.classList.add('-translate-x-full');
                sidebarBackdrop.classList.add('hidden');
                document.body.style.overflow = '';
            }
        } else {
            sidebarContainer.classList.remove('-translate-x-full');
            sidebarBackdrop.classList.add('hidden');
            document.body.style.overflow = '';
        }
    }

    // --- IMPORT/EXPORT HANDLING ---
    async function handleZipImport(event) {
        const file = event.target.files[0];
        if (!file) return;

        state.importExportStatus = { message: 'Обработка файла...', type: 'success' };
        updateUI();

        try {
            const jszip = new JSZip();
            const zip = await jszip.loadAsync(file);
            const collectionFile = zip.file('collection.json');

            if (!collectionFile) throw new Error("Файл 'collection.json' не найден.");
            
            const content = await collectionFile.async('string');
            const importedCollection = JSON.parse(content);

            let mergedCount = 0;
            for (const partId in importedCollection) {
                if (!state.collection[partId]) state.collection[partId] = {};
                for (const colorId in importedCollection[partId]) {
                    const quantity = importedCollection[partId][colorId];
                    if (typeof quantity === 'number' && quantity > 0) {
                        state.collection[partId][colorId] = (state.collection[partId][colorId] || 0) + quantity;
                        mergedCount++;
                    }
                }
            }
            
            saveState();
            state.importExportStatus = { message: `Импорт успешен! Добавлено ${mergedCount} записей.`, type: 'success' };
            await fetchMissingCollectionPartDetails();
            await fetchColorDetailsForCollectionParts();
        } catch (error) {
            console.error("Import failed:", error);
            state.importExportStatus = { message: `Ошибка импорта: ${error.message}`, type: 'error' };
        } finally {
            event.target.value = '';
            updateUI();
        }
    }

    async function handleExportCollection() {
        state.importExportStatus = { message: '', type: '' };
        if (Object.keys(state.collection).length === 0) {
            state.importExportStatus = { message: 'Коллекция пуста для экспорта.', type: 'error' };
            updateUI();
            return;
        }

        try {
            const jszip = new JSZip();
            jszip.file("collection.json", JSON.stringify(state.collection, null, 2));
            const blob = await jszip.generateAsync({ type: "blob" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = `lego-collection-${new Date().toISOString().slice(0,10)}.zip`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            state.importExportStatus = { message: 'Экспорт начался.', type: 'success' };
        } catch (error) {
            console.error("Export failed:", error);
            state.importExportStatus = { message: `Ошибка экспорта: ${error.message}`, type: 'error' };
        }
        updateUI();
    }

    // --- EVENT HANDLING ---
    async function handleUpdateCollection(partId, colorId, quantity) {
        if (!state.collection[partId]) state.collection[partId] = {};
        
        if (quantity > 0) {
            state.collection[partId][colorId] = quantity;
        } else {
            delete state.collection[partId][colorId];
            if (Object.keys(state.collection[partId]).length === 0) {
                delete state.collection[partId];
            }
        }

        if (quantity > 0 && !PART_MAP[partId]?.colorImages) {
            await fetchColorDetailsForPart(partId);
        }
        
        state.importExportStatus = { message: '', type: '' };
        saveState();
        updateUI();
    }
    
    function clearStatusOnClick() {
        if(state.importExportStatus.message) {
            state.importExportStatus = { message: '', type: '' };
            renderSidebar();
        }
    }

    function triggerSearch() {
        clearStatusOnClick();
        const query = state.searchQuery.trim();

        if (state.currentView === 'collection') {
            state.selectedCollectionCategoryId = null; 
            updateUI();
        } else {
            searchRebrickableParts(query);
        }
    }
    
    document.addEventListener('click', (e) => {
        if (!(e.target instanceof Element)) return;
        const target = e.target;
        const isMobile = window.innerWidth < 1024;

        if (target.closest('#sidebar-toggle')) {
            clearStatusOnClick();
            state.isSidebarOpen = true;
            updateUI();
            return;
        }
        if (target.closest('#sidebar-close') || target.id === 'sidebar-backdrop') {
            state.isSidebarOpen = false;
            updateUI();
            return;
        }

        const viewButton = target.closest('[data-view]');
        if (viewButton?.dataset.view) {
            clearStatusOnClick();
            const newView = viewButton.dataset.view;
            if (state.currentView === newView) return;

            state.currentView = newView;
            state.searchQuery = '';
            state.searchResultGroups = null;
            state.catalogGroups = null;
            state.selectedCategoryId = null;
            state.selectedCollectionCategoryId = null;
            state.itemsToDisplay = state.itemsIncrement;
            if (isMobile) state.isSidebarOpen = false;
            updateUI();
            return;
        }

        const categoryButton = target.closest('[data-category-id]');
        if (categoryButton?.dataset.categoryId) {
            const catId = parseInt(categoryButton.dataset.categoryId, 10);
            clearStatusOnClick();
            state.searchQuery = '';

            if (state.currentView === 'collection') {
                state.selectedCollectionCategoryId = state.selectedCollectionCategoryId === catId ? null : catId;
                if (isMobile) state.isSidebarOpen = false;
                updateUI();
            } else {
                state.selectedCategoryId = state.selectedCategoryId === catId ? null : catId;
                state.selectedCollectionCategoryId = null;
                if (state.selectedCategoryId) {
                    loadPartsForCategory(catId);
                } else {
                    state.catalogGroups = null;
                    state.searchResultGroups = null;
                    updateUI();
                }
                if (isMobile) state.isSidebarOpen = false;
            }
            return;
        }

        if(target.closest('#load-more-button')) {
            state.itemsToDisplay += state.itemsIncrement;
            updateUI();
            return;
        }
        
        const deleteButton = target.closest('[data-action="delete-from-collection"]');
        if (deleteButton?.dataset.partId && deleteButton.dataset.colorId) {
            handleUpdateCollection(deleteButton.dataset.partId, deleteButton.dataset.colorId, 0);
            return;
        }
        
        const partCard = target.closest('.part-card');
        if (partCard?.dataset.groupId && partCard.dataset.partId) {
            clearStatusOnClick();
            state.selectedPartId = partCard.dataset.partId;
            const groupId = partCard.dataset.groupId;
            const representativePart = PART_MAP[state.selectedPartId];
            if (!representativePart) { state.selectedPartId = null; return; }

            const groupsSource = state.searchResultGroups || state.catalogGroups;
            const variations = (groupsSource && groupsSource[groupId]) ? groupsSource[groupId] : [representativePart];
            
            state.modal = { 
                partGroupId: groupId,
                partVariations: variations,
                selectedColorId: null, 
                quantity: 1, 
                isLoadingColors: false,
                isImageLoading: false,
                partImageUrl: representativePart.rebrickable_img_url,
            };
            
            if (state.currentView === 'collection' && partCard.dataset.colorId) {
                // This logic needs adjustment for grouping, as collection view is flat.
                // For now, opening from collection will behave like catalog.
                // Future improvement: group collection items too.
            }
            
            if (!representativePart.availableColorIds) {
                fetchPartColors(representativePart.id);
            } else if (representativePart.availableColorIds.length > 0) {
                state.modal.selectedColorId = representativePart.availableColorIds[0];
                fetchPartColorSpecifics(representativePart.id, representativePart.availableColorIds[0]);
            }
            
            updateUI();
            return;
        }
        
        if (target.id === 'modal-container' || target.closest('#modal-close')) {
            state.selectedPartId = null;
            updateUI();
            return;
        }

        if (target.closest('#search-button')) {
            triggerSearch();
            return;
        }
        
        if (target.closest('#clear-search')) {
            state.searchQuery = '';
            document.getElementById('search-input')?.focus();
            triggerSearch();
            return;
        }

        if (target.closest('#import-button')) { document.getElementById('import-zip-input')?.click(); return; }
        if (target.closest('#export-button')) { handleExportCollection(); return; }

        const modalContent = document.getElementById('modal-content');
        if (modalContent?.contains(target)) {
            const colorButton = target.closest('[data-color-id]');
            if (colorButton?.dataset.colorId) {
                const newColorId = colorButton.dataset.colorId;
                if(state.modal.selectedColorId !== newColorId) {
                    state.modal.selectedColorId = newColorId;
                    const currentQuantity = (state.collection[state.selectedPartId]?.[state.modal.selectedColorId]) || 0;
                    state.modal.quantity = currentQuantity > 0 ? currentQuantity : 1;
                    fetchPartColorSpecifics(state.selectedPartId, newColorId);
                }
                return;
            }

            const actionButton = target.closest('[data-action]');
            if (actionButton?.dataset.action) {
                const { action } = actionButton.dataset;
                if (action === 'increase-qty') {
                    state.modal.quantity++;
                } else if (action === 'decrease-qty') {
                    state.modal.quantity = Math.max(1, state.modal.quantity - 1);
                } else if (action === 'update-collection' && state.modal.selectedColorId && state.selectedPartId) {
                    handleUpdateCollection(state.selectedPartId, state.modal.selectedColorId, state.modal.quantity);
                } else if (action === 'delete-from-collection-modal' && state.modal.selectedColorId && state.selectedPartId) {
                    handleUpdateCollection(state.selectedPartId, state.modal.selectedColorId, 0);
                    state.selectedPartId = null;
                }
                updateUI();
            }
        }
    });

    document.addEventListener('input', (e) => {
        if (e.target.id === 'search-input') {
            state.searchQuery = e.target.value;
            const clearButton = document.getElementById('clear-search');
            if (clearButton) {
                clearButton.classList.toggle('hidden', !state.searchQuery);
            }
            if (state.currentView === 'collection') {
                if (state.selectedCollectionCategoryId !== null) {
                    state.selectedCollectionCategoryId = null;
                    renderSidebar();
                }
                renderGrid();
            }
        }
    });
    
    document.addEventListener('keydown', (e) => {
        if (e.target.id === 'search-input' && e.key === 'Enter') {
            e.preventDefault();
            triggerSearch();
        }
    });

    document.addEventListener('change', (e) => {
        if (e.target.id === 'import-zip-input') {
            handleZipImport(e);
        }
        if (e.target.id === 'variation-select') {
            const newPartId = e.target.value;
            if (state.selectedPartId === newPartId) return;

            state.selectedPartId = newPartId;
            const newPart = PART_MAP[newPartId];
            
            state.modal.selectedColorId = null;
            state.modal.quantity = 1;
            state.modal.partImageUrl = newPart.rebrickable_img_url;
            state.modal.isLoadingColors = true;

            fetchPartColors(newPart.id);
        }
    });

    window.addEventListener('resize', () => {
        const isDesktop = window.innerWidth >= 1024;
        if (isDesktop && !state.isSidebarOpen) {
          state.isSidebarOpen = true;
        }
        updateUI();
    });

    // --- INITIALIZATION ---
    async function initializeApp() {
        loadState();
        updateUI();
        
        try {
            await Promise.all([
                fetchCategories(),
                fetchAllColors()
            ]);
            
            await fetchMissingCollectionPartDetails();
            await fetchColorDetailsForCollectionParts();
        } catch (error) {
            console.error("Initialization failed:", error);
            state.apiError = error.message;
        } finally {
            state.isLoading = false;
            updateUI();
        }
    }

    initializeApp();
  </script>
</body>
</html>
