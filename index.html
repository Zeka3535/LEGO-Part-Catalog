
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Каталог деталей LEGO</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    body { font-family: sans-serif; }
    .no-scrollbar::-webkit-scrollbar { display: none; }
    .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    #search-input::-webkit-search-cancel-button {
      -webkit-appearance: none;
      appearance: none;
      display: none;
    }
    .checkerboard {
      background-image:
        linear-gradient(45deg, #374151 25%, transparent 25%),
        linear-gradient(-45deg, #374151 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #374151 75%),
        linear-gradient(-45deg, transparent 75%, #374151 75%);
      background-size: 8px 8px;
      background-position: 0 0, 0 4px, 4px -4px, -4px 0px;
    }
    .modal-hidden { display: none !important; }
    .loader {
      border: 4px solid #4A5568;
      border-top: 4px solid #4299E1;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Animation Keyframes */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }
    @keyframes scaleIn {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }
    @keyframes scaleOut {
      from { opacity: 1; transform: scale(1); }
      to { opacity: 0; transform: scale(0.95); }
    }
    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(1rem); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Animation Classes */
    #modal-container, #filter-modal-container {
        opacity: 0;
        transition: opacity 0.2s ease-out;
    }
    #modal-container.visible, #filter-modal-container.visible {
        opacity: 1;
    }
    .modal-content-enter {
      animation: scaleIn 0.2s ease-out forwards;
    }
    .modal-content-leave {
      animation: scaleOut 0.2s ease-out forwards;
    }
    .part-card.animate-in {
      opacity: 0;
      animation: fadeInUp 0.4s ease-out forwards;
    }
    
    #color-selector-wrapper {
        transition: max-height 0.35s ease-in-out;
        overflow: hidden;
    }
  </style>
</head>
<body class="bg-gray-900 text-gray-200">

  <!-- Sidebar -->
  <aside id="sidebar-container" class="w-72 bg-gray-800 p-4 flex flex-col h-full border-r border-gray-700 fixed inset-y-0 left-0 z-40 transition-transform duration-300 ease-in-out lg:translate-x-0 -translate-x-full"></aside>

  <!-- Backdrop for mobile sidebar -->
  <div id="sidebar-backdrop" class="fixed inset-0 bg-black bg-opacity-60 z-30 hidden lg:hidden"></div>

  <div class="lg:ml-72 flex flex-col h-screen">
    <!-- Header -->
    <header id="header-container" class="bg-gray-800/50 backdrop-blur-sm sticky top-0 z-20 p-4 border-b border-gray-700"></header>
    
    <!-- Main Content -->
    <main id="main-content" class="flex-1 overflow-y-auto no-scrollbar"></main>

  </div>

  <!-- Modal -->
  <div id="modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 backdrop-blur-sm modal-hidden"></div>
  
  <!-- Filter Modal -->
  <div id="filter-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 backdrop-blur-sm modal-hidden"></div>


  <script>
    // --- APP LOGIC ---
    
    // --- API CONFIG ---
    const REBRICKABLE_API_URL = 'https://rebrickable.com/api/v3/lego';
    const REBRICKABLE_API_KEY = '20c78cc607d6059c8d2a61338d851590';

    // --- UI CONFIG ---
    const COLOR_COLLAPSE_THRESHOLD = 18;

    // --- DATA MAPS (populated dynamically) ---
    let COLOR_MAP = {};
    let PART_MAP = {};
    let flatCategories = [];

    // --- ICONS ---
    const CatalogIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>`;
    const CollectionIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polygon points="2 17 12 22 22 17"></polygon><polygon points="2 12 12 17 22 12"></polygon></svg>`;
    const PlusIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>`;
    const MinusIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>`;
    const XIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
    const MenuIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>`;
    const UploadIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>`;
    const DownloadIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>`;
    const ImageIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>`;
    const TrashIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`;
    const SearchIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>`;
    const ChevronDownIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>`;
    const DiceIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><path d="M16 8h.01"></path><path d="M12 12h.01"></path><path d="M8 16h.01"></path><path d="M8 8h.01"></path><path d="M16 16h.01"></path></svg>`;
    const BrickIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="10" rx="2" ry="2"></rect><path d="M7 11V7a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v4"></path><path d="M12 11V7"></path></svg>`;
    const PlateIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="15" width="18" height="6" rx="1"></rect><circle cx="8" cy="18" r="1"></circle><circle cx="16" cy="18" r="1"></circle></svg>`;
    const TechnicIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20.94c1.5 0 2.85-.93 3.53-2.28a3.99 3.99 0 0 0-7.06 0c.68 1.35 2.03 2.28 3.53 2.28z"></path><path d="M12 3.06c-1.5 0-2.85.93-3.53 2.28a3.99 3.99 0 0 0 7.06 0C14.85 3.99 13.5 3.06 12 3.06z"></path><path d="M3.06 12c0-1.5.93-2.85 2.28-3.53a3.99 3.99 0 0 0 0 7.06C3.99 14.85 3.06 13.5 3.06 12z"></path><path d="M20.94 12c0 1.5-.93 2.85-2.28 3.53a3.99 3.99 0 0 0 0-7.06c1.35.68 2.28 2.03 2.28 3.53z"></path><circle cx="12" cy="12" r="1"></circle></svg>`;
    const SlopeIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 20h18L3 4v16z"></path></svg>`;
    const TileIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>`;
    const WindowIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"></rect><path d="M3 12h18"></path><path d="M12 3v18"></path></svg>`;
    const WheelIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle></svg>`;
    const MinifigIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="8" r="3"></circle><path d="M12 11v5"></path><path d="M9 22v-5h6v5"></path><path d="M9 11H5a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h4"></path><path d="M15 11h4a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-4"></path></svg>`;
    const BarIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12h16"></path><path d="M4 12a2 2 0 1 0-4 0 2 2 0 0 0 4 0z"></path><path d="M20 12a2 2 0 1 0 4 0 2 2 0 0 0-4 0z"></path></svg>`;
    const ArchIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 21V11c0-3.87 3.13-7 7-7s7 3.13 7 7v10"></path><path d="M5 21h14"></path></svg>`;
    const OtherIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>`;
    const FilterIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>`;

    // --- STATE MANAGEMENT ---
    let state = {
      currentView: 'catalog',
      categoryTree: [],
      expandedCategories: new Set(),
      selectedCategoryId: null,
      selectedCollectionCategoryId: null,
      catalogGroups: null,
      searchQuery: '',
      searchResultGroups: null,
      isLoading: true, // Start in loading state for initialization
      apiError: null,
      selectedPartId: null, // This is the ID of the selected *variation*
      isSidebarOpen: window.innerWidth >= 1024,
      isGridStale: true, // Flag to trigger grid animations
      modal: {
          partGroupId: null,
          partVariations: [],
          selectedColorId: null,
          quantity: 1,
          isLoadingColors: false,
          isImageLoading: false,
          partImageUrl: null,
          areColorsExpanded: false,
      },
      itemsToDisplay: 48,
      itemsIncrement: 48,
      collection: {},
      importExportStatus: { message: '', type: '' },
      isFilterModalOpen: false,
      filters: {
          colorIds: [],
          inCollectionOnly: false,
      },
      sortBy: 'relevance', // 'relevance', 'alpha_asc', 'alpha_desc', 'popularity'
    };
    
    let tempFilters = {};

    function loadState() {
      const savedCollection = localStorage.getItem('legoCollection');
      if (savedCollection) {
        try {
          const parsed = JSON.parse(savedCollection);
          if (typeof parsed === 'object' && parsed !== null) {
            state.collection = parsed;
          }
        } catch (e) {
          console.error("Failed to parse lego collection from localStorage", e);
          state.collection = {};
        }
      }
    }

    function saveState() {
      localStorage.setItem('legoCollection', JSON.stringify(state.collection));
    }

    // --- DOM Elements ---
    const sidebarContainer = document.getElementById('sidebar-container');
    const sidebarBackdrop = document.getElementById('sidebar-backdrop');
    const headerContainer = document.getElementById('header-container');
    const mainContent = document.getElementById('main-content');
    const modalContainer = document.getElementById('modal-container');
    const filterModalContainer = document.getElementById('filter-modal-container');
    
    // --- API & DATA HANDLING ---
    
    async function apiFetchPaginated(baseEndpoint) {
        let allResults = [];
        let page = 1;
        const PAGE_SIZE = 1000;

        while (true) {
            const separator = baseEndpoint.includes('?') ? '&' : '?';
            const fullUrl = `${REBRICKABLE_API_URL}${baseEndpoint}${separator}page=${page}&page_size=${PAGE_SIZE}`;
            
            const response = await fetch(fullUrl, {
                headers: { 'Authorization': `key ${REBRICKABLE_API_KEY}` }
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ detail: 'Не удалось получить детали ошибки.' }));
                throw new Error(`Ошибка API Rebrickable: ${response.status} - ${errorData.detail}`);
            }

            const data = await response.json();
            
            if (data.results && data.results.length > 0) {
                allResults = allResults.concat(data.results);
            }
            
            if (!data.next) {
                break;
            }
            page++;
        }
        return allResults;
    }

    function processPartData(apiPart) {
      if (!apiPart || !apiPart.part_num) {
        console.warn("Пропуск некорректных данных о детали из API:", apiPart);
        return null;
      }
      const partData = {
          id: apiPart.part_num,
          name: apiPart.name,
          rebrickable_img_url: apiPart.part_img_url,
          categoryId: apiPart.part_cat_id,
          num_sets: apiPart.num_sets,
          part_num: apiPart.part_num,
      };
      PART_MAP[partData.id] = { ...PART_MAP[partData.id], ...partData };
      return partData;
    }

    function getGroupId(partNum) {
        if (!partNum || typeof partNum !== 'string') return partNum || 'unknown_group';
        const match = partNum.match(/^([0-9]+)/);
        return match ? match[1] : partNum.split('p')[0];
    }
    
    function groupParts(parts) {
        const groups = {};
        parts.forEach(part => {
            if (!part || !part.part_num) {
                console.warn('Пропуск детали без номера:', part);
                return;
            }
            const groupId = getGroupId(part.part_num);
            if (!groups[groupId]) {
                groups[groupId] = [];
            }
            groups[groupId].push(part);
        });
        for (const groupId in groups) {
            groups[groupId].sort(partRelevanceComparator);
        }
        return groups;
    }

    function buildCategoryTree(categories) {
        const categoryGroups = {
            'Bricks': ['brick'],
            'Plates': ['plate'],
            'Technic': ['technic'],
            'Slopes & Wedges': ['slope', 'wedge'],
            'Tiles': ['tile'],
            'Panels, Doors & Windows': ['panel', 'door', 'window'],
            'Wheels & Tyres': ['wheel', 'tyre'],
            'Minifig': ['minifig', 'minidoll', 'headwear'],
            'Bars, Hinges & Connectors': ['bar', 'hinge', 'connector', 'link', 'axle', 'pin'],
            'Arches & Curves': ['arch', 'curved', 'round', 'cone', 'cylinder'],
        };

        const tree = {};
        const other = [];

        categories.forEach(cat => {
            const lowerName = cat.name.toLowerCase();
            let found = false;
            for (const groupName in categoryGroups) {
                if (categoryGroups[groupName].some(keyword => lowerName.includes(keyword))) {
                    if (!tree[groupName]) {
                        tree[groupName] = { name: groupName, children: [] };
                    }
                    tree[groupName].children.push(cat);
                    found = true;
                    break;
                }
            }
            if (!found) {
                other.push(cat);
            }
        });
        
        const sortedTree = Object.values(tree).sort((a,b) => a.name.localeCompare(b.name));
        
        if (other.length > 0) {
            sortedTree.push({ name: 'Other', children: other.sort((a,b) => a.name.localeCompare(b.name))});
        }
        
        return sortedTree;
    }


    async function fetchCategories() {
        try {
            const categories = await apiFetchPaginated('/part_categories/');
            flatCategories = categories.sort((a, b) => a.name.localeCompare(b.name));
            state.categoryTree = buildCategoryTree(flatCategories);
        } catch (error) {
            console.error("Ошибка загрузки категорий:", error);
            state.apiError = `Не удалось загрузить категории: ${error.message}`;
            state.categoryTree = [];
        }
    }

    async function fetchAllColors() {
        try {
            const colors = await apiFetchPaginated('/colors/');
            colors.forEach(colorInfo => {
                const colorIdStr = String(colorInfo.id);
                COLOR_MAP[colorIdStr] = {
                    id: colorIdStr,
                    name: colorInfo.name,
                    hex: `#${colorInfo.rgb}`,
                    isTransparent: colorInfo.is_trans,
                };
            });
        } catch (error) {
            console.error("Ошибка загрузки цветов:", error);
            state.apiError = (state.apiError ? state.apiError + '\n' : '') + 'Не удалось загрузить палитру цветов.';
        }
    }

    async function loadPartsForCategory(categoryId) {
        state.selectedCategoryId = categoryId;
        state.isLoading = true;
        state.apiError = null;
        state.searchResultGroups = null;
        state.searchQuery = '';
        state.catalogGroups = null;
        state.itemsToDisplay = state.itemsIncrement;
        state.isGridStale = true;
        updateUI();

        if (state.filters.colorIds && state.filters.colorIds.length > 1) {
            state.catalogGroups = {};
            state.isLoading = false;
            updateUI();
            return;
        }

        try {
            let endpoint = `/parts/?part_cat_id=${categoryId}`;
            if (state.filters.colorIds && state.filters.colorIds.length === 1) {
                endpoint += `&color_id=${state.filters.colorIds[0]}`;
            }
            const rawParts = await apiFetchPaginated(endpoint);
            const parts = rawParts.map(processPartData).filter(Boolean);
            
            let filteredParts = parts;
            if (state.filters.inCollectionOnly) {
                 filteredParts = parts.filter(p => state.collection[p.id] && Object.keys(state.collection[p.id]).length > 0);
            }

            state.catalogGroups = groupParts(filteredParts);
        } catch (error) {
            console.error("Rebrickable parts fetch failed:", error);
            state.apiError = error.message;
        } finally {
            state.isLoading = false;
            updateUI();
        }
    }

    function getRelevanceScore(part, query) {
        const lowerQuery = query.toLowerCase();
        const lowerName = part.name.toLowerCase();
        const partNum = part.part_num.toLowerCase();

        if (partNum === lowerQuery) return 100;
        if (lowerName === lowerQuery) return 90;
        if (partNum.startsWith(lowerQuery)) return 80;
        if (lowerName.startsWith(lowerQuery)) return 70;
        if (partNum.includes(lowerQuery)) return 60;
        if (lowerName.includes(lowerQuery)) return 50;
        return 0;
    }

    function partRelevanceComparator(a, b) {
        if (!b || !b.part_num || !b.name) return -1;
        if (!a || !a.part_num || !a.name) return 1;

        const isPrintA = a.name.toLowerCase().includes('print') || a.name.toLowerCase().includes('sticker') || a.name.toLowerCase().includes('pattern');
        const isPrintB = b.name.toLowerCase().includes('print') || b.name.toLowerCase().includes('sticker') || b.name.toLowerCase().includes('pattern');
        if (isPrintA && !isPrintB) return 1;
        if (!isPrintA && isPrintB) return -1;

        const isAltA = a.part_num.match(/[a-zA-Z]/);
        const isAltB = b.part_num.match(/[a-zA-Z]/);
        if (isAltA && !isAltB) return 1;
        if (!isAltA && isAltB) return -1;
        
        const popularityDiff = b.num_sets - a.num_sets;
        if (popularityDiff !== 0) return popularityDiff;

        const lengthDiff = a.name.length - b.name.length;
        if (lengthDiff !== 0) return lengthDiff;

        return a.part_num.localeCompare(b.part_num);
    }
    
    async function searchRebrickableParts(query) {
        if (!query || query.trim().length === 0) {
            state.searchResultGroups = null;
            state.isLoading = false;
            state.selectedCategoryId = null;
            state.isGridStale = true;
            updateUI();
            return;
        }
        state.isLoading = true;
        state.apiError = null;
        state.selectedCategoryId = null;
        state.catalogGroups = null;
        state.itemsToDisplay = state.itemsIncrement;
        state.isGridStale = true;
        updateUI();

        if (state.filters.colorIds && state.filters.colorIds.length > 1) {
            state.searchResultGroups = {};
            state.isLoading = false;
            updateUI();
            return;
        }

        try {
            let endpoint = `/parts/?search=${encodeURIComponent(query)}`;
            if (state.filters.colorIds && state.filters.colorIds.length === 1) {
                endpoint += `&color_id=${state.filters.colorIds[0]}`;
            }
            const rawParts = await apiFetchPaginated(endpoint);
            let parts = rawParts.map(processPartData).filter(Boolean);
            
            if (state.filters.inCollectionOnly) {
                 parts = parts.filter(p => state.collection[p.id] && Object.keys(state.collection[p.id]).length > 0);
            }

            const groups = groupParts(parts);
            
            const scoredGroups = Object.entries(groups).map(([groupId, partList]) => {
                const bestScore = Math.max(...partList.map(p => getRelevanceScore(p, query)));
                return { groupId, partList, bestScore };
            });

            scoredGroups.sort((a, b) => {
                if (b.bestScore !== a.bestScore) return b.bestScore - a.bestScore;
                return partRelevanceComparator(a.partList[0], b.partList[0]);
            });

            const sortedGroups = {};
            scoredGroups.forEach(g => {
                if (g.bestScore > 0) { // Only include groups that match the search
                    sortedGroups[g.groupId] = g.partList;
                }
            });
            state.searchResultGroups = sortedGroups;

        } catch (error) {
            console.error("Rebrickable search failed:", error);
            state.apiError = error.message;
            state.searchResultGroups = {};
        } finally {
            state.isLoading = false;
            updateUI();
        }
    }
    
    async function fetchPartColors(partId) {
        state.modal.isLoadingColors = true;
        updateModalPartially({ colors: true });
        
        try {
            const colorAvailability = await apiFetchPaginated(`/parts/${partId}/colors/`);
            const colorIds = colorAvailability.map(c => String(c.color_id));

            PART_MAP[partId].availableColorIds = colorIds;
            if (colorIds.length > 0 && (!state.modal.selectedColorId || !colorIds.includes(state.modal.selectedColorId))) {
                const sortedColorIds = sortColorIds(colorIds, partId);
                state.modal.selectedColorId = sortedColorIds[0];
            }
        } catch (error) {
            console.error(`Failed to fetch colors for ${partId}:`, error);
            if(!PART_MAP[partId]) PART_MAP[partId] = {};
            PART_MAP[partId].availableColorIds = PART_MAP[partId].availableColorIds || [];
        } finally {
            state.modal.isLoadingColors = false;
            updateModalPartially({ colors: true, controls: true });

            if (state.modal.selectedColorId) {
                fetchPartColorSpecifics(partId, state.modal.selectedColorId);
            }
        }
    }
    
    async function fetchPartColorSpecifics(partId, colorId) {
        state.modal.isImageLoading = true;
        updateModalPartially({ image: true });

        try {
            const url = `${REBRICKABLE_API_URL}/parts/${partId}/colors/${colorId}/`;
            const response = await fetch(url, { headers: { 'Authorization': `key ${REBRICKABLE_API_KEY}` } });
            if (!response.ok) throw new Error('Image not found for this color.');
            const data = await response.json();
            
            state.modal.partImageUrl = data.part_img_url || PART_MAP[partId]?.rebrickable_img_url;
        } catch (error) {
            console.warn(`Could not fetch color-specific image:`, error);
            state.modal.partImageUrl = PART_MAP[partId]?.rebrickable_img_url;
        } finally {
            state.modal.isImageLoading = false;
            updateModalPartially({ image: true });
        }
    }

    async function fetchColorDetailsForPart(partId) {
        if (PART_MAP[partId]?.colorImages) return;
    
        try {
            const colorAvailability = await apiFetchPaginated(`/parts/${partId}/colors/`);
            if (!PART_MAP[partId]) PART_MAP[partId] = { id: partId };
            
            const colorImages = {};
            colorAvailability.forEach(colorInfo => {
                if (colorInfo.part_img_url) {
                    colorImages[String(colorInfo.color_id)] = colorInfo.part_img_url;
                }
            });
            PART_MAP[partId].colorImages = colorImages;
    
        } catch (error) {
            console.warn(`Could not fetch color details for part ${partId}:`, error);
        }
    }
    
    async function fetchColorDetailsForCollectionParts() {
        const collectionPartIds = Object.keys(state.collection);
        const partsToFetch = collectionPartIds.filter(id => !PART_MAP[id]?.colorImages);
        
        if (partsToFetch.length === 0) return;
        console.log(`Fetching color-specific images for ${partsToFetch.length} parts from collection...`);
    
        const BATCH_SIZE = 20;
        for (let i = 0; i < partsToFetch.length; i += BATCH_SIZE) {
            const batch = partsToFetch.slice(i, i + BATCH_SIZE);
            const promises = batch.map(partId => fetchColorDetailsForPart(partId));
            await Promise.all(promises);
        }
    }

    async function fetchMissingCollectionPartDetails() {
      const collectionPartIds = Object.keys(state.collection);
      const missingPartIds = collectionPartIds.filter(id => !PART_MAP[id] || !PART_MAP[id].name);
      if (missingPartIds.length === 0) return;

      console.log(`Fetching details for ${missingPartIds.length} parts from collection...`);
      
      const BATCH_SIZE = 100;
      for (let i = 0; i < missingPartIds.length; i += BATCH_SIZE) {
          const batch = missingPartIds.slice(i, i + BATCH_SIZE);
          try {
            const rawParts = await apiFetchPaginated(`/parts/?part_nums=${batch.join(',')}`);
            rawParts.map(processPartData).filter(Boolean);
          } catch(err) {
            console.error(`Could not fetch details for batch starting with part ${batch[0]}:`, err);
            state.apiError = (state.apiError ? state.apiError + '\n' : '') + 'Не удалось загрузить данные для некоторых деталей коллекции.';
          }
      }
    }

    async function handleFeelingLucky() {
      state.isLoading = true;
      state.apiError = null;
      state.isGridStale = true;
      updateUI();
      try {
        if (flatCategories.length === 0) {
          throw new Error("Категории еще не загружены.");
        }
        const randomCategory = flatCategories[Math.floor(Math.random() * flatCategories.length)];
        
        const rawParts = await apiFetchPaginated(`/parts/?part_cat_id=${randomCategory.id}&page_size=100`);
        if (rawParts.length === 0) {
            handleFeelingLucky(); // Try again if category is empty
            return;
        }

        const parts = rawParts.map(processPartData).filter(Boolean);
        const randomPart = parts[Math.floor(Math.random() * parts.length)];

        if (!randomPart) {
          throw new Error("Не удалось выбрать случайную деталь.");
        }
        
        const groups = groupParts(parts);
        const groupId = getGroupId(randomPart.part_num);
        const variations = groups[groupId] || [randomPart];
        
        openModalForPart(randomPart.id, groupId, variations);

      } catch (error) {
        console.error("Feeling lucky failed:", error);
        state.apiError = `Не удалось совершить чудо: ${error.message}`;
      } finally {
        state.isLoading = false;
        updateUI();
      }
    }

    // --- UTILITY FUNCTIONS ---
    function getPartImageUrl(url) {
        const placeholderSvg = `data:image/svg+xml,${encodeURIComponent(ImageIcon('w-full h-full text-gray-500'))}`;
        if (url) {
            return `src="${url}" onerror="this.onerror=null; this.src='${placeholderSvg}';"`;
        }
        return `src="${placeholderSvg}"`;
    }

    function sortColorIds(colorIds, partId) {
        const BASIC_COLOR_IDS = ['0', '15', '4', '1', '14', '2', '71', '72', '88', '19', '5', '34']; // Black, White, Red, Blue, Yellow, Green, LBG, DBG, Reddish Brown, Tan, Orange, Lime
        
        const partCollectionColors = Object.keys(state.collection[partId] || {});

        return [...colorIds].sort((a, b) => {
            const aIsBasic = BASIC_COLOR_IDS.includes(a);
            const bIsBasic = BASIC_COLOR_IDS.includes(b);
            if (aIsBasic && !bIsBasic) return -1;
            if (!aIsBasic && bIsBasic) return 1;

            const aInCollection = partCollectionColors.includes(a);
            const bInCollection = partCollectionColors.includes(b);
            if (aInCollection && !bInCollection) return -1;
            if (!aInCollection && bInCollection) return 1;
            
            const colorA = COLOR_MAP[a];
            const colorB = COLOR_MAP[b];
            if (colorA && colorB) {
                return colorA.name.localeCompare(colorB.name);
            }

            return 0;
        });
    }

    function getPluralizedColorString(count) {
        const n = Math.abs(count);
        const lastDigit = n % 10;
        const lastTwoDigits = n % 100;

        if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
            return 'цветов';
        }
        if (lastDigit === 1) {
            return 'цвет';
        }
        if ([2, 3, 4].includes(lastDigit)) {
            return 'цвета';
        }
        return 'цветов';
    }

    // --- RENDER FUNCTIONS ---
    const CATEGORY_ICONS = {
        'Bricks': BrickIcon,
        'Plates': PlateIcon,
        'Technic': TechnicIcon,
        'Slopes & Wedges': SlopeIcon,
        'Tiles': TileIcon,
        'Panels, Doors & Windows': WindowIcon,
        'Wheels & Tyres': WheelIcon,
        'Minifig': MinifigIcon,
        'Bars, Hinges & Connectors': BarIcon,
        'Arches & Curves': ArchIcon,
        'Other': OtherIcon,
    };

    function renderSidebar() {
      const { uniqueModelsCount, totalPartsCount } = Object.keys(state.collection).reduce((acc, partId) => {
        const colors = state.collection[partId] || {};
        const colorKeys = Object.keys(colors);
        if (colorKeys.length > 0) {
            acc.uniqueModelsCount += colorKeys.length;
            acc.totalPartsCount += Object.values(colors).reduce((sum, q) => sum + q, 0);
        }
        return acc;
      }, { uniqueModelsCount: 0, totalPartsCount: 0 });

      const viewButtonStyle = (view) => `w-1/2 flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 ${state.currentView === view ? 'bg-blue-600 text-white' : 'text-gray-300 hover:bg-gray-700 hover:text-white'}`;
      
      let categoriesToRender = state.categoryTree;
      let allPartsButtonHtml = '';

      if (state.currentView === 'collection') {
          const isSelected = state.selectedCollectionCategoryId === null;
          const buttonStyle = isSelected ? 'bg-blue-600 text-white' : 'text-gray-300 hover:bg-gray-700 hover:text-white';
          allPartsButtonHtml = `
            <li>
              <button data-action="show-all-collection" class="w-full text-left flex items-center p-2 rounded-md transition-colors duration-150 ${buttonStyle}">
                <span class="truncate">Все детали</span>
              </button>
            </li>
          `;

          const collectionCategoryIds = new Set(
              Object.keys(state.collection)
                  .map(partId => PART_MAP[partId]?.categoryId)
                  .filter(id => id !== undefined && id !== null)
          );
          
          categoriesToRender = JSON.parse(JSON.stringify(state.categoryTree)); // Deep copy
          categoriesToRender = categoriesToRender.map(group => {
              group.children = group.children.filter(cat => collectionCategoryIds.has(cat.id));
              return group;
          }).filter(group => group.children.length > 0);
      }
      
      let categoryListContent = '';
      if (state.isLoading && state.categoryTree.length === 0) {
          categoryListContent = `<div class="flex items-center justify-center p-4"><div class="loader !w-6 !h-6"></div></div>`;
      } else if (state.currentView === 'catalog' && categoriesToRender.length === 0) {
          // No special message for catalog, as it's the default state before selection
      } else if (state.currentView === 'collection' && Object.keys(state.collection).length > 0 && categoriesToRender.length === 0) {
          categoryListContent = `<li class="text-gray-400 text-sm p-2">Нет деталей в категориях.</li>`;
      } else {
           categoryListContent = categoriesToRender.map(group => {
            const isExpanded = state.expandedCategories.has(group.name);
            const childList = group.children.map(cat => {
                 const isSelected = state.currentView === 'catalog' 
                    ? state.selectedCategoryId === cat.id
                    : state.selectedCollectionCategoryId === cat.id;
                 const buttonStyle = isSelected ? 'bg-blue-600/80 text-white' : 'text-gray-400 hover:bg-gray-700/50 hover:text-gray-200';
                 return `
                    <li>
                        <button data-category-id="${cat.id}" class="w-full text-left flex items-center p-2 pl-11 rounded-md transition-colors duration-150 ${buttonStyle}">
                          <span class="truncate">${cat.name}</span>
                        </button>
                    </li>
                 `;
            }).join('');
            
            const IconComponent = CATEGORY_ICONS[group.name] || OtherIcon;
            const iconHtml = IconComponent('w-5 h-5 mr-3 text-gray-400 flex-shrink-0');

            return `
                <li class="space-y-1">
                    <button data-parent-category="${group.name}" class="w-full text-left flex items-center justify-between p-2 rounded-md hover:bg-gray-700 transition-colors duration-150">
                        <div class="flex items-center truncate">
                          ${iconHtml}
                          <span class="font-semibold text-gray-200 truncate">${group.name}</span>
                        </div>
                        ${ChevronDownIcon(`w-5 h-5 text-gray-400 transform transition-transform duration-200 ${isExpanded ? 'rotate-180' : ''}`)}
                    </button>
                    <ul class="space-y-1 ${isExpanded ? '' : 'hidden'}">
                        ${childList}
                    </ul>
                </li>
            `;
          }).join('');
      }

      sidebarContainer.innerHTML = `
        <div class="flex items-center justify-between mb-4 flex-shrink-0">
          <h1 class="text-xl font-bold text-white">Меню</h1>
          <button id="sidebar-close" class="lg:hidden text-gray-400 hover:text-white p-1">
            ${XIcon('w-6 h-6')}
          </button>
        </div>

        <div class="flex bg-gray-900/70 rounded-lg p-1 mb-4 flex-shrink-0">
          <button data-view="catalog" class="${viewButtonStyle('catalog')}">${CatalogIcon('w-5 h-5 mr-2')} Каталог</button>
          <button data-view="collection" class="${viewButtonStyle('collection')}">${CollectionIcon('w-5 h-5 mr-2')} Коллекция</button>
        </div>
        
        <div class="flex-grow overflow-y-auto no-scrollbar">
          <h2 class="text-lg font-semibold text-white mb-3">Категории</h2>
          <nav>
            <ul id="category-list" class="space-y-1">${allPartsButtonHtml}${categoryListContent}</ul>
          </nav>
        </div>
        
        <div class="flex-shrink-0 mt-4 border-t border-gray-700 pt-4">
            <h2 class="text-lg font-semibold text-white mb-3">Сводка коллекции</h2>
            ${totalPartsCount === 0 ? '<p class="text-gray-400 text-sm">Ваша коллекция пуста.</p>' : `
              <div class="space-y-2 text-sm">
                  <div class="flex justify-between"><span class="text-gray-400">Уникальные модели:</span><span class="font-bold text-white">${uniqueModelsCount}</span></div>
                  <div class="flex justify-between"><span class="text-gray-400">Всего деталей:</span><span class="font-bold text-white">${totalPartsCount}</span></div>
              </div>
            `}
        </div>

        <div class="flex-shrink-0 mt-4 border-t border-gray-700 pt-4">
            <h2 class="text-lg font-semibold text-white mb-3">Управление данными</h2>
            <div class="space-y-2">
                <button id="import-button" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-600 hover:bg-gray-500 text-white">
                    ${UploadIcon('w-5 h-5 mr-2')} Импорт .zip
                </button>
                <input type="file" id="import-zip-input" class="hidden" accept=".zip">
                <button id="export-button" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-600 hover:bg-gray-500 text-white ${totalPartsCount === 0 ? 'opacity-50 cursor-not-allowed' : ''}" ${totalPartsCount === 0 ? 'disabled' : ''}>
                    ${DownloadIcon('w-5 h-5 mr-2')} Экспорт .zip
                </button>
            </div>
            ${state.importExportStatus.message ? `
              <div id="import-export-status" class="mt-3 p-2 text-sm rounded-md ${state.importExportStatus.type === 'error' ? 'bg-red-900/50 text-red-300' : 'bg-green-900/50 text-green-300'}">
                ${state.importExportStatus.message}
              </div>
            ` : ''}
        </div>
      `;
    }

    function renderHeader() {
        headerContainer.innerHTML = `
            <div class="flex justify-between items-center gap-4">
                <div class="flex items-center">
                    <button id="sidebar-toggle" class="lg:hidden text-gray-300 hover:text-white mr-4 -ml-1 p-1">
                        ${MenuIcon('w-6 h-6')}
                    </button>
                    <h1 class="text-xl font-bold text-white hidden sm:block">LEGO® Part Catalog</h1>
                </div>
                <div class="flex items-center space-x-2 w-full max-w-sm">
                    <div class="relative flex-grow">
                        <input id="search-input" type="search" placeholder="Поиск по ID или названию..." value="${state.searchQuery}" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 pl-4 pr-10 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"/>
                        <button id="clear-search" class="absolute inset-y-0 right-0 flex items-center pr-3 text-gray-400 hover:text-white ${!state.searchQuery ? 'hidden' : ''}">${XIcon('w-5 h-5')}</button>
                    </div>
                     <button id="search-button" class="p-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors flex-shrink-0" aria-label="Поиск">
                        ${SearchIcon('w-5 h-5')}
                    </button>
                    <button id="filter-button" class="p-2 bg-gray-600 text-white rounded-md hover:bg-gray-500 transition-colors flex-shrink-0" aria-label="Фильтры">
                        ${FilterIcon('w-5 h-5')}
                    </button>
                </div>
            </div>
        `;
    }

    function renderPartCard(part, color, quantity, shouldAnimate, index = 0) {
        const inCollection = state.currentView === 'collection';
        const groupId = getGroupId(part.id);
        const animationClass = shouldAnimate ? 'animate-in' : '';
        const animationDelay = shouldAnimate ? `animation-delay: ${Math.min(index * 40, 1500)}ms;` : '';
        
        let quantityIndicator = '';
        if (quantity > 0) {
            const positionClass = inCollection ? 'left-3' : 'right-3';
            quantityIndicator = `<div class="absolute top-3 ${positionClass} bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md">${quantity}</div>`;
        }
        
        let imageUrl = part.rebrickable_img_url;
        if (inCollection && color) {
            const colorSpecificUrl = PART_MAP[part.id]?.colorImages?.[color.id];
            if (colorSpecificUrl) {
                imageUrl = colorSpecificUrl;
            }
        }

        return `
            <div data-group-id="${groupId}" data-part-id="${part.id}" ${inCollection ? `data-color-id="${color.id}"` : ''} style="${animationDelay}" class="part-card ${animationClass} relative bg-gray-800 rounded-lg overflow-hidden group transform transition-all duration-300 hover:bg-gray-700 cursor-pointer hover:scale-105">
                ${inCollection ? `
                    <button aria-label="Удалить ${part.name} (${color.name})" data-action="delete-from-collection" data-part-id="${part.id}" data-color-id="${color.id}" class="absolute top-3 right-3 bg-red-600 text-white p-1.5 rounded-full z-10 shadow-md transition-colors hover:bg-red-700 opacity-100 focus:opacity-100 md:opacity-0 md:group-hover:opacity-100">
                        ${TrashIcon('w-4 h-4')}
                    </button>
                ` : ''}
                ${quantityIndicator}
                <div class="w-full h-40 bg-gray-700 flex items-center justify-center p-2 rounded-t-lg">
                    <div class="w-full h-full bg-white rounded-md flex items-center justify-center overflow-hidden shadow-inner">
                        <img ${getPartImageUrl(imageUrl)} alt="${part.name}" class="w-full h-full object-contain pointer-events-none" loading="lazy" />
                    </div>
                </div>
                <div class="p-4 space-y-1">
                    <h3 class="text-sm font-semibold text-white truncate pointer-events-none">${part.name}</h3>
                    <p class="text-xs text-gray-400 pointer-events-none">ID: ${part.id}</p>
                    ${inCollection ? `
                        <div class="flex items-center pt-1 pointer-events-none">
                            <span class="w-4 h-4 rounded-full border border-gray-500 ${color.isTransparent ? 'checkerboard' : ''}" style="background-color: ${color.hex};"></span>
                            <span class="ml-2 text-xs text-gray-300 truncate">${color.name}</span>
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
    }

    function renderAppliedFilters() {
        const { colorIds, inCollectionOnly } = state.filters;
        const { sortBy } = state;

        const isDefaultSort = state.searchQuery ? sortBy === 'relevance' : sortBy === 'popularity';
        if ((!colorIds || colorIds.length === 0) && !inCollectionOnly && isDefaultSort) {
            return '';
        }

        const colorTags = colorIds.map(colorId => {
            if (!COLOR_MAP[colorId]) return '';
            return `
            <div class="flex items-center bg-blue-900/50 text-blue-200 rounded-full pl-3 pr-2 py-1 text-sm">
                <span class="mr-2">${COLOR_MAP[colorId].name}</span>
                <button data-action="remove-filter" data-filter-type="color" data-color-id="${colorId}" class="text-blue-200 hover:bg-blue-500/50 rounded-full p-0.5">${XIcon('w-4 h-4')}</button>
            </div>
            `;
        }).join('');

        const collectionTag = inCollectionOnly && state.currentView === 'catalog' ? `
            <div class="flex items-center bg-green-900/50 text-green-200 rounded-full pl-3 pr-2 py-1 text-sm">
                <span class="mr-2">В коллекции</span>
                <button data-action="remove-filter" data-filter-type="inCollectionOnly" class="text-green-200 hover:bg-green-500/50 rounded-full p-0.5">${XIcon('w-4 h-4')}</button>
            </div>
        ` : '';

        const sortMap = {
            'relevance': 'Релевантность',
            'alpha_asc': 'Алфавит (А-Я)',
            'alpha_desc': 'Алфавит (Я-А)',
            'popularity': 'Популярность'
        };

        const sortTag = !isDefaultSort ? `
            <div class="flex items-center bg-gray-600 text-gray-200 rounded-full pl-3 pr-2 py-1 text-sm">
                <span class="mr-2">Сортировка: ${sortMap[sortBy]}</span>
                <button data-action="remove-filter" data-filter-type="sortBy" class="text-gray-200 hover:bg-gray-500/50 rounded-full p-0.5">${XIcon('w-4 h-4')}</button>
            </div>
        ` : '';
        
        const tags = [sortTag, colorTags, collectionTag].filter(Boolean).join('');

        if (!tags) return '';

        return `
            <div class="px-4 pt-2 pb-0">
                <div class="flex items-center flex-wrap gap-2">
                    ${tags}
                    <button data-action="remove-all-filters" class="text-sm text-blue-400 hover:underline">Очистить все</button>
                </div>
            </div>
        `;
    }

    function renderMainContent() {
        let gridContent = '';
        
        if (state.isLoading) {
            gridContent = `<div class="flex flex-col items-center justify-center h-full p-8 text-center"><div class="loader"></div><p class="mt-4 text-gray-400">Загрузка...</p></div>`;
        } else if (state.apiError) {
            gridContent = `<div class="flex flex-col items-center justify-center h-full p-8 text-center text-red-400"><p class="font-semibold">Произошла ошибка</p><p class="text-sm mt-2">${state.apiError}</p></div>`;
        } else if (state.currentView === 'collection') {
            let items = [];
            for (const partId in state.collection) {
              for (const colorId in state.collection[partId]) {
                const part = PART_MAP[partId];
                const color = COLOR_MAP[colorId];
                const quantity = state.collection[partId][colorId];
                if (part && color && quantity > 0) {
                  items.push({ part, color, quantity });
                }
              }
            }
            
            // Apply client-side filters for collection view
            if (state.selectedCollectionCategoryId) {
                items = items.filter(({ part }) => PART_MAP[part.id]?.categoryId === state.selectedCollectionCategoryId);
            }
            if (state.filters.colorIds && state.filters.colorIds.length > 0) {
                items = items.filter(item => state.filters.colorIds.includes(item.color.id));
            }

            const query = state.searchQuery.trim().toLowerCase();
            if (query) {
                const getClientRelevanceScore = (item, q) => {
                    const lowerName = item.part.name.toLowerCase();
                    const partId = item.part.id.toLowerCase();
                    if (partId === q) return 100;
                    if (lowerName === q) return 90;
                    if (partId.startsWith(q)) return 80;
                    if (lowerName.startsWith(q)) return 70;
                    if (partId.includes(q)) return 60;
                    if (lowerName.includes(q)) return 50;
                    return 0;
                };

                items = items
                    .map(item => ({ item, score: getClientRelevanceScore(item, query) }))
                    .filter(i => i.score > 0)
                    .sort((a, b) => b.score - a.score)
                    .map(i => i.item);
            }

            // Apply sorting for collection view
            switch(state.sortBy) {
                case 'alpha_asc': items.sort((a, b) => a.part.name.localeCompare(b.part.name)); break;
                case 'alpha_desc': items.sort((a, b) => b.part.name.localeCompare(a.part.name)); break;
                case 'popularity': items.sort((a, b) => (PART_MAP[b.part.id]?.num_sets || 0) - (PART_MAP[a.part.id]?.num_sets || 0)); break;
            }

            if (items.length === 0) {
                let emptyMsg = 'В вашей коллекции нет деталей';
                if (state.searchQuery || (state.filters.colorIds && state.filters.colorIds.length > 0) || state.selectedCollectionCategoryId) emptyMsg += ', соответствующих фильтрам';
                emptyMsg += '.';
                gridContent = `<div class="flex items-center justify-center h-full p-4 text-center"><p class="text-gray-400">${emptyMsg}</p></div>`;
            } else {
                gridContent = `<div class="grid grid-cols-[repeat(auto-fill,minmax(130px,1fr))] gap-4 p-4">
                    ${items.map((item, index) => renderPartCard(item.part, item.color, item.quantity, state.isGridStale, index)).join('')}
                </div>`;
            }

        } else { // Catalog view
            let groupsToShow = {};
            let emptyMessage = 'Выберите категорию, чтобы увидеть детали, или воспользуйтесь поиском.';

            if (state.filters.colorIds && state.filters.colorIds.length > 1) {
                groupsToShow = {};
                emptyMessage = 'Фильтрация по нескольким цветам в режиме "Каталог" не поддерживается. Пожалуйста, выберите один цвет или просмотрите свою "Коллекцию".';
            } else if (state.searchResultGroups !== null) {
                groupsToShow = state.searchResultGroups;
                emptyMessage = 'По вашему запросу ничего не найдено.';
            } else if (state.selectedCategoryId !== null) {
                groupsToShow = state.catalogGroups;
                emptyMessage = 'В этой категории нет деталей.';
            }
            
            let allItems = Object.values(groupsToShow).flat();
            
            // Apply sorting for catalog view
            switch(state.sortBy) {
                case 'alpha_asc': allItems.sort((a, b) => a.name.localeCompare(b.name)); break;
                case 'alpha_desc': allItems.sort((a, b) => b.name.localeCompare(a.name)); break;
                case 'popularity': allItems.sort((a, b) => b.num_sets - a.num_sets); break;
            }
            groupsToShow = groupParts(allItems);

            const groupKeys = groupsToShow ? Object.keys(groupsToShow) : [];

            if (groupKeys.length === 0) {
                gridContent = `
                    <div class="flex flex-col items-center justify-center h-full p-4 text-center">
                        <p class="text-gray-400 max-w-sm mb-6">${emptyMessage}</p>
                        <button id="feeling-lucky-button" class="flex items-center gap-3 bg-blue-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-blue-700 transition-all duration-200 transform hover:scale-105 shadow-lg">
                            ${DiceIcon('w-6 h-6')} Мне повезёт!
                        </button>
                    </div>`;
            } else {
                const groupsToRender = groupKeys.slice(0, state.itemsToDisplay);

                gridContent = `<div class="grid grid-cols-[repeat(auto-fill,minmax(130px,1fr))] gap-4 p-4">
                    ${groupsToRender.map((key, index) => {
                        const representativePart = groupsToShow[key][0];
                        const totalQuantity = Object.values(state.collection[representativePart.id] || {}).reduce((sum, q) => sum + q, 0);
                        return renderPartCard(representativePart, null, totalQuantity, state.isGridStale, index);
                    }).join('')}
                </div>`;
                
                if (groupKeys.length > state.itemsToDisplay) {
                    gridContent += `
                        <div class="p-4 text-center">
                            <button id="load-more-button" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 transition-colors">
                                Загрузить ещё
                            </button>
                        </div>
                    `;
                }
            }
        }
        mainContent.innerHTML = renderAppliedFilters() + gridContent;
        state.isGridStale = false; // Animation flag is reset after render
    }

    function renderModal() {
        if (!state.selectedPartId) {
            if (!modalContainer.classList.contains('modal-hidden')) {
                closeModal();
            }
            return;
        }

        const part = PART_MAP[state.selectedPartId];
        if (!part) {
            closeModal();
            return;
        }
        
        const animationClass = 'modal-content-enter';
        const categoryName = flatCategories.find(c => c.id === part.categoryId)?.name;
        const { partVariations, partImageUrl } = state.modal;
        
        let variationSelector = '';
        if (partVariations && partVariations.length > 1) {
            variationSelector = `
                <div>
                    <label for="variation-select" class="block text-sm font-medium text-gray-400 mb-2">Вариация</label>
                    <select id="variation-select" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                        ${partVariations.map(variation => `
                            <option value="${variation.id}" ${variation.id === state.selectedPartId ? 'selected' : ''}>
                                ${variation.name}
                            </option>
                        `).join('')}
                    </select>
                </div>
            `;
        }

        document.body.classList.add('overflow-hidden');
        modalContainer.classList.remove('modal-hidden');
        requestAnimationFrame(() => {
            modalContainer.classList.add('visible');
        });
        
        modalContainer.innerHTML = `
        <div id="modal-content" class="bg-gray-800 rounded-lg shadow-xl w-[calc(100%-2rem)] max-w-lg lg:max-w-4xl flex flex-col max-h-[calc(100vh-2rem)] ${animationClass}">
            
            <div class="flex-shrink-0 p-4 border-b border-gray-700 flex justify-between items-center">
                 <h2 class="text-xl lg:text-2xl font-bold text-white lg:truncate pr-8">${part.name}</h2>
                 <button id="modal-close" class="text-gray-400 hover:text-white transition-colors">${XIcon('w-6 h-6')}</button>
            </div>
            
            <div id="modal-scroll-area" class="flex-grow flex flex-col lg:flex-row overflow-y-auto no-scrollbar">
                <div class="lg:w-1/2 p-4 sm:p-6 bg-gray-900/30 flex items-center justify-center flex-shrink-0 border-b lg:border-b-0 lg:border-r border-gray-700">
                     <div id="modal-image-container" class="w-48 h-48 sm:w-64 sm:h-64 bg-white rounded-lg flex items-center justify-center overflow-hidden shadow-lg relative">
                        <img ${getPartImageUrl(partImageUrl)} alt="${part.name}" class="max-w-full max-h-full object-contain">
                     </div>
                </div>
                
                <div class="lg:w-1/2 p-4 sm:p-6 flex flex-col">
                    <div class="space-y-6">
                        <div>
                            <p class="text-sm text-gray-400">ID: ${part.id}</p>
                            ${categoryName ? `
                                <div class="text-sm text-gray-400 flex items-center mt-1">
                                    <span class="mr-1">Категория:</span>
                                    <button data-action="go-to-category" data-category-id="${part.categoryId}" class="text-blue-400 hover:text-blue-300 hover:underline text-left truncate">
                                        ${categoryName}
                                    </button>
                                </div>
                            ` : ''}
                            ${variationSelector ? `<div class="mt-4">${variationSelector}</div>` : ''}
                        </div>
                        
                        <div>
                          <h3 class="text-md font-semibold text-gray-300 mb-3">Доступные цвета</h3>
                           <div id="color-selector-container">${renderColorSelector()}</div>
                        </div>
                        
                        <div id="modal-controls-container">${renderModalControls()}</div>
                    </div>
                </div>
            </div>
        </div>
        `;

        updateModalPartially({ image: true });
    }
    
    function renderColorSelector() {
        if (!state.selectedPartId) return '';

        const part = PART_MAP[state.selectedPartId];
        if (!part) return '';

        const { areColorsExpanded, selectedColorId, isLoadingColors } = state.modal;
        const availableColorIds = part.availableColorIds || [];

        if (isLoadingColors) {
            return `<div class="flex items-center justify-center h-24"><div class="loader !w-8 !h-8"></div></div>`;
        }
        if (availableColorIds.length === 0) {
            return `<p class="text-sm text-gray-400 text-center py-4">Нет информации о доступных цветах.</p>`;
        }
        
        const isExpandable = availableColorIds.length > COLOR_COLLAPSE_THRESHOLD;
        const sortedColorIds = sortColorIds(availableColorIds, part.id);
        
        const allColorButtonsHtml = sortedColorIds.map(cid => {
            const color = COLOR_MAP[cid];
            if (!color) return '';
            const isInCollection = state.collection[part.id] && state.collection[part.id][cid] > 0;
            return `
                <button data-color-id="${cid}" title="${color.name}" class="w-10 h-10 rounded-full border-2 transition-transform duration-150 overflow-hidden flex-shrink-0 flex items-center justify-center ${color.isTransparent ? 'checkerboard' : ''} ${selectedColorId === cid ? 'border-blue-500 scale-110' : 'border-gray-600 hover:border-gray-400'}" style="background-color: ${color.hex};">
                    ${isInCollection ? '<div class="w-2 h-2 bg-white rounded-full"></div>' : ''}
                </button>
            `;
        }).join('');
        
        let expandCollapseButton = '';
        if (isExpandable) {
            if (!areColorsExpanded) {
                const remainingCount = sortedColorIds.length - COLOR_COLLAPSE_THRESHOLD;
                const pluralizedString = getPluralizedColorString(remainingCount);
                expandCollapseButton = `
                    <button data-action="expand-colors" class="text-blue-400 hover:text-blue-300 hover:underline text-sm font-semibold">
                        Показать ещё ${remainingCount} ${pluralizedString}
                    </button>
                `;
            } else {
                expandCollapseButton = `
                    <button data-action="collapse-colors" class="text-blue-400 hover:text-blue-300 hover:underline text-sm font-semibold">
                        Свернуть
                    </button>
                `;
            }
        }
        
        const collapsedHeight = '150px'; 
        const wrapperStyle = isExpandable && !areColorsExpanded ? `max-height: ${collapsedHeight};` : '';

        return `
            <div id="color-selector-wrapper" style="${wrapperStyle}">
                <div class="grid grid-cols-[repeat(auto-fill,minmax(48px,1fr))] gap-x-2 gap-y-4 p-2">
                    ${allColorButtonsHtml}
                </div>
            </div>
            <div id="expand-collapse-container" class="text-center mt-2">
                ${expandCollapseButton}
            </div>
        `;
    }

    function renderModalControls() {
        const { selectedColorId, quantity } = state.modal;
        const selectedColor = selectedColorId ? COLOR_MAP[selectedColorId] : null;

        if (!selectedColor || !state.selectedPartId) return '';

        const currentInCollection = (state.collection[state.selectedPartId]?.[selectedColorId]) || 0;

        return `
            <div class="bg-gray-700/50 rounded-lg p-4">
                <div class="space-y-4">
                    <div class="flex justify-between items-center">
                        <p class="text-white font-semibold truncate" title="${selectedColor.name}">${selectedColor.name}</p>
                        <p class="text-sm text-gray-400 text-right">В коллекции: <span id="modal-in-collection-qty" class="font-bold text-white">${currentInCollection}</span></p>
                    </div>
                    
                    <div class="flex justify-between items-center gap-4">
                        <div class="flex items-center gap-2">
                            <button data-action="decrease-qty" class="p-2 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors">${MinusIcon('w-5 h-5')}</button>
                            <input id="modal-quantity-input" type="number" value="${quantity}" readonly class="w-12 text-center bg-gray-900 text-white font-bold rounded-md py-1"/>
                            <button data-action="increase-qty" class="p-2 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors">${PlusIcon('w-5 h-5')}</button>
                        </div>
                        <button id="modal-update-collection-btn" data-action="update-collection" class="flex-grow bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors">
                            ${currentInCollection > 0 ? 'Обновить' : 'Добавить'}
                        </button>
                    </div>
                    ${currentInCollection > 0 ? `
                        <div id="modal-delete-container">
                            <button data-action="delete-from-collection-modal" class="w-full mt-1 text-sm text-red-400 hover:text-red-300 hover:bg-red-900/50 rounded-md py-1.5 transition-colors">Удалить из коллекции</button>
                        </div>
                    ` : '<div id="modal-delete-container"></div>'}
                </div>
            </div>
        `;
    }

    function renderFilterModal() {
        if (!state.isFilterModalOpen) {
            closeFilterModal();
            return;
        }
        
        // Sort options
        const sortOptions = [
            { id: 'relevance', name: 'Релевантность', desc: 'Поиск' },
            { id: 'popularity', name: 'Популярность', desc: 'Каталог' },
            { id: 'alpha_asc', name: 'Алфавит (А-Я)', desc: '' },
            { id: 'alpha_desc', name: 'Алфавит (Я-А)', desc: '' },
        ];
        const sortRadios = sortOptions.map(opt => {
            const isChecked = tempFilters.sortBy === opt.id;
            const isDisabled = (opt.id === 'relevance' && !state.searchQuery) || (opt.id === 'popularity' && state.searchQuery);
            const defaultBadge = (state.searchQuery && opt.id === 'relevance') || (!state.searchQuery && opt.id === 'popularity') ? '<span class="ml-2 text-xs bg-blue-600/50 text-blue-300 px-1.5 py-0.5 rounded-full">По умолч.</span>' : '';
            return `
                <label class="flex items-center p-3 rounded-lg hover:bg-gray-700/50 transition-colors cursor-pointer ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}">
                    <input type="radio" name="sort" value="${opt.id}" class="h-4 w-4 text-blue-600 bg-gray-700 border-gray-500 focus:ring-blue-500" ${isChecked ? 'checked' : ''} ${isDisabled ? 'disabled' : ''} data-action="modal-set-sort">
                    <span class="ml-3 text-white">${opt.name}</span>
                    ${defaultBadge}
                </label>
            `;
        }).join('');

        // Collection toggle
        const collectionToggle = state.currentView === 'catalog' ? `
            <div>
                <h3 class="text-md font-semibold text-gray-300 mb-2">Фильтры</h3>
                <div class="bg-gray-900/50 rounded-lg p-2">
                    <label class="flex justify-between items-center p-2 cursor-pointer">
                        <span class="text-white">Только детали в коллекции</span>
                        <div class="relative">
                            <input type="checkbox" class="sr-only peer" ${tempFilters.filters.inCollectionOnly ? 'checked' : ''} data-action="modal-toggle-collection">
                            <div class="w-11 h-6 bg-gray-600 rounded-full peer peer-focus:ring-2 peer-focus:ring-blue-500 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                        </div>
                    </label>
                </div>
            </div>
        ` : '';

        // Color palette
        const sortedColorIds = Object.keys(COLOR_MAP).sort((a,b) => COLOR_MAP[a].name.localeCompare(COLOR_MAP[b].name));
        const colorButtons = sortedColorIds.map(cid => {
            const color = COLOR_MAP[cid];
            const isSelected = tempFilters.filters.colorIds.includes(cid);
            return `
                <button data-action="modal-set-color" data-color-id="${cid}" title="${color.name}" class="w-8 h-8 rounded-full border-2 transition-transform duration-150 overflow-hidden flex-shrink-0 ${color.isTransparent ? 'checkerboard' : ''} ${isSelected ? 'border-blue-500 scale-110' : 'border-gray-600 hover:border-gray-400'}" style="background-color: ${color.hex};"></button>
            `;
        }).join('');

        const animationClass = 'modal-content-enter';
        document.body.classList.add('overflow-hidden');
        filterModalContainer.classList.remove('modal-hidden');
        requestAnimationFrame(() => {
            filterModalContainer.classList.add('visible');
        });
        
        filterModalContainer.innerHTML = `
            <div id="filter-modal-content" class="bg-gray-800 rounded-lg shadow-xl w-[calc(100%-2rem)] max-w-md flex flex-col max-h-[calc(100vh-2rem)] ${animationClass}">
                <div class="flex-shrink-0 p-4 border-b border-gray-700 flex justify-between items-center">
                     <h2 class="text-xl font-bold text-white">Фильтры и сортировка</h2>
                     <button id="filter-modal-close" class="text-gray-400 hover:text-white transition-colors">${XIcon('w-6 h-6')}</button>
                </div>
                <div class="flex-grow p-4 overflow-y-auto no-scrollbar space-y-6">
                    <div>
                        <h3 class="text-md font-semibold text-gray-300 mb-2">Сортировать по</h3>
                        <div class="bg-gray-900/50 rounded-lg space-y-1 p-2">${sortRadios}</div>
                    </div>
                    ${collectionToggle}
                    <div>
                         <h3 class="text-md font-semibold text-gray-300 mb-2">Фильтр по цвету</h3>
                         <div class="bg-gray-900/50 rounded-lg p-3">
                            <button data-action="modal-set-color" data-color-id="null" class="w-full mb-3 py-2 text-sm rounded-md transition-colors ${tempFilters.filters.colorIds.length === 0 ? 'bg-blue-600 text-white font-semibold' : 'bg-gray-600 hover:bg-gray-500 text-gray-200'}">Все цвета</button>
                            <div class="relative">
                                <div class="max-h-48 overflow-y-auto no-scrollbar pr-2">
                                    <div class="grid grid-cols-[repeat(auto-fill,minmax(36px,1fr))] gap-3">
                                        ${colorButtons}
                                    </div>
                                </div>
                                <div class="absolute bottom-0 left-0 right-0 h-6 bg-gradient-to-t from-gray-900 to-transparent pointer-events-none"></div>
                            </div>
                         </div>
                    </div>
                </div>
                <div class="flex-shrink-0 p-4 border-t border-gray-700 flex justify-between items-center gap-4">
                    <button data-action="modal-reset-filters" class="px-4 py-2 text-sm font-semibold rounded-md transition-colors bg-gray-600 hover:bg-gray-500 text-white">Сбросить</button>
                    <button data-action="modal-apply-filters" class="flex-grow px-4 py-2 text-sm font-semibold rounded-md transition-colors bg-blue-600 hover:bg-blue-700 text-white">Применить</button>
                </div>
            </div>
        `;
    }

    function updateFilterModalUI() {
        if (!state.isFilterModalOpen || !filterModalContainer.innerHTML) return;

        // Update Sort Radios
        const sortRadios = filterModalContainer.querySelectorAll('input[name="sort"]');
        sortRadios.forEach(radio => {
            radio.checked = tempFilters.sortBy === radio.value;
        });
        
        // Update Collection Toggle
        const collectionToggle = filterModalContainer.querySelector('input[data-action="modal-toggle-collection"]');
        if (collectionToggle) {
            collectionToggle.checked = tempFilters.filters.inCollectionOnly;
        }

        // Update "All Colors" button
        const allColorsButton = filterModalContainer.querySelector('button[data-color-id="null"]');
        if (allColorsButton) {
            const isActive = tempFilters.filters.colorIds.length === 0;
            allColorsButton.className = `w-full mb-3 py-2 text-sm rounded-md transition-colors ${isActive ? 'bg-blue-600 text-white font-semibold' : 'bg-gray-600 hover:bg-gray-500 text-gray-200'}`;
        }

        // Update Color Palette buttons
        const colorButtons = filterModalContainer.querySelectorAll('button[data-action="modal-set-color"]');
        colorButtons.forEach(button => {
            const colorId = button.dataset.colorId;
            if (colorId && colorId !== 'null') {
                const isSelected = tempFilters.filters.colorIds.includes(colorId);
                const color = COLOR_MAP[colorId];
                if (color) {
                    button.className = `w-8 h-8 rounded-full border-2 transition-transform duration-150 overflow-hidden flex-shrink-0 ${color.isTransparent ? 'checkerboard' : ''} ${isSelected ? 'border-blue-500 scale-110' : 'border-gray-600 hover:border-gray-400'}`;
                }
            }
        });
    }

    function updateModalPartially(updates) {
        if (!state.selectedPartId) return;

        if (updates.image) {
            const imageContainer = document.getElementById('modal-image-container');
            if (imageContainer) {
                const { partImageUrl, isImageLoading } = state.modal;
                const part = PART_MAP[state.selectedPartId];
                imageContainer.innerHTML = `
                    ${isImageLoading ? `<div class="absolute inset-0 bg-gray-900/80 flex items-center justify-center z-10"><div class="loader !w-10 !h-10"></div></div>` : ''}
                    <img ${getPartImageUrl(partImageUrl)} alt="${part.name}" class="max-w-full max-h-full object-contain">
                `;
            }
        }
        if (updates.colors) {
            const colorContainer = document.getElementById('color-selector-container');
            if (colorContainer) {
                colorContainer.innerHTML = renderColorSelector();
            }
        }
        if (updates.controls) {
            const controlsContainer = document.getElementById('modal-controls-container');
            if (controlsContainer) {
                controlsContainer.innerHTML = renderModalControls();
            }
        }
    }
    
    function updateModalControlsState() {
        if (!state.selectedPartId || !state.modal.selectedColorId) return;

        const currentInCollection = (state.collection[state.selectedPartId]?.[state.modal.selectedColorId]) || 0;
        
        const inCollectionQtySpan = document.getElementById('modal-in-collection-qty');
        if (inCollectionQtySpan) inCollectionQtySpan.textContent = currentInCollection;
        
        const updateBtn = document.getElementById('modal-update-collection-btn');
        if (updateBtn) updateBtn.textContent = currentInCollection > 0 ? 'Обновить' : 'Добавить';
        
        const deleteContainer = document.getElementById('modal-delete-container');
        if (deleteContainer) {
            if (currentInCollection > 0 && !deleteContainer.innerHTML.trim()) {
                deleteContainer.innerHTML = `<button data-action="delete-from-collection-modal" class="w-full mt-1 text-sm text-red-400 hover:text-red-300 hover:bg-red-900/50 rounded-md py-1.5 transition-colors">Удалить из коллекции</button>`;
            } else if (currentInCollection === 0) {
                deleteContainer.innerHTML = '';
            }
        }

        const qtyInput = document.getElementById('modal-quantity-input');
        if(qtyInput) qtyInput.value = state.modal.quantity;
    }


    function updateUI() {
        renderSidebar();
        renderHeader();
        renderMainContent();
        
        const isMobile = window.innerWidth < 1024;
        if (isMobile) {
            if (state.isSidebarOpen) {
                sidebarContainer.classList.remove('-translate-x-full');
                sidebarBackdrop.classList.remove('hidden');
                document.body.style.overflow = 'hidden';
            } else {
                sidebarContainer.classList.add('-translate-x-full');
                sidebarBackdrop.classList.add('hidden');
                document.body.style.overflow = '';
            }
        } else {
            sidebarContainer.classList.remove('-translate-x-full');
            sidebarBackdrop.classList.add('hidden');
            document.body.style.overflow = '';
        }
    }

    // --- IMPORT/EXPORT HANDLING ---
    async function handleZipImport(event) {
        const file = event.target.files[0];
        if (!file) return;

        state.importExportStatus = { message: 'Обработка файла...', type: 'success' };
        updateUI();

        try {
            const jszip = new JSZip();
            const zip = await jszip.loadAsync(file);
            const collectionFile = zip.file('collection.json');

            if (!collectionFile) throw new Error("Файл 'collection.json' не найден.");
            
            const content = await collectionFile.async('string');
            const importedCollection = JSON.parse(content);

            let mergedCount = 0;
            for (const partId in importedCollection) {
                if (!state.collection[partId]) state.collection[partId] = {};
                for (const colorId in importedCollection[partId]) {
                    const quantity = importedCollection[partId][colorId];
                    if (typeof quantity === 'number' && quantity > 0) {
                        state.collection[partId][colorId] = (state.collection[partId][colorId] || 0) + quantity;
                        mergedCount++;
                    }
                }
            }
            
            saveState();
            state.importExportStatus = { message: `Импорт успешен! Добавлено ${mergedCount} записей.`, type: 'success' };
            await fetchMissingCollectionPartDetails();
            await fetchColorDetailsForCollectionParts();
        } catch (error) {
            console.error("Import failed:", error);
            state.importExportStatus = { message: `Ошибка импорта: ${error.message}`, type: 'error' };
        } finally {
            event.target.value = '';
            state.isGridStale = true;
            updateUI();
        }
    }

    async function handleExportCollection() {
        state.importExportStatus = { message: '', type: '' };
        if (Object.keys(state.collection).length === 0) {
            state.importExportStatus = { message: 'Коллекция пуста для экспорта.', type: 'error' };
            updateUI();
            return;
        }

        try {
            const jszip = new JSZip();
            jszip.file("collection.json", JSON.stringify(state.collection, null, 2));
            const blob = await jszip.generateAsync({ type: "blob" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = `lego-collection-${new Date().toISOString().slice(0,10)}.zip`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            state.importExportStatus = { message: 'Экспорт начался.', type: 'success' };
        } catch (error) {
            console.error("Export failed:", error);
            state.importExportStatus = { message: `Ошибка экспорта: ${error.message}`, type: 'error' };
        }
        updateUI();
    }

    // --- EVENT HANDLING ---
    async function handleUpdateCollection(partId, colorId, quantity) {
        if (!state.collection[partId]) state.collection[partId] = {};
        
        if (quantity > 0) {
            state.collection[partId][colorId] = quantity;
        } else {
            delete state.collection[partId][colorId];
            if (Object.keys(state.collection[partId]).length === 0) {
                delete state.collection[partId];
            }
        }

        if (quantity > 0 && !PART_MAP[partId]?.colorImages) {
            await fetchColorDetailsForPart(partId);
        }
        
        state.importExportStatus = { message: '', type: '' };
        saveState();
        
        state.isGridStale = false;
        
        if(state.currentView === 'collection') {
            updateUI(); // In collection view, a full but non-animated re-render is cleanest
        } else {
            // In catalog view, perform targeted updates for performance
            renderSidebar();
            const card = mainContent.querySelector(`.part-card[data-part-id="${partId}"]`);
            if(card) {
                const totalQuantity = Object.values(state.collection[partId] || {}).reduce((sum, q) => sum + q, 0);
                let indicator = card.querySelector('.absolute.top-3.right-3');
                if(totalQuantity > 0) {
                    if(!indicator) {
                        indicator = document.createElement('div');
                        indicator.className = `absolute top-3 right-3 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md`;
                        card.prepend(indicator);
                    }
                    indicator.textContent = totalQuantity;
                } else {
                    indicator?.remove();
                }
            }
        }
        
        if (state.selectedPartId === partId) {
            updateModalControlsState();
            const colorButton = modalContainer.querySelector(`button[data-color-id="${colorId}"]`);
            if (colorButton) {
                const dot = colorButton.querySelector('.w-2.h-2');
                if (quantity > 0 && !dot) {
                    const newDot = document.createElement('div');
                    newDot.className = 'w-2 h-2 bg-white rounded-full';
                    colorButton.appendChild(newDot);
                } else if (quantity === 0 && dot) {
                    dot.remove();
                }
            }
        }
    }
    
    function clearStatusOnClick() {
        if(state.importExportStatus.message) {
            state.importExportStatus = { message: '', type: '' };
            renderSidebar();
        }
    }

    function triggerSearch(useCurrentFilters = false) {
        clearStatusOnClick();
        if (!useCurrentFilters) {
             state.sortBy = state.searchQuery ? 'relevance' : 'popularity';
             state.filters.colorIds = [];
             state.filters.inCollectionOnly = false;
        }
        const query = state.searchQuery.trim();

        if (state.currentView === 'collection') {
            state.selectedCollectionCategoryId = null;
            state.isGridStale = true;
            updateUI();
        } else {
            searchRebrickableParts(query);
        }
    }
    
    function closeModal() {
        const modalContent = document.getElementById('modal-content');
        if (!modalContent || modalContainer.classList.contains('modal-hidden')) {
            return; 
        }
        
        modalContainer.classList.remove('visible');
        modalContent.classList.add('modal-content-leave');
        document.body.classList.remove('overflow-hidden');
        
        modalContent.addEventListener('animationend', () => {
            if (modalContent.classList.contains('modal-content-leave')) {
                state.selectedPartId = null;
                state.modal = {
                    partGroupId: null, partVariations: [], selectedColorId: null,
                    quantity: 1, isLoadingColors: false, isImageLoading: false,
                    partImageUrl: null, areColorsExpanded: false,
                };
                modalContainer.classList.add('modal-hidden');
                modalContainer.innerHTML = '';
            }
        }, { once: true });
    }
    
    function closeFilterModal() {
        const modalContent = document.getElementById('filter-modal-content');
        if (!modalContent || filterModalContainer.classList.contains('modal-hidden')) {
            return; 
        }
        
        state.isFilterModalOpen = false;
        filterModalContainer.classList.remove('visible');
        modalContent.classList.add('modal-content-leave');
        if (!state.selectedPartId) {
            document.body.classList.remove('overflow-hidden');
        }
        
        modalContent.addEventListener('animationend', () => {
            if (modalContent.classList.contains('modal-content-leave')) {
                filterModalContainer.classList.add('modal-hidden');
                filterModalContainer.innerHTML = '';
            }
        }, { once: true });
    }

    function openModalForPart(partId, groupId, variations) {
        const representativePart = PART_MAP[partId];
        if (!representativePart) { 
            console.error(`Part ${partId} not found in PART_MAP.`);
            return; 
        }
        
        state.selectedPartId = partId;
        state.modal = { 
            partGroupId: groupId,
            partVariations: variations,
            selectedColorId: null, 
            quantity: 1, 
            isLoadingColors: false,
            isImageLoading: false,
            partImageUrl: representativePart.rebrickable_img_url,
            areColorsExpanded: false,
        };
        
        renderModal();
        
        if (!representativePart.availableColorIds) {
            fetchPartColors(representativePart.id);
        } else if (representativePart.availableColorIds.length > 0) {
            const sortedColorIds = sortColorIds(representativePart.availableColorIds, representativePart.id);
            state.modal.selectedColorId = sortedColorIds[0];
            const currentQuantity = state.collection[partId]?.[state.modal.selectedColorId] || 0;
            state.modal.quantity = currentQuantity > 0 ? currentQuantity : 1;
            updateModalPartially({ controls: true });
            fetchPartColorSpecifics(representativePart.id, sortedColorIds[0]);
        }
    }
    
    function refreshWithNewFilters() {
        state.itemsToDisplay = state.itemsIncrement;
        state.isGridStale = true;
        if (state.currentView === 'collection') {
            updateUI();
        } else if (state.searchQuery) {
            searchRebrickableParts(state.searchQuery.trim());
        } else if (state.selectedCategoryId) {
            loadPartsForCategory(state.selectedCategoryId);
        } else {
             updateUI();
        }
    }
    
    document.addEventListener('click', (e) => {
        if (!(e.target instanceof Element)) return;
        const target = e.target;

        if (target.closest('#sidebar-toggle')) {
            clearStatusOnClick();
            state.isSidebarOpen = true;
            updateUI();
            return;
        }
        if (target.closest('#sidebar-close') || target.id === 'sidebar-backdrop') {
            state.isSidebarOpen = false;
            updateUI();
            return;
        }

        const viewButton = target.closest('[data-view]');
        if (viewButton?.dataset.view) {
            clearStatusOnClick();
            const newView = viewButton.dataset.view;
            if (state.currentView === newView) return;

            state.currentView = newView;
            state.searchQuery = '';
            state.searchResultGroups = null;
            state.catalogGroups = null;
            state.selectedCategoryId = null;
            state.selectedCollectionCategoryId = null;
            state.itemsToDisplay = state.itemsIncrement;
            state.isGridStale = true;
            refreshWithNewFilters();
            return;
        }

        const showAllCollectionButton = target.closest('[data-action="show-all-collection"]');
        if (showAllCollectionButton) {
            clearStatusOnClick();
            state.selectedCollectionCategoryId = null;
            state.isGridStale = true;
            updateUI();
            return;
        }

        const parentCategoryButton = target.closest('[data-parent-category]');
        if(parentCategoryButton?.dataset.parentCategory) {
            const groupName = parentCategoryButton.dataset.parentCategory;
            if (state.expandedCategories.has(groupName)) {
                state.expandedCategories.delete(groupName);
            } else {
                state.expandedCategories.add(groupName);
            }
            renderSidebar(); // Only re-render sidebar for performance
            return;
        }

        const categoryButton = target.closest('[data-category-id]');
        if (categoryButton?.dataset.categoryId) {
            const catId = parseInt(categoryButton.dataset.categoryId, 10);
            clearStatusOnClick();
            state.searchQuery = '';
            state.filters = { colorIds: [], inCollectionOnly: false };
            state.sortBy = 'popularity';

            if (state.currentView === 'collection') {
                state.selectedCollectionCategoryId = state.selectedCollectionCategoryId === catId ? null : catId;
                state.isGridStale = true;
                updateUI();
            } else {
                state.selectedCategoryId = state.selectedCategoryId === catId ? null : catId;
                state.selectedCollectionCategoryId = null;
                if (state.selectedCategoryId) {
                    loadPartsForCategory(catId);
                } else {
                    state.catalogGroups = null;
                    state.searchResultGroups = null;
                    state.isGridStale = true;
                    updateUI();
                }
            }
            return;
        }

        if(target.closest('#load-more-button')) {
            state.itemsToDisplay += state.itemsIncrement;
            renderMainContent();
            return;
        }

        if(target.closest('#feeling-lucky-button')) {
            handleFeelingLucky();
            return;
        }
        
        const deleteButton = target.closest('[data-action="delete-from-collection"]');
        if (deleteButton?.dataset.partId && deleteButton.dataset.colorId) {
            handleUpdateCollection(deleteButton.dataset.partId, deleteButton.dataset.colorId, 0);
            return;
        }
        
        const partCard = target.closest('.part-card');
        if (partCard?.dataset.groupId && partCard.dataset.partId) {
            clearStatusOnClick();
            const partId = partCard.dataset.partId;
            const groupId = partCard.dataset.groupId;
            
            const representativePart = PART_MAP[partId];
            if (!representativePart) { return; }

            let variations = [representativePart];
            if (state.currentView === 'catalog') {
                const groupsSource = state.searchResultGroups || state.catalogGroups;
                variations = (groupsSource && groupsSource[groupId]) ? groupsSource[groupId] : [representativePart];
            } else {
                const allParts = Object.values(PART_MAP);
                variations = allParts
                    .filter(p => getGroupId(p.part_num) === groupId)
                    .sort(partRelevanceComparator);
                if (variations.length === 0) variations = [representativePart];
            }
            
            openModalForPart(partId, groupId, variations);
            if (state.currentView === 'collection' && partCard.dataset.colorId) {
                state.modal.selectedColorId = partCard.dataset.colorId;
                const currentQuantity = state.collection[partId]?.[state.modal.selectedColorId] || 0;
                state.modal.quantity = currentQuantity > 0 ? currentQuantity : 1;
                updateModalPartially({ controls: true });
                fetchPartColorSpecifics(partId, state.modal.selectedColorId);
            }
            return;
        }
        
        if (target.id === 'modal-container' || target.closest('#modal-close')) {
            closeModal();
            return;
        }
        
        if (target.id === 'filter-modal-container' || target.closest('#filter-modal-close')) {
            closeFilterModal();
            return;
        }

        if (target.closest('#search-button')) {
            triggerSearch();
            return;
        }
        
        if (target.closest('#clear-search')) {
            state.searchQuery = '';
            document.getElementById('search-input')?.focus();
            triggerSearch();
            return;
        }
        
        if (target.closest('#filter-button')) {
            state.isFilterModalOpen = true;
            tempFilters = {
                filters: JSON.parse(JSON.stringify(state.filters)),
                sortBy: state.sortBy
            };
            renderFilterModal();
            return;
        }

        const filterAction = target.closest('[data-action="remove-filter"]');
        if (filterAction) {
            const type = filterAction.dataset.filterType;
            if (type === 'color') {
                 const colorIdToRemove = filterAction.dataset.colorId;
                 if (colorIdToRemove) {
                    state.filters.colorIds = state.filters.colorIds.filter(id => id !== colorIdToRemove);
                 }
            }
            if (type === 'inCollectionOnly') state.filters.inCollectionOnly = false;
            if (type === 'sortBy') state.sortBy = state.searchQuery ? 'relevance' : 'popularity';
            refreshWithNewFilters();
            return;
        }

        if (target.closest('[data-action="remove-all-filters"]')) {
            state.filters.colorIds = [];
            state.filters.inCollectionOnly = false;
            state.sortBy = state.searchQuery ? 'relevance' : 'popularity';
            refreshWithNewFilters();
            return;
        }

        if (target.closest('#import-button')) { document.getElementById('import-zip-input')?.click(); return; }
        if (target.closest('#export-button')) { handleExportCollection(); return; }

        if (filterModalContainer?.contains(target)) {
            const actionTarget = target.closest('[data-action]');
            if(!actionTarget) return;

            const { action } = actionTarget.dataset;

            switch(action) {
                case 'modal-set-sort':
                    tempFilters.sortBy = actionTarget.value;
                    break;
                case 'modal-toggle-collection':
                    tempFilters.filters.inCollectionOnly = actionTarget.checked;
                    break;
                case 'modal-set-color':
                    const colorId = actionTarget.dataset.colorId;
                    if (colorId === 'null') {
                        tempFilters.filters.colorIds = [];
                    } else {
                        const index = tempFilters.filters.colorIds.indexOf(colorId);
                        if (index > -1) {
                            tempFilters.filters.colorIds.splice(index, 1);
                        } else {
                            tempFilters.filters.colorIds.push(colorId);
                        }
                    }
                    break;
                case 'modal-apply-filters':
                    state.filters = JSON.parse(JSON.stringify(tempFilters.filters));
                    state.sortBy = tempFilters.sortBy;
                    closeFilterModal();
                    refreshWithNewFilters();
                    return;
                case 'modal-reset-filters':
                    tempFilters.filters.colorIds = [];
                    tempFilters.filters.inCollectionOnly = false;
                    tempFilters.sortBy = state.searchQuery ? 'relevance' : 'popularity';
                    break;
            }
            updateFilterModalUI();
        }

        if (modalContainer?.contains(target)) {
            const goToCategoryButton = target.closest('[data-action="go-to-category"]');
            if (goToCategoryButton?.dataset.categoryId) {
                const catId = parseInt(goToCategoryButton.dataset.categoryId, 10);
                
                const parentGroup = state.categoryTree.find(group => group.children.some(child => child.id === catId));
                if (parentGroup) {
                    state.expandedCategories.add(parentGroup.name);
                }

                closeModal();
                setTimeout(() => {
                    state.currentView = 'catalog';
                    state.selectedCollectionCategoryId = null; 
                    loadPartsForCategory(catId);
                }, 200);
                return;
            }

            const colorButton = target.closest('[data-color-id]');
            if (colorButton?.dataset.colorId) {
                const newColorId = colorButton.dataset.colorId;
                if(state.modal.selectedColorId !== newColorId) {
                    // Update selection style
                    const oldSelected = modalContainer.querySelector('.border-blue-500');
                    oldSelected?.classList.remove('border-blue-500', 'scale-110');
                    oldSelected?.classList.add('border-gray-600');
                    colorButton.classList.remove('border-gray-600');
                    colorButton.classList.add('border-blue-500', 'scale-110');
                    
                    state.modal.selectedColorId = newColorId;
                    const currentQuantity = (state.collection[state.selectedPartId]?.[state.modal.selectedColorId]) || 0;
                    state.modal.quantity = currentQuantity > 0 ? currentQuantity : 1;
                    
                    updateModalPartially({ controls: true });
                    fetchPartColorSpecifics(state.selectedPartId, newColorId);
                }
                return;
            }

            const actionButton = target.closest('[data-action]');
            if (actionButton?.dataset.action) {
                const { action } = actionButton.dataset;
                
                if (action === 'expand-colors' || action === 'collapse-colors') {
                    const wrapper = document.getElementById('color-selector-wrapper');
                    if (!wrapper) return;
                    
                    state.modal.areColorsExpanded = (action === 'expand-colors');
                    actionButton.disabled = true;

                    if (state.modal.areColorsExpanded) {
                        wrapper.style.maxHeight = wrapper.scrollHeight + 'px';
                        actionButton.parentElement.innerHTML = `<button data-action="collapse-colors" class="text-blue-400 hover:text-blue-300 hover:underline text-sm font-semibold">Свернуть</button>`;
                    } else {
                        const remainingCount = (PART_MAP[state.selectedPartId]?.availableColorIds || []).length - COLOR_COLLAPSE_THRESHOLD;
                        const pluralizedString = getPluralizedColorString(remainingCount);
                        wrapper.style.maxHeight = '150px';
                        actionButton.parentElement.innerHTML = `<button data-action="expand-colors" class="text-blue-400 hover:text-blue-300 hover:underline text-sm font-semibold">Показать ещё ${remainingCount} ${pluralizedString}</button>`;
                    }
                } else if (action === 'increase-qty') {
                    state.modal.quantity++;
                    updateModalControlsState();
                } else if (action === 'decrease-qty') {
                    state.modal.quantity = Math.max(1, state.modal.quantity - 1);
                    updateModalControlsState();
                } else if (action === 'update-collection' && state.modal.selectedColorId && state.selectedPartId) {
                    handleUpdateCollection(state.selectedPartId, state.modal.selectedColorId, state.modal.quantity);
                } else if (action === 'delete-from-collection-modal' && state.modal.selectedColorId && state.selectedPartId) {
                    handleUpdateCollection(state.selectedPartId, state.modal.selectedColorId, 0);
                    closeModal();
                    return;
                }
            }
        }
    });

    document.addEventListener('input', (e) => {
        if (e.target.id === 'search-input') {
            state.searchQuery = e.target.value;
            const clearButton = document.getElementById('clear-search');
            if (clearButton) {
                clearButton.classList.toggle('hidden', !state.searchQuery);
            }
            if (state.currentView === 'collection') {
                if (state.selectedCollectionCategoryId !== null) {
                    state.selectedCollectionCategoryId = null;
                    renderSidebar();
                }
                state.isGridStale = false; // No animation for client-side filtering
                renderMainContent();
            }
        }
    });
    
    document.addEventListener('keydown', (e) => {
        if (e.target.id === 'search-input' && e.key === 'Enter') {
            e.preventDefault();
            triggerSearch();
        }
        if (e.key === 'Escape') {
             if (state.isFilterModalOpen) {
                closeFilterModal();
             } else if (state.selectedPartId) {
                closeModal();
             }
        }
    });

    document.addEventListener('change', (e) => {
        if (e.target.id === 'import-zip-input') {
            handleZipImport(e);
        }
        if (e.target.id === 'variation-select') {
            const newPartId = e.target.value;
            if (state.selectedPartId === newPartId) return;

            const scrollable = document.getElementById('modal-scroll-area');
            const savedScrollTop = scrollable ? scrollable.scrollTop : 0;
            
            openModalForPart(newPartId, state.modal.partGroupId, state.modal.partVariations);

            requestAnimationFrame(() => {
                const newScrollable = document.getElementById('modal-scroll-area');
                if(newScrollable) {
                    newScrollable.scrollTop = savedScrollTop;
                }
            });
        }
    });

    let lastWindowWidth = window.innerWidth;
    window.addEventListener('resize', () => {
        if (window.innerWidth !== lastWindowWidth) {
            lastWindowWidth = window.innerWidth;
            const isDesktop = window.innerWidth >= 1024;
            if (isDesktop && !state.isSidebarOpen) {
              state.isSidebarOpen = true;
            }
            updateUI();
        }
    });

    // --- INITIALIZATION ---
    async function initializeApp() {
        loadState();
        if (!state.searchQuery) {
            state.sortBy = 'popularity';
        }
        updateUI();
        
        try {
            await Promise.all([
                fetchCategories(),
                fetchAllColors()
            ]);
            
            await fetchMissingCollectionPartDetails();
            await fetchColorDetailsForCollectionParts();
        } catch (error) {
            console.error("Initialization failed:", error);
            state.apiError = error.message;
        } finally {
            state.isLoading = false;
            state.isGridStale = true;
            updateUI();
        }
    }

    initializeApp();
  </script>
</body>
</html>
